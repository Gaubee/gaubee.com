<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Gaubee</title><subtitle>Gaubee&#39;s Articles</subtitle><link href="https://gaubee.com/articles.atom" rel="self"/><link href="https://gaubee.com/"/><updated>2023-03-27T06:36:09Z</updated><id>https://gaubee.com/</id><author><name>Gaubee Bangeel</name></author><entry><title/><link href="https://gaubee.com/articles/%E5%9C%A8%E6%9C%AC%E6%9C%BA%E9%85%8D%E7%BD%AE%20CNAME"/><updated>2023-03-27T06:36:09Z</updated><id>https://gaubee.com/articles/%E5%9C%A8%E6%9C%AC%E6%9C%BA%E9%85%8D%E7%BD%AE%20CNAME</id><content type="html">&lt;h1 id=&quot;%E5%9C%A8%E6%9C%AC%E6%9C%BA%E9%85%8D%E7%BD%AE-cname&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%9C%A8%E6%9C%AC%E6%9C%BA%E9%85%8D%E7%BD%AE%20CNAME#%E5%9C%A8%E6%9C%AC%E6%9C%BA%E9%85%8D%E7%BD%AE-cname&quot;&gt;在本机配置 CNAME&lt;/a&gt;&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装 dnsmasq&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;apt-get&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; dnsmasq&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 dnsmasq&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;vi&lt;/span&gt; /etc/dnsmasq.d/test.conf &lt;span class=&quot;token comment&quot;&gt;# 随便开一个文件&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;填入：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-ini&quot;&gt;&lt;code class=&quot;language-ini&quot;&gt;&lt;span class=&quot;token key attr-name&quot;&gt;cname&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token value attr-value&quot;&gt;from.gaubee.com,to.gaubee.com&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改本地 dns 配置：&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;vi&lt;/span&gt; /etc/resolv.conf&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;# 添加一行 nameserver 127.0.0.1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;最终我自己本地这个文件是这样的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-ini&quot;&gt;&lt;code class=&quot;language-ini&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;# [network]&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;# generateResolvConf = false&lt;/span&gt;&lt;br /&gt;nameserver 127.0.0.1&lt;br /&gt;nameserver 172.19.208.1&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后启动 dnsmasq 即可：&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;/etc/init.d/dnsmasq start&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;它会监听本地 53 断开（DNS 服务的端口），如果报端口占用。那么查看一下占用程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lsof&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-P&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; LISTEN&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content></entry><entry><title>基于AsyncIterator的响应式编程</title><link href="https://gaubee.com/articles/%E5%9F%BA%E4%BA%8EAsyncIterator%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"/><updated>2022-04-18T08:19:46Z</updated><id>https://gaubee.com/articles/%E5%9F%BA%E4%BA%8EAsyncIterator%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B</id><content type="html">&lt;p&gt;最近在重新思考响应式编程的一些事情，其实我很少使用 RxJS，往往是直接手撸各种异步策略。&lt;br /&gt;
因为我自己是更加倾向于使用原生的 async-await/generaor 来实现。因为会有更好的调式支持，性能也会更好。但可维护性可能就不一定，如果没有好好封装，别人读代码的时候，就会比较晦涩。&lt;br /&gt;
虽然 RxJS 在开始的时候也是晦涩，但是至少他们的高级的概念能够很好的复用。&lt;br /&gt;
而像我这种直接手撸的就往往是按照需求来进行编程，阅读者如果对需求没有足够的理解，那这种代码的可维护性可以说是相对比较低的。&lt;/p&gt;
&lt;p&gt;但最近有打算把 RxJS 的一些常见概念和我自己的经验结合起来，写一个基于异步迭代器的响应式编程的库。&lt;br /&gt;
这篇文章就简单的讲一下这个库里头涉及到的一些有趣的经验点。&lt;/p&gt;
&lt;p&gt;首先就是我异步编程时最常使用的 PromiseOut，它是对 promise 的再封装&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PromiseOut&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  resolve&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  reject&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  promise &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;resolve&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;resolve &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; resolve&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;reject &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; reject&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这是一个缩略版的 PromiseOut 代码，完整版的代码过段时间会放出来。（我司开源的相关工作还是推进中，主要是在做一个 typescript 项目管理标准，替代 monorepo……）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它的用法自然也很简单，就是把 Promise 的控制器对外暴露：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; po &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PromiseOut&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; po&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;promise&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着我们正式来聊聊异步迭代器与响应式编程。&lt;br /&gt;
不知道大家记不记得，现在 nodejs/web，对于&lt;code&gt;socket.on(&amp;quot;data&amp;quot;)&lt;/code&gt;这种有了一种新的写法：&lt;br /&gt;
&lt;code&gt;for await(const chunk of socket)&lt;/code&gt;。&lt;br /&gt;
这里我们就实现一个简易版的，来看这段代码：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/**&lt;br /&gt; * 订阅器&lt;br /&gt; * 提供一个流式的变更触发&lt;br /&gt; * 等价于 EventEmitter&lt;br /&gt; * 这里提供基于流式编程的书写方法&lt;br /&gt; */&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sub&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;/**&lt;br /&gt;   * 如果是 true，说明已经发生修改，只是这个改变还没有被拾取&lt;br /&gt;   * 如果是 false，说明改变已经被拾取&lt;br /&gt;   * 如果是 PromiseOut，说明有控制器在等待它&lt;br /&gt;   */&lt;/span&gt;&lt;br /&gt;  changed&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; PromiseOut&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Demo&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; _subs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Set&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Sub&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;/*触发修改*/&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token function&quot;&gt;emitChanged&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sub &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_subs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token comment&quot;&gt;// 如果有等待中的控制器，那么唤醒它&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PromiseOut&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token comment&quot;&gt;// 修改状态值：有改变&lt;/span&gt;&lt;br /&gt;      sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;/**&lt;br /&gt;   * 执行订阅&lt;br /&gt;   */&lt;/span&gt;&lt;br /&gt;  async &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sub&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Sub &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; changed&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_subs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token comment&quot;&gt;/// 如果是 true 那么就重置成 false&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/// 异步迭代器暂停，将控制权转交给外部迭代者&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token comment&quot;&gt;/// 暂停期间可能会被修改成 true（调用了emitChanged）&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token comment&quot;&gt;/// 如果还是 false，说明期间没有发生任何修改&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token comment&quot;&gt;// 创建一个控制器并等待它被唤醒&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PromiseOut&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;promise&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在代码的核心逻辑就是以上这些了，但那段代码是不完整的，因为很明显，&lt;code&gt;Demo._subs: Set&amp;lt;Sub&amp;gt;&lt;/code&gt;这个对象只有&lt;code&gt;add&lt;/code&gt;，没有&lt;code&gt;delete&lt;/code&gt;，所以需要再加上内存释放的逻辑才够完整。&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sub &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; changed&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_subs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/* 核心代码 */&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_subs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不熟悉 AsyncGenerator 的人可能会觉得奇怪，那“核心代码”里头根本没有&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;等关键字，那&lt;code&gt;do-while(true)&lt;/code&gt;能跑出来吗？&lt;br /&gt;
答案是：能，你可以将&lt;code&gt;yield&lt;/code&gt;的关键字理解成是注入外部的代码，类似于函数调用。同时，外部还能有两个特殊的控制函数：&lt;code&gt;asyncGenerator.return&lt;/code&gt;和&lt;code&gt;asyncGenerator.throw&lt;/code&gt;。所以只要外部调用了&lt;code&gt;asyncGenerator.return&lt;/code&gt;，那么&lt;code&gt;finally&lt;/code&gt;块的代码就能被执行。&lt;br /&gt;
比如这段代码：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; changed &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; demo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我们最常用的&lt;code&gt;for-await&lt;/code&gt;循环中，只要退出了循环，不论是用&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;，都会触发&lt;code&gt;asyncGenerator.return&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;好了，至此你觉得上面这段代码完事了吗？&lt;br /&gt;
答案是：没有。&lt;br /&gt;
看这句代码：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 创建一个控制器并等待它被唤醒&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PromiseOut&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;promise&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个 promise 如果一直没有处于 pending 状态，那么&lt;code&gt;asyncGenerator.return&lt;/code&gt;或者&lt;code&gt;asyncGenerator.throw&lt;/code&gt;并不会无缘无故地将之释放掉。&lt;br /&gt;
也就是说&lt;code&gt;finally&lt;/code&gt;的代码一定要等到下一次&lt;code&gt;emitChanged&lt;/code&gt;触发的时候，&lt;code&gt;promiseOut&lt;/code&gt;被&lt;code&gt;resolved&lt;/code&gt;，之后还要再次进入循环，执行到&lt;code&gt;yield&lt;/code&gt;字段这里跳出来。同时被&lt;code&gt;for-await&lt;/code&gt;这时候才会真的跳出来&lt;br /&gt;
以下这段代码可以简单复现这个问题：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// 一秒后执行 emitChanged&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  demo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;emitChanged&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; _ &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; demo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 执行 asyncGenerator.return，但不会马上跳出循环&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// 等待一秒后，这句日志才会被打印&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;demo._subs.size&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; demo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_subs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;size&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以要怎么解决这个问题呢？很简单，我们需要重写&lt;code&gt;asyncGenerator.return&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/**&lt;br /&gt; * 一个特殊的中断信号&lt;br /&gt; */&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;ABORT_SIGNAL&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;abort-signal&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Demo&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; async &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;_subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Sub&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_subs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token comment&quot;&gt;/* 核心代码 */&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;ABORT_SIGNAL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; err&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_subs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/*将原有的subscription方法改成私有，且sub对象由外部传入*/&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token function&quot;&gt;subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sub&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Sub &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; changed&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; subject &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;_subscription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/// 重写 return 函数，确保能够直接地释放掉这个订阅&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; _return &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; subject&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;return&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    subject&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PromiseOut&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;ABORT_SIGNAL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;_return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;subject&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/// 同样的，需要重写 throw 函数&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; _throw &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; subject&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;throw&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    subject&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PromiseOut&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        sub&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;changed&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;_throw&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;subject&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; subject&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，基于&lt;code&gt;AsyncGenerator&lt;/code&gt;的这个事件流就基本开发完成了。&lt;br /&gt;
如果你已经能理解以上的代码，那么接下来需要进阶的，其实就是&lt;code&gt;ReadableStream&lt;/code&gt;，它同样提供了一个控制器，来用更加统一的方式易懂来实现以上代码中&lt;code&gt;PromiseOut&lt;/code&gt;的作用。同时它还有背压的功能，这对于传统的基于事件驱动编程在程序的健壮性上是一个质变的存在，正如&lt;code&gt;try-catch&lt;/code&gt;对于错误处理的重要性一样。这篇文章就不对此展开描述了。&lt;/p&gt;
</content></entry><entry><title>Web 未来技术猜想（一）</title><link href="https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89"/><updated>2021-12-17T09:34:43Z</updated><id>https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89</id><content type="html">&lt;p&gt;对于近十年来 Web 技术的高速发展，很有多精彩的概念与设计涌现出来，但也有很多设计是建立在历史 Web 技术的架构上。&lt;/p&gt;
&lt;p&gt;这间接地导致了浏览器的开发越来越难，现在还存活的浏览器内核也就只剩下 Webkit 和 Blink 了（Firefix 的 Servo 份额实在太小了，开发进度也实在缓慢）……&lt;/p&gt;
&lt;p&gt;即便这两个内核的代码都是开源的，但并不意味着“不垄断”，Web 技术再这样发展下去，只会制造出越来越高的技术壁垒。因为开源并不意味着自由，技术标准的话语权还是掌握在别人手里，你想贡献代码，还得看社区是否“有时间”去接纳，还得有大量的条条框框在限制着你，而反观 Chrome 团队，它们则是能肆无忌惮地往 Chrome 中添加各种实验性功能。从技术层面上来说，技术人的贡献固然是令人尊敬值得肯定，但从资本的层面上来说，这些新技术的堆在这般的堆砌，制造技术壁垒、掌握标准话语权，不正是垄断牟利的老套路吗？&lt;/p&gt;
&lt;p&gt;我这里大胆预测一下，未来 Web 技术一定带来突变。&lt;br /&gt;
或者说这不是预测，是我个人假设要去从头设计一个浏览器，我应该怎么去做。宏观上会分成两大种类的模块来开发：&lt;/p&gt;
&lt;h3 id=&quot;%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8A%9F%E8%83%BD%E6%80%A7%E6%A8%A1%E5%9D%97&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8A%9F%E8%83%BD%E6%80%A7%E6%A8%A1%E5%9D%97&quot;&gt;第一种是功能性模块&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;比如蓝牙模块、HTTP1/2/3 协议模块、USB 模块、摄像头模块等等。对此可以理解成“驱动模块”，但不同的是，驱动模块目的只是将硬件被操作系统的接口所认知，功能性模块还加入了隐私保护的概念，所有的行为对于使用者来说必须是公开透明的。这不是单纯做好“功能授权”与“信息流向透明”就能解决的问题，还是确保用户的身份不被追踪，用户的偏好不被预测等等。&lt;br /&gt;
这类模块由两部分组成：一部分是“原子接口”，一部分是“应用接口”。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其中“原子接口”只能由操作系统提供，类似于操作系统的 API，但是要符合上文所提到的 Web 的隐私安全性的定义。
&lt;blockquote&gt;
&lt;p&gt;Web 开发者可以直接在网页上进行使用 WASM/JS 围绕“原子接口”进行开发。&lt;/p&gt;
&lt;p&gt;比如说摄像头模块的原子接口，可以做到对相机预览功能的二次开发，或者直接拿到 YUV、RGB、RAW 等格式进行处理等等。但现实情况是，每一个物理硬件都有它的特性，我们只能说这些硬件在出厂的时候通过了可用性的测试，但并无法保证所有的硬件都是一致的，所以我们往往需要加入一个理想数据模型，来结合实际硬件的情况，加入一定的偏移与噪点来消除误差，这其实是需要硬件厂商和系统驱动要去解决的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;其次“应用接口”是基于“原子接口”开发出来的应用。首先操作系统会提供一套默认的“应用接口”，正因为将浏览器的开发成本嫁接到操作系统上，并将之模块化，才有可能将浏览器的开发成本大大降低。
&lt;blockquote&gt;
&lt;p&gt;同时第三方开发者通用也可以在“原子接口”确保安全性与隐私性的基础上使用原生的指令集进行二次开发，这种第三方开发的原生应用，可以上架到应用市场。正如我们可以去设置&lt;code&gt;mailto:&lt;/code&gt;邮件协议的处理程序一样。&lt;/p&gt;
&lt;p&gt;虽然是原生开发，但是并不代表可以绕过“原子接口”去直接使用更加底层的操作系统接口，毕竟是 Web 技术，一定要确保隐私性与安全性。&lt;/p&gt;
&lt;p&gt;但是在应用市场上，会有明确需要通过功能测试与基准测试才能正式上架，在下载的时候，用户也可以看到测试的分数，在功能性与性能之间做出选择。同时也正式因为只能基于“原子接口”，牺牲少量性能换来了更高的安全性，用户不用担心使用第三方摄像头功能模块的时候，数据会被悄悄泄露上传到别的地方去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;对于 Web 开发者如何使用这些功能模块呢？
&lt;ol&gt;
&lt;li&gt;一般情况下会直接使用“应用接口”。大部分接口使用时都需要经过授权；部分接口会有明确的状态信息限制；也会有接口调用日志。&lt;/li&gt;
&lt;li&gt;但是开发者无法拿到接口开发商的信息，因为这些信息很有可能被当作指纹来识别。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8&quot;&gt;第二种是浏览器内核&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;它是一个综合性的模块，也是开发难度最大的模块，它的作用就是定义 Web 技术最基础的输入与输出。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于输入，就是要将键盘、鼠标、触摸、陀螺仪、摄影、声音、环境亮度等输入信号抽象定义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发者无法拿到这些信号的源头（比如键盘的型号、鼠标的型号等等），只能拿到这些输入的值，比如用户点击了屏幕上的哪里，使用手点击的还是鼠标点击的，点击的力度是多大等等，这种是数值。&lt;/li&gt;
&lt;li&gt;有时候这些值还会在精度允许的范围内做一定的模糊，特别是跟现实有关的值，不允许过高的精度（如果需要也需要通过用户允许），以防止有站点采集这些信息作为指纹识别。
&lt;blockquote&gt;
&lt;p&gt;比如说我们可以使用陀螺仪，实现对心跳频率的识别，识别出你是年轻人还是老人，从而做出差异化体验，这种模糊识别是允许的。&lt;/p&gt;
&lt;p&gt;但是要知道，每个人心跳就跟指纹一样，都会有细微的差别，如果陀螺仪的精度过高，那么在 AI 技术的加持下，很有可能就能更进一步精确识别出个体。&lt;br /&gt;
如果这种机制存在，黑客或者一些大型企业就能通过一些手段，在很多网页上注入它们的监控算法，将这些信息收集，只要收集的时间够长，这时候你的个人隐私就与裸奔无异了。你的生活里的信息很可能会被人引导、控制、甚至攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于输出，就是要将画面，音频、震动等信息的输出方式进行封装。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;其中最难的就是“画面”的输出了，虽然我对计算机图形编程并没有多少研究，但是对于 Web 渲染我有一定的使用心得。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请我允许我偏执地认为，HTML+CSS 的绘制，曾经是一种很棒的标准，它除了绘制的功能，还提供了屏幕可读的功能，这对于对于视力障碍人群是很友好的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但现在我并不在觉得它是优秀的设计，Web2.0 蓬勃发展，已经加入了太多太多功能，因为其过去的封闭性，所以标准制定者需要对这些标准的兼容性负责，所以它们现在实在过于膨胀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好在现在有人在开放性上一直做出努力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WebComponent 在一定程度上已经能满足大部分场景，新的提案也一直在推进。&lt;/li&gt;
&lt;li&gt;而 CSS Houdini 的发展则有些迟缓，但我相信它正在以正确的方式在解决问题，它的野心很大，需要开放“解析”、“布局”、“绘制”、“合成”的过程，所以难度自然更大。
&lt;blockquote&gt;
&lt;p&gt;相信未来新的 CSS、HTML 标准应该只能属于“功能性模块“而不是“浏览器内核”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;软件的高内聚与硬件的高内聚并不一样，硬件是会有损耗的，所以当我们更新硬件时，拿到的就是一个全新的设备。&lt;br /&gt;
而软件的问题，则是会跟着历史的进程去向下兼容下去。如果软件保持高内聚而不开放，这就会导致软件的功能会越来越臃肿。相反的如果使用开放的架构，我们可以明确地定义新的标准，果断地遗弃过去的功能，对于兼容性，就直接由过去的功能模块来做就好。新的标准可以更加专注于小范围领域内的逻辑自洽的设计就好了，这也能使之拥有更高的性能，同时也拥有更少的成本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未来，HTML 会专注于表单、结构化、屏幕可读性，这可以让人们基本没有 CSS 的辅助，也能基于这些文本与超文本标记语言，理解到网页的大体内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而 CSS，则是会更进一步融合 canvas-2d/webgl/webgpu 等绘制功能来提供更棒的视觉体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息的输入，则是会围绕 HTML 来展开捕获，而后将之传递给 CSS。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;综合以上关于技术的几点构想，假如真的成立，那么未来浏览器与 Web 技术的发展会有这几种趋势特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发一个浏览器的成本会越来越低。低到一个人也能通过整个开源社区来独立实现一个比较高效的 Web 浏览器。&lt;/li&gt;
&lt;li&gt;性能与原生差距很低。基于浏览器的二次开发会称为原生软件的开发标准，比如可以替换“功能性模块”来实现更进一步的性能与体验的升级。&lt;/li&gt;
&lt;li&gt;浏览器会更加省电。
&lt;ol&gt;
&lt;li&gt;这也是因为浏览器的模块协同机制的改变，操作系统可以更加精细地调控对各个模块电源的使用来进一步省电，比如降低触摸与鼠标的输入频率。&lt;/li&gt;
&lt;li&gt;Web 技术的历史包袱会更小，对于过时的技术，本身就是存在过过去的硬件性能水平下，那么对于当下的硬件水平，我们可以只提供更少的资源，在确保功能正常的情况下同时省电。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;向兼容性不再是困扰开发者的事情。
&lt;ol&gt;
&lt;li&gt;一方面是浏览器架构的升级，升级核心组件会变得更加简单；&lt;/li&gt;
&lt;li&gt;另一方开发者可以更加激进地不去考虑兼容性的问题，想要使用新的技术，只需要操作系统后台去安装这些模块即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;用户会有更多的选择权与话语权。体现在用户可以更加轻松地杜绝个人信息盗取，这也会为整个互联网的发展带来更加良性的循环，而不是靠着贩卖用户信息牟利。&lt;/li&gt;
&lt;/ol&gt;
</content></entry><entry><title>CSS“文字”渐变，一种比background-clip通用性更好的方案，可以用于SVG中（CSS svg icon gradients, a more versatile solution than background-clip）</title><link href="https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89"/><updated>2021-08-05T15:19:04Z</updated><id>https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89</id><content type="html">&lt;h2 id=&quot;%E7%A4%BA%E4%BE%8B-demo&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E7%A4%BA%E4%BE%8B-demo&quot;&gt;示例 Demo&lt;/a&gt;&lt;/h2&gt;
&lt;main id=&quot;demo&quot;&gt;
  &lt;div id=&quot;text-container&quot;&gt;
    &lt;div class=&quot;gradient-text&quot;&gt;
    SOME
    &lt;svg class=&quot;icon&quot; style=&quot;width: 1em;height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;8288&quot;&gt;&lt;path d=&quot;M512 0C230.4 0 0 230.4 0 512s230.4 512 512 512 512-230.4 512-512S793.6 0 512 0z m0 939.2c-235.2 0-427.2-192-427.2-427.2S276.8 84.8 512 84.8s427.2 192 427.2 427.2-192 427.2-427.2 427.2zM320 363.2m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0ZM704 363.2m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0ZM734.4 555.2H289.6c-17.6 0-33.6 8-46.4 20.8s-17.6 33.6-12.8 51.2C256 763.2 376 857.6 512 857.6s256-97.6 281.6-230.4c4.8-17.6 0-33.6-12.8-51.2-12.8-12.8-30.4-20.8-46.4-20.8zM512 772.8c-84.8 0-161.6-56-187.2-132.8H704c-30.4 81.6-107.2 132.8-192 132.8z&quot; p-id=&quot;8289&quot;&gt;&lt;/path&gt;&lt;/svg&gt;
    TEXT
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;controllers&quot;&gt;
    &lt;fieldset&gt;
      &lt;legend&gt;背景色 Background Color&lt;/legend&gt;
      &lt;input id=&quot;bg-color&quot; type=&quot;color&quot; /&gt;
      &lt;script&gt;
        const bindInputColor = (selector, cssProperty, defaultValue) =&gt; {
          const ele = document.querySelector(selector);
          ele.oninput = () =&gt; demo.style.setProperty(cssProperty, ele.value);
          ele.value = defaultValue;
          ele.oninput();
        };
        bindInputColor(&quot;#bg-color&quot;, &quot;--background-color&quot;, &quot;#ffffff&quot;);
      &lt;/script&gt;
    &lt;/fieldset&gt;
    &lt;fieldset&gt;
      &lt;legend&gt;渐变色 Gradient Color&lt;/legend&gt;
      &lt;label for=&quot;start-color&quot;&gt;开始色 Start Color&lt;/label&gt;
      &lt;input id=&quot;start-color&quot; type=&quot;color&quot; /&gt;
      &lt;label for=&quot;end-color&quot;&gt;结束色 End Color&lt;/label&gt;
      &lt;input id=&quot;end-color&quot; type=&quot;color&quot; /&gt;
      &lt;script&gt;
        bindInputColor(&quot;#start-color&quot;, &quot;--gradient-color-start&quot;, &quot;#1f00ff&quot;);
        bindInputColor(&quot;#end-color&quot;, &quot;--gradient-color-end&quot;, &quot;#ff0000&quot;);
      &lt;/script&gt;
    &lt;/fieldset&gt;
  &lt;/div&gt;
  &lt;style&gt;
    #demo {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #text-container {
      --gradient-color: linear-gradient(
        45deg,
        var(--gradient-color-start),
        var(--gradient-color-end)
      );
      background-color: var(--background-color);
      font-size: 3em;
      font-weight: bold;
      display: inline-block;
    }
    #text-container .gradient-text {
      display: flex;
      align-items: center;
    }
    #text-container .gradient-text {
      background: var(--gradient-color);
      color: var(--background-color);
      position: relative;
      mix-blend-mode: difference;
    }
    #text-container .gradient-text::before {
      content: &quot; &quot;;
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: inherit;
      mix-blend-mode: difference;
      pointer-events: none;
    }
    .controllers {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      width: 100%;
    }
    .controllers fieldset {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
  &lt;/style&gt;
&lt;/main&gt;
&lt;h2 id=&quot;%E8%B5%B7%E5%9B%A0-the-story&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E8%B5%B7%E5%9B%A0-the-story&quot;&gt;起因 The Story&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;探究这个问题的起因，是源于我打算把公司的图标从 font 逐步转化成 svg。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;My plan is convert the company&#39;s icon from font to svg gradually.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然绘制性能有所下降，但是整体的好处是比 font 多得多的：比如“按需引入”，“多色”，“动画”，“可访问性”等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although the drawing performance maybe reduced, the overall benefits are much more than font: &amp;quot;dynamic import&amp;quot;, &amp;quot;multi-color&amp;quot;, &amp;quot;animation&amp;quot;, &amp;quot;accessibility&amp;quot;, etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但之前使用&lt;code&gt;background-clip:text&lt;/code&gt;的方案就不好用了，因为默认情况下，svg 的 path 使用的是&lt;code&gt;fill=&amp;quot;currentColor&amp;quot;&lt;/code&gt;这样的写法。诸多原因，我不得不思考较好的替代的方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But the previous solution of using &lt;code&gt;background-clip:text&lt;/code&gt; doesn&#39;t work well,&lt;br /&gt;
because by default, svg&#39;s path use &lt;code&gt;fill=&amp;quot;currentColor&amp;quot;&lt;/code&gt;. For many reasons, I&lt;br /&gt;
had to think of a better alternative.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%81%9A%E6%B3%95-usage&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E5%81%9A%E6%B3%95-usage&quot;&gt;做法 Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;核心思路是使用&lt;code&gt;mix-blend-mode&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The core idea is to use &lt;code&gt;mix-blend-mode&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;gradient-text&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;SOME TEXT&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token selector&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;--bg-color&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token selector&quot;&gt;.gradient-text&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;--gradient-color&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;--bg-color&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; relative&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;mix-blend-mode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; difference&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token selector&quot;&gt;.gradient-text::before&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; block&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; absolute&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 0&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 0&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 0&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 0&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; inherit&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;mix-blend-mode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; difference&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;pointer-events&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; none&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E5%8E%9F%E7%90%86-principle&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E5%8E%9F%E7%90%86-principle&quot;&gt;原理 Principle&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;DEMO 中，一共有三层定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;body&lt;/code&gt;：我们称之为 &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gradient-text&lt;/code&gt;：我们称之为 &lt;code&gt;CONTENT-LAYER-1&lt;/code&gt; ，它由两部分组成：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;CONTENT-BG-1&lt;/code&gt; ：绘制着我们定义的&lt;code&gt;var(--gradient-color)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONTENT-INNER-2&lt;/code&gt; ：绘制着我们的文本、svg 等内容&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gradient-text::before&lt;/code&gt;：我们称之为 &lt;code&gt;TOP-LAYER-3&lt;/code&gt; ；&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;In Demo, There are three layers defined:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;body&lt;/code&gt;: we call it &lt;code&gt;TOP-LAYER-0&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gradient-text&lt;/code&gt;: we call it &amp;quot;&lt;code&gt;CONTENT-LAYER-1&lt;/code&gt;&amp;quot; and it consists of two parts:
&lt;ol&gt;
&lt;li&gt;&amp;quot;&lt;code&gt;CONTENT-BG-1&lt;/code&gt;&amp;quot;: draws the &lt;code&gt;var(--gradient-color)&lt;/code&gt; we defined&lt;/li&gt;
&lt;li&gt;&amp;quot;&lt;code&gt;CONTENT-INNER-2&lt;/code&gt;&amp;quot;: drawing our text, svg, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gradient-text::before&lt;/code&gt;: we call it &lt;code&gt;TOP-LAYER-3&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以这里总共有四种景受到影响，我们可以逐一推理每一种景发生的混合：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So there are a total of four layer affected here, and we can reason about the mix one by one.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TOP-LAYER-0-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ^ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;；
&lt;ol&gt;
&lt;li&gt;∵ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; == &lt;code&gt;TOP-LAYER-3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;∴ &lt;code&gt;TOP-LAYER-0-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONTENT-BG-1-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ^ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;∵ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;∴ &lt;code&gt;CONTENT-BG-1-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONTENT-INNER-2-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ^ &lt;code&gt;CONTENT-INNER-2&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;∵ &lt;code&gt;TOP-LAYER-0&lt;/code&gt; == &lt;code&gt;CONTENT-INNER-2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;∴ &lt;code&gt;CONTENT-INNER-2-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-3&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TOP-LAYER-3-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ^ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;∵ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; == &lt;code&gt;TOP-LAYER-3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;∴ &lt;code&gt;TOP-LAYER-3-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到， &lt;code&gt;TOP-LAYER-0-RES&lt;/code&gt; 、 &lt;code&gt;CONTENT-BG-1-RES&lt;/code&gt; 、 &lt;code&gt;TOP-LAYER-3-RES&lt;/code&gt; 最终都等于 &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ，所以它们看上去跟直接看到 &lt;code&gt;TOP-LAYER-0&lt;/code&gt; 的效果一样。像是透明层一般。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As you can see, &lt;code&gt;TOP-LAYER-0-RES&lt;/code&gt;, &lt;code&gt;CONTENT-BG-1-RES&lt;/code&gt;, and &lt;code&gt;TOP-LAYER-3-RES&lt;/code&gt; end up being equal to &lt;code&gt;TOP-LAYER-0&lt;/code&gt;, so they look the same as if you see &lt;code&gt;TOP-LAYER-0&lt;/code&gt; directly. It looks like a transparent layer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只剩下 &lt;code&gt;CONTENT-INNER-2-RES&lt;/code&gt; 绘制的是 &lt;code&gt;TOP-LAYER-3&lt;/code&gt; 的内容，也就是我们最终需要的渐变色。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Only &lt;code&gt;CONTENT-INNER-2-RES&lt;/code&gt; is left to draw the contents of &lt;code&gt;TOP-LAYER-3&lt;/code&gt;, which is the gradient color we eventually need.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E7%BC%BA%E9%99%B7-defects&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E7%BC%BA%E9%99%B7-defects&quot;&gt;缺陷 Defects&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;因为使用混合模式，它需要小心元素所在的父级。如果父级是一个复杂的图层，比如有复杂的背景，那么这个方案就无法生效了。所以父级最好是白色或者黑色&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Because using blend mode, it needs to be careful about the parent layer where the element is located. If the parent is a complex layer, for example with a complex background, then this scheme will not work. so the parent layer should preferably be white or black.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;渐变的颜色不可以是带有透明通道的颜色，但由于这个方案本身就对背景颜色有明确的要求，所以这点可以间接规避。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;The color of the gradient cannot with alpha, but the good thing is that we explicitly require the background color, so this can be circumvented indirectly.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%B0%8F%E6%8F%90%E7%A4%BA-tip&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E5%B0%8F%E6%8F%90%E7%A4%BA-tip&quot;&gt;小提示 Tip&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在复杂的图层中，你可以需要这个 css 属性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In complex layers, you can need this css property:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token selector&quot;&gt;.gradient-text-parent&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;isolation&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; isolate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>初识go-wasm</title><link href="https://gaubee.com/articles/%E5%88%9D%E8%AF%86go%EF%BC%8Dwasm"/><updated>2021-04-22T12:53:00Z</updated><id>https://gaubee.com/articles/%E5%88%9D%E8%AF%86go%EF%BC%8Dwasm</id><content type="html">&lt;p&gt;https://github.com/Gaubee/big-json-parser&lt;/p&gt;
</content></entry><entry><title>Comlink-v2</title><link href="https://gaubee.com/articles/Comlink%EF%BC%8Dv2"/><updated>2021-07-22T23:59:26Z</updated><id>https://gaubee.com/articles/Comlink%EF%BC%8Dv2</id><content type="html">&lt;p&gt;我是Comlink-v1的重度用户，并在我的公司重努力推广它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am a heavy user of Comlink-v1 and have worked hard to promote it at my company.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它很棒，但仍然有一些问题，比如使用者必须知道它背后的工作原理，有时候还会因为参数传递时，对其进行序列化或者反序列化时引发一些低级的错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&#39;s great, but still has some issues, such as the user having to know how it works behind the scenes, and sometimes triggering some low-level errors when serializing or deserializing it when passing parameters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总的来说，Comlink-v1虽然有些瑕疵，但他解决了很多问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Overall, Comlink-v1 has some flaws, but it solves a lot of problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近我重新思考Comlink-v1存在的一些缺陷，并且尝试对它进行重新实现。在几经尝试后，不得不说，那些缺陷真的很难规避，为此我不得不牺牲它的通用性。所以最终我还是将Comlink-v2给实现了出来。可惜的是我不能将源码公布出来，但我可以提供基础的实现思路。我相信，这个新的思路会给js领域带来新的魔力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Recently I&#39;ve been rethinking some of the flaws in Comlink-v1 and trying to re-implement it. After a few attempts, I have to say that those flaws are really hard to avoid, and for that I had to sacrifice its versatility. So I finally implemented Comlink-v2. Unfortunately I can&#39;t publish the source code, but I can provide the basic idea of the implementation. I believe that this new idea will bring new magic to the JS field.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88-effect-preview&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88-effect-preview&quot;&gt;效果预览 Effect Preview&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这是已经通过测试的代码：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is the code that has been tested:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure&gt;&lt;img src=&quot;https://gaubee.com/img/comlink-v2/effect-preview.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; height=&quot;1706&quot; loading=&quot;lazy&quot; /&gt;&lt;figcaption&gt;Effect Preview&lt;/figcaption&gt;&lt;/figure&gt;
&lt;h2 id=&quot;%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-implementation-approach&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-implementation-approach&quot;&gt;实现思路 Implementation approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;众所周知，Comlink-v1使用&lt;code&gt;await&lt;/code&gt;来隐式调用&lt;code&gt;then&lt;/code&gt;函数的特性来实现的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As you know, Comlink-v1 uses the feature of &lt;code&gt;await&lt;/code&gt; to implicitly call the &lt;code&gt;then&lt;/code&gt; function to do this.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Comlink-v2中，我努力将所有异步给消除了。众所周知，在js中，同步是异步特性的根基，也正因此我们能将&lt;code&gt;async/await&lt;/code&gt;编译成es5的代码来运行。所以理论上，只要在comlink重摆脱了异步的依赖，那么就彻底拥有了更多的语言特性。比如 &lt;code&gt;instanceof&lt;/code&gt;、&lt;code&gt;prop in obj&lt;/code&gt; 等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Comlink-v2, I tried to eliminate all asynchrony. As you know, synchronization is the basis of asynchronous features in js, and that&#39;s why we can compile &lt;code&gt;async/await&lt;/code&gt; into es5 code and run it. so theoretically, once we get rid of the asynchronous dependency in comlink, we have more features in the language. For example, &lt;code&gt;instanceof&lt;/code&gt;, &lt;code&gt;prop in obj&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为此，我使用&lt;code&gt;Atomic.wait/notify&lt;/code&gt;这对API来实现。当然，在浏览器中，它必须在web-worker中才能正常使用。这确实带来了一些局限性，但相信我，最终的Comlink-v2所带来的特性将会把这些局限性间接消除。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For this, I use the &lt;code&gt;Atomic.wait/notify&lt;/code&gt; pair of APIs. Of course, it has to work in a web-worker to work in a browser. This does introduce some limitations, but believe me, the features that will eventually come with Comlink-v2 will indirectly remove these limitations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Atomic-API的加持下，我们现在可以将一个worker暂停，等待其它线程执行完再将之唤醒。因此，你现在可以完全使用Proxy的魔力了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With the addition of Atomic-API, we can now pause a worker and wait for other threads to finish executing before waking it up. So you can now use the full magic of Proxy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-specific-implementation&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-specific-implementation&quot;&gt;具体实现方法 Specific implementation&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;接下来，要做工作主要有三方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are three main areas of work to be done next.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;要将数据分成三类：cloneable（string、number、boolean、bigint、null、undefined）；symbol；reference（object、function）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;To divide data into three categories: cloneable (string, number, boolean, bigint, null, undefined); symbol; reference (object, function)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;使用Atomic来进行通讯&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Using Atomic for communication&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;内存的引用与释放&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Reference and release of memory&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Comlink-v2中，我们&lt;strong&gt;不再需要注册数据的序列化与反序列化，因为我们拥抱了同步&lt;/strong&gt;。所以对于reference，我们统一使用Proxy来实现，这样能直接消除Comlink-v1的存有的各种副作用。正如你只是在同一个isolate中对一个引用对象进行代理一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Comlink-v2, we &lt;strong&gt;no longer need serialization and deserialization of registration data, because we embrace synchronization&lt;/strong&gt;. So for references, we use a unified Proxy implementation, which directly eliminates the various side effects present in Comlink-v1. Just as you would just proxy a reference object in the same isolate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其次，就是symbol这个比较特殊的类型。我们无法对symbol进行Proxy代理，但依赖symbol的特性，在不同isolate中的symbol本身就是不共享的，我们可以在不同的isolate中创建一个副本，并为其注册唯一的id。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Secondly, there is the rather special type of symbol. We can&#39;t Proxy symbols, but relying on the properties of symbols, which are themselves unshared in different isolate, we can create a copy of the symbol in a different isolate and register a unique id for it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于Symbol有两点要注意：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are two things to note about Symbol:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;要使用&lt;code&gt;Symbol.keyFor&lt;/code&gt;来判断是否是使用&lt;code&gt;Symbol.for&lt;/code&gt;创建的；&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;To use &lt;code&gt;Symbol.keyFor&lt;/code&gt; to determine if it was created using &lt;code&gt;Symbol.for&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;我们还需要预先对&lt;code&gt;Symbol.iterator,Symbol.hasInstance...&lt;/code&gt;这些特殊的symbol进行预先注册。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;We also need to pre-register the special symbols &lt;code&gt;Symbol.iterator,Symbol.hasInstance... &lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们来谈谈如何使用Atomic来进行通讯：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Next let&#39;s talk about how to use Atomic for communication.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们需要一个&lt;code&gt;shareArrayBuffer&lt;/code&gt;，它用于存储两个线程通讯所需要的全部数据。但是我们不应该使用轮询到方式来让另一个线程知晓何时开始处理数据，所以我们还需要一个&lt;code&gt;messageChannel&lt;/code&gt;，它的作用是用来通知另一个线程开始处理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;First we need a &lt;code&gt;shareArrayBuffer&lt;/code&gt;, which is used to store all the data needed for the two workers to communicate. But we shouldn&#39;t use polling to let the other worker know when to start processing the data, so we also need a &lt;code&gt;messageChannel&lt;/code&gt;, which is used to inform the other thread to start processing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// write message size and content to shareAreayBuffer...&lt;/span&gt;&lt;br /&gt;msgPort&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMesaage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;Please wake me up&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;Atomic&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sab_i32a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// read result from shareArrayBuffer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来就会遇到一个问题，就是调用堆栈的问题。执行一个任务，两个线程可能需要进行多次的交互。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The next problem that comes up is the problem of calling the stack. Executing a task, two threads may need to interact multiple times.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我的解决方案是：记录调用堆栈长度：&lt;br /&gt;
So my solution is to record the call stack lengths:&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// write message size and content to shareAreayBuffer...&lt;/span&gt;&lt;br /&gt;msgPort&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMesaage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;Please wake me up&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; stackLen &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; sab_i32a&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;Atomic&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sab_i32a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// loop&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sab_i32a&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; stackLen &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// read result from shareArrayBuffer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，也是最重要的一点。因为我们模拟了JavaScript中的引用对象，所以，当我们导入一个对象，那么它就会被注册，也就意味着无法主动释放，如果强制释放，可能会造成其它线程使用&lt;code&gt;refId&lt;/code&gt;（引用ID）来寻找时，才发现对象被释放，造成异常。&lt;br /&gt;
对此，我的解决方案是 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef&quot;&gt;WeakRef&lt;/a&gt; + &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry&quot;&gt;FinalizationRegistry&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lastly, and most importantly. Since we simulate reference objects in JavaScript, when we import an object, then it is registered, which means that it cannot be actively released, and if it is forced to be released, it may cause an exception when other threads use &lt;code&gt;refId&lt;/code&gt; (reference ID) to look for it, only to find that the object is released.&lt;br /&gt;
For this, my solution is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef&quot;&gt;WeakRef&lt;/a&gt; + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry&quot;&gt;FinalizationRegistry&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只需要监听引用者的内存释放，从而来通知数据提供方的释放对象即可。唯一遗憾的是，我们无法监听&lt;code&gt;symbol&lt;/code&gt;的释放。所以这点要特别注意，不要让两个线程交互过多的&lt;code&gt;symbol&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You only need to listen to the referrer&#39;s memory release to notify the data provider of the released object. The only unfortunate thing is that we can&#39;t listen for &lt;code&gt;symbol&lt;/code&gt; releases. So be careful not to let two workers interact with too many &lt;code&gt;symbol&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-programming-skill&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-programming-skill&quot;&gt;编程技巧 Programming skill&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;虽然我们使用了同步作为基础作为通讯，但为了可以让其有更加丰富的使用场景，我们也应该支持异步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although we use synchronous as the basis for communication, we should also support asynchronous in order to have a richer use case for it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何让同一套代码同时兼容异步和同步呢？我的建议是使用callback：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;How can we make the same set of code compatible with both asynchronous and synchronous? My suggestion would be to use callback.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// sync&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;flow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dosomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;res&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;_res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;callback ❤️ sync&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// async&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;Promise&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cb&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;flow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dosomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;callback ❤️ async&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E5%B1%95%E6%9C%9B-look-ahead&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E5%B1%95%E6%9C%9B-look-ahead&quot;&gt;展望 Look ahead&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最后我来聊一聊它的一些特性所将带来的影响：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Let me conclude by talking about the impact that some of its features will have:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在浏览器中，我们完全可以使用Comlink-v2来代理主线程。从而将业务完全运行在web-worker中。但因为浏览器的局限性，我们需要结合同步和异步的接口来进行实现。这点很像在nodejs中开发native插件。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;In the browser, we could have used Comlink-v2 to proxy the main thread. This allows us to run the business entirely in the web-worker. But because of browser limitations, we need to combine synchronous and asynchronous interfaces to do so. This is much like developing native plugins in nodejs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;我觉得这可以作为JavaScript并发的实现，它可以给我们带来很多想象。虽然Comlink-v1已经做到，但是同步的接口将会更加自然，开发者使用时，局限性更少：想象一下erlang的特性将会基于此实现～&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;I think this can be implemented as JavaScript concurrency, it can give us a lot to imagine. Although Comlink-v1 already does this, the synchronous interface will be more natural and less restrictive for developers to use: imagine the features of erlang will be based on this implementation ~!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;因为少了注册模型的序列化与反序列化，所以它与其它语言更容易交互。（事实上这正是我们公司将要做的事情）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Because there is less serialization and deserialization of registration models, it is easier to interact with other languages. (In fact this is exactly what we are going to do at our company.)&lt;/p&gt;
&lt;/blockquote&gt;
</content></entry><entry><title>封装异步编程中时间的理念</title><link href="https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5"/><updated>2020-09-22T11:17:53Z</updated><id>https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5</id><content type="html">&lt;p&gt;异步编程，本质就是要充分利用时间。但现代异步编程对于时间仍旧是一个很片面的理解，比如关于“超时异常”，我们往往只是定义一个 30s，超过这个时间就是失败。而所谓“健壮的异步程序”，往往也只是堆砌地使用这些定时器而已，这里头缺乏了一个“系统地时间理念”来规范时间的使用与等待。&lt;/p&gt;
&lt;p&gt;从业务或者功能等角度，可以定义出各种时间的概念，比如渲染的、网络的、磁盘的等待。&lt;br /&gt;
但进一步解剖，其实可以用两种时间概念来替代：&lt;br /&gt;
&lt;strong&gt;“我自己花费的时间”&lt;/strong&gt; 与 &lt;strong&gt;“我等待别人的时间”&lt;/strong&gt;&lt;br /&gt;
进一步简化就是：&lt;strong&gt;“计算时间”&lt;/strong&gt; 与 &lt;strong&gt;“等待时间”&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这里我是以一个“程序包”的角度去理解时间，无关“线程/进程”、“网络”、“磁盘”等待。&lt;br /&gt;
接下来一边分享我的理解，一边进行编程所需要的设计封装。&lt;/p&gt;
&lt;h2 id=&quot;%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%EF%BC%88%E6%88%91%E8%87%AA%E5%B7%B1%E8%8A%B1%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5#%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%EF%BC%88%E6%88%91%E8%87%AA%E5%B7%B1%E8%8A%B1%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89&quot;&gt;计算时间（我自己花费的时间）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;和人一样，如果自己是在做正确的事情，那么我们不会认为自己在浪费时间，自己也就没必要给自己“计算耗时”，毕竟“正确的事情”是最总要的，计算耗时反而会转移自己的注意力，不是“正确的事情”。&lt;br /&gt;
所以我们不会去给“计算时间”挂上计时钩子，而是一个程序的执行消耗多少时间也不是固定的，会被设备的状态所影响，比如低电量、一个 CPU 线程中有多个程序在切换调度互相争夺资源 等等。&lt;br /&gt;
但是程序之间可以互相统计对方消耗了多少时间，由此来做出自己的判断。不过这一步往往是“系统内核”在做的，因为是它在决策程序的调度，所以它应该统计并记录每一个程序的执行时间、压力状态。&lt;br /&gt;
这些信息都将帮助整个系统变得更加的稳健，而不是单一地使用超时来决策接下来的作业。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A&quot;&gt;举个例子：&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前段时间我就遇到一个 BUG，我封装了一个请求，如果请求超时，那么过一会儿再去请求。结果超时的不是别人，而是自己的封装中，有一些需要进行排队的验证。其实请求的结果已经返回了，而因为排队时间过长导致上层的流程认为需要重试，结果就又重新发起了一次请求，而后请求的结果又一次排队验证，外层又一次认为超时……一般来说因为验证很快，所以不会出现这样的恶性循环，但因为验证模块是共用的，所以很可能被其它模块的调用给塞满任务。&lt;br /&gt;
一个复杂的系统中，出现异常的原因很多，各种模块都有自己的异常情况，如果我一段程序依赖了其它三种模块，那难不成我要考虑这三种模块的所有可能涉及的异常吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;理论上来说我们确实可以通过抽象封装来简化一个已经依赖了很多程序的程序。再通过缓存结果、合并请求等等手段来进行加固。但这样的程序结构在愈发庞大的时候，仍然是包含着内耗的。这就是是为什么很多系统，一开始跑着没问题，跑着跑着就只能“重启”了。&lt;br /&gt;
因为“封装”本就是人面对复杂系统的一种简化措施，它需要配合各种缓存优化才能达到一个更高的可用性。而缓存优化本身就是以一种带有副作用的行为。比如说我们调用缓存时，内存不够了怎么办？一般来说都是没有后路地去写下程序吧，没内存了，重启吧……正是因为大量没有系统性的规范操作，才导致了一个系统无法长时间地运转，当然我们也看过那种自动重启来解决问题的。自动重启在有分布式集群的时候确实蛮实用，但这篇文章探讨的是如何在一开始就规避这些问题，而不是如何补救。&lt;br /&gt;
所以解决问题最好的方法之一，就是面对它们！而不是一味地迷信于一个程序自己“封装”的力量。&lt;br /&gt;
如果“人”不能直接做到对所有依赖程序的异常处理进行最优解，那么这就应该交给系统去做。&lt;br /&gt;
一个程序一个模块对于异常，不应该自己藏着掖着，因为它自己不知道下游的需求场景，所以它最好是暴露出相关的信息。这些信息经过系统统筹，以及调用堆栈的层层决策之后，才有一个真正意义上正确的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以刚才的例子来说：点击按钮发起一个请求，理想中，它应该 0.5s~1s 内就返回结果了，结果到了 800ms 还是没有响应，这时候这个按钮应该要知道，到底出现了什么问题，好让用户能去及时做出一些更加正确的决策，而不是再让用户白白浪费时间。在传统系统中，上游程序并不知道下游发生了什么，但如果系统能告知按钮程序：“其实数据请求已经返回了，是验证排队满了，而验证排队满了是因为另外一个程序在大量调度，可能需要再等上 2s。”当用户得知了这些信息，这时候就等于将选择权交给了用户，让用户有事情可以做了。这对于整个系统长远来说是更益处的，一方面是在当下，模块之间（包括人）可以做出更加正确的事情，另一方面，大量的决策信息，在使用人工智能加持后，对于使用者来说就会越来越好用。比如下次还是遇到这种情况的话，用户愿意等，而且在等待之后的事情并不是与其它程序竞争资源，那么也许就可以让用户插个队~~&lt;/p&gt;
&lt;p&gt;从刚才的例子也可以看出，这里头最重要的其实是“沟通的艺术”。说白了就是，一个模块一个人，如果 ta 想要做决策，那么它需要的是什么样的信息？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;再举个例子：对于&lt;strong&gt;渲染程序&lt;/strong&gt;，往往就是我们的主线程在承载。当我们位于子线程中的逻辑运算过慢的时候，渲染程序并不需要为什么算得慢，而是只是想向用户反应“计算慢了”这个信息。通过这个信息，它可以通过延长动画时间，来向用户表达当前设备的计算压力，也借由这些动画，可以用来减慢用户的操作速度，进而减缓计算模块的响应压力。从而达成一个正循环的机制。所以，在这里，它需要的信息是：“程序现在有多慢”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这与刚才按钮程序想要知道“为什么慢”，这里就说明一个模块所需要的信息就是不一样的。包括人这个模块也是，人能决策的只是 ta 自身能操作的东西，比如开关程序、操作程序、等待结果。比如读一个文件，卡了，系统不应该用户：“磁盘现在很忙，因为&lt;code&gt;system.logs&lt;/code&gt;模在疯狂写入”。而是应该说：“&lt;code&gt;视频&lt;/code&gt;程序导致了文件读取比较慢，可能还需要再等 3 秒钟”。亦或者你直接跟一个正在读写磁盘的程序说一些主板才能听懂的话，那也没意义。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%EF%BC%88%E6%88%91%E7%AD%89%E5%BE%85%E5%88%AB%E4%BA%BA%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5#%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%EF%BC%88%E6%88%91%E7%AD%89%E5%BE%85%E5%88%AB%E4%BA%BA%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89&quot;&gt;等待时间（我等待别人的时间）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这其实包含了“别人的计算时间”以及“信息传输时间”。当我们在讨论：处理”等待时间“过长问题的时候，并不是在处理异常，而是将这种定义成非理想流程的执行。过去我们一直将这类流程统一归纳成了错误或者异常，总是想用各种省时省力的方法将它们扭转到所谓“正确的流程上来”，却忘了一分耕耘一分收获。若不认真对待它们，特别是当它们在复杂系统中，自然而然就会混沌起来。&lt;br /&gt;
所以我不建议将它们当成错误或者异常，而是将它们作为正常且必须面对的流程来处理。所以下文我们用“异流”来对其进称呼。&lt;/p&gt;
&lt;p&gt;你可以看到其实有些编程语言就有考虑过这样的设计，比如 Go。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但它是通过多返回值来传递错误，这也是不得已的设计，虽然被人诟病，但其背后的理念支持是多少 BUG 堆叠而来的。可 Go 的哲学导致对它的设计过于简单，所以对于开发者来说，反而也会变得复杂和迷糊。&lt;br /&gt;
还有，大部分静态编程语言都能有根据类型进行捕捉的能力。但这种写法很容易造成雪崩效应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们才需要一个系统的理念来处理它们，上文提到很重要的一点：在异流中，我们需要根据不同的场景来得到不同的信息。&lt;br /&gt;
所以这里我们先对信息进行定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上下文信息
&lt;blockquote&gt;
&lt;p&gt;这点可以用“程序堆栈”来理解，但准确说堆栈只是描述了“上文”，它可以让我们知道已经走过了哪些程序，消耗了多少的资源，“下文”是指它即将做什么任务，即将消耗哪些资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;统计信息
&lt;blockquote&gt;
&lt;p&gt;这里是指对于资源消耗的统计。&lt;br /&gt;
补充一下对于资源的定义：不同的程序、模块是可以自己定义资源的，也可以将自己的资源消耗细分成到某一种资源下的子资源。所以从程序角度来说：资源是一种全局的不断累积或者不断变化的变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们以上文“渲染层动画时长”的实现为例：&lt;/p&gt;
&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token atrule&quot;&gt;&lt;span class=&quot;token rule&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;only&lt;/span&gt; resouce-usage &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;module-name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;my.logic&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;80%&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token property&quot;&gt;--base-transform-duraction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 400ms&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token atrule&quot;&gt;&lt;span class=&quot;token rule&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;only&lt;/span&gt; resouce-usage &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;module-name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;my.logic&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;50%&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token property&quot;&gt;--base-transform-duraction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 100ms&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token atrule&quot;&gt;&lt;span class=&quot;token rule&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;only&lt;/span&gt; resouce-usage &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;module-name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;my.logic&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;20%&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token property&quot;&gt;--base-transform-duraction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 30ms&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;待续~&lt;/em&gt;&lt;/p&gt;
</content></entry><entry><title>浅谈Web Worker关闭的问题</title><link href="https://gaubee.com/articles/%E6%B5%85%E8%B0%88Web%20Worker%E5%85%B3%E9%97%AD%E7%9A%84%E9%97%AE%E9%A2%98"/><updated>2020-05-24T08:46:02Z</updated><id>https://gaubee.com/articles/%E6%B5%85%E8%B0%88Web%20Worker%E5%85%B3%E9%97%AD%E7%9A%84%E9%97%AE%E9%A2%98</id><content type="html">&lt;p&gt;Web Worker是没有提供onclose事件的，但它有提供terminate函数。&lt;br /&gt;
可能官方很自信地觉得Worker只要是用户销毁的，那么就没必要onclose……但其实昨天就遇到这个问题了（在Cordova-Ionic-Webview里头），就是从后台唤起程序，WebWorker没响应了，被杀了……在调试控制台已经看不到这个Worker的身影。&lt;br /&gt;
解决办法我想有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原生层面入手，去监控有什么系统层面的回调会触发&lt;/li&gt;
&lt;li&gt;改成用ServiceWorker试一下&lt;/li&gt;
&lt;li&gt;监控WebWorker的销毁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了简单且通用起见，我先选择了3。&lt;br /&gt;
但其实在官方接口里头是没有相关的接口的，这就只能另辟蹊径。&lt;br /&gt;
一开始我想到的是研究MessageChannel。因为从接口层面来说，它们几乎是一出的，也许底层实现是一样的。&lt;br /&gt;
所以就去研究如何识别MessageChannel是close状态的。最糟糕的方式估计就是pingpong，但这就得额外增加脏代码。&lt;br /&gt;
后来忽然想到transferable这个标准，所以就有了以下的骚操作：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ArrayBuffer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;port1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;byteLength&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果MessagePort是开启的状态，内存对象会被顺利传输，从而打印“0”。否则如果打印“1”，就说明MessagePort已经被关闭。&lt;br /&gt;
用这个方法去实验WebWorker。理论上几乎是一个东西吧……事实却是即便WebWorker执行了terminate，ArrayBuffer仍旧会被传输过去……这就很恐怖了，错觉自己是不是遇上了浏览器内存泄漏的问题……一搜索其实github上三四年前就已经有人提出了，到现在仍旧没有音讯。实在不理解terminate居然没有销毁消息管道……那我发送到子进程的ArrayBuffer到底发到哪里了呢?&lt;/p&gt;
&lt;p&gt;既然这条路不通，我就再换一个操作。我想terminate至少会销毁WebWorker中所有的Promise吧。故而我想起了有这个一个API：LockManager 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 我后来测试在使用&lt;code&gt;new Worker(&#39;data:text/javascript;,&#39;)&lt;/code&gt;这样的&lt;code&gt;data:&lt;/code&gt;协议下的Worker环境，是不支持的。建议还是用https协议。&lt;br /&gt;
它的用法很简单，虽然还是需要在子进程中注入代码，但至少也比pingpong的方案好，毕竟Worker就是要用来执行密集型任务，哪里还能保障一定能返回pingpong呢。所以只要在子进程启动后，执行一个永远不释放的request，然后发一个信号告知主进程开始监听这个request：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/// worker&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; lockReqId &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;process-live-&#39;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;Date&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;locks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lockReqId&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;Promise&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lockReqId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;/// master&lt;/span&gt;&lt;br /&gt;worker&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;message&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; me&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; me&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;string&#39;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; me&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;startsWith&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;process-live-&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;locks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;me&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      worker&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dispatchEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CloseEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;close&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方案几乎是完美的。因为是直接跟js引擎的销毁与否进行绑定。不过它只有chrome69+才支持。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;不过pingpong只能识别出Worker不响应，它可能繁忙。如果没有预期中的响应，应该将是否重启WebWorker&lt;/p&gt;
</content></entry><entry><title>发现几个很棒的开源项目</title><link href="https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"/><updated>2020-05-07T07:29:48Z</updated><id>https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE</id><content type="html">&lt;h2 id=&quot;isomorphic-git&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE#isomorphic-git&quot;&gt;&lt;a href=&quot;https://isomorphic-git.org/&quot;&gt;Isomorphic-Git&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用js实现的git，与git保持完全的兼容&lt;/p&gt;
&lt;h2 id=&quot;storybook&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE#storybook&quot;&gt;&lt;a href=&quot;https://www.learnstorybook.com/&quot;&gt;Storybook&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一个管理组件的工具，能部署在本地项目中，方便测试人员进行测试、开发人员互相了解、设计师进行审查&lt;/p&gt;
&lt;h2 id=&quot;warriorjs&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE#warriorjs&quot;&gt;&lt;a href=&quot;https://warriorjs.com/&quot;&gt;WarriorJS&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;编程游戏，用编程来通关&lt;/p&gt;
</content></entry><entry><title>Promise.race会带来内存泄露</title><link href="https://gaubee.com/articles/Promise.race%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"/><updated>2020-04-23T01:02:06Z</updated><id>https://gaubee.com/articles/Promise.race%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2</id><content type="html">&lt;p&gt;假若有两个promise: a, b，现在它们都&lt;code&gt;Promise.race([a,b])&lt;/code&gt;所包裹。&lt;br /&gt;
此时，如果a先完成了resolve，race也就有了返回值。&lt;br /&gt;
然而，b却迟迟没有被resolve或者reject……&lt;br /&gt;
结果会带来隐式的内存问题，就是a看上去被释放了，但其实没有。&lt;br /&gt;
v8论坛上有类似的bug提交：https://bugs.chromium.org/p/v8/issues/detail?id=9858&lt;/p&gt;
&lt;p&gt;简单地模拟一下实现：&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;race&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;promises&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; p &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; promises&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      p&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;resolve&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我实际测试了一下，一些不同版本的v8似乎会有不同的表现，但终归是内存泄漏了，只是好像v12的是直接泄漏了捕捉不到，v13是能在内存堆栈里头看到。&lt;br /&gt;
我在工作的时候发现这个问题也是靠async_hooks的异步资源监控下才看到这个问题的存在。&lt;/p&gt;
&lt;p&gt;解决方案其实也不难，核心问题就是消除引用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先我们需要一个&lt;code&gt;Promise.prototype.safeThen&lt;/code&gt;的实现，因为&lt;code&gt;Promise.prototype.then&lt;/code&gt;是会返回出一个新的promise的。做法其实就是只使用一次then来代理实现。其返回值就是&lt;code&gt;thened: { resolves: Set&amp;lt;Function&amp;gt;, rejects: Set&amp;lt;Function&amp;gt;, isFinished: boolean }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接着我们基于&lt;code&gt;safeThen&lt;/code&gt;来实现&lt;code&gt;Promise.safePromiseRace&lt;/code&gt;，重点在于收集thened对象，并主动进行释放：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function safePromiseRace(...promises){
  return new Promise((resolve, reject)=&amp;gt;{
    const thenedList = []
    const finished = ()=&amp;gt;{
      thenedList.forEach(thened=&amp;gt;{
        thened.resolves.delete(safeResolve);
        thened.rejects.delete(safeReject);
      })
    }
    const safeResolve = (v)=&amp;gt;{resolve(v); finished();}
    const safeReject = (v)=&amp;gt;{reject(v); finished();}
    for(const p of promises){
      thenedList.push(p.safeThen(safeResolve, safeReject))
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
</content></entry></feed>