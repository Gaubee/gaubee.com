<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Gaubee</title><subtitle>Gaubee&#39;s Articles</subtitle><link href="https://gaubee.com/articles.atom" rel="self"/><link href="https://gaubee.com/"/><updated>2021-12-17T07:57:59Z</updated><id>https://gaubee.com/</id><author><name>Gaubee Bangeel</name></author><entry><title>Web 未来技术猜想（一）</title><link href="https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89"/><updated>2021-12-17T09:34:43Z</updated><id>https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89</id><content type="html">&lt;p&gt;对于近十年来 Web 技术的高速发展，很有多精彩的概念与设计涌现出来，但也有很多设计是建立在历史 Web 技术的架构上。&lt;/p&gt;
&lt;p&gt;这间接地导致了浏览器的开发越来越难，现在还存活的浏览器内核也就只剩下 Webkit 和 Blink 了（Firefix 的 Servo 份额实在太小了，开发进度也实在缓慢）……&lt;/p&gt;
&lt;p&gt;即便这两个内核的代码都是开源的，但并不意味着“不垄断”，Web 技术再这样发展下去，只会制造出越来越高的技术壁垒。因为开源并不意味着自由，技术标准的话语权还是掌握在别人手里，你想贡献代码，还得看社区是否“有时间”去接纳，还得有大量的条条框框在限制着你，而反观 Chrome 团队，它们则是能肆无忌惮地往 Chrome 中添加各种实验性功能。从技术层面上来说，技术人的贡献固然是令人尊敬值得肯定，但从资本的层面上来说，这些新技术的堆在这般的堆砌，制造技术壁垒、掌握标准话语权，不正是垄断牟利的老套路吗？&lt;/p&gt;
&lt;p&gt;我这里大胆预测一下，未来 Web 技术一定带来突变。&lt;br /&gt;
或者说这不是预测，是我个人假设要去从头设计一个浏览器，我应该怎么去做。宏观上会分成两大种类的模块来开发：&lt;/p&gt;
&lt;h3 id=&quot;%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8A%9F%E8%83%BD%E6%80%A7%E6%A8%A1%E5%9D%97&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8A%9F%E8%83%BD%E6%80%A7%E6%A8%A1%E5%9D%97&quot;&gt;第一种是功能性模块&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;比如蓝牙模块、HTTP1/2/3 协议模块、USB 模块、摄像头模块等等。对此可以理解成“驱动模块”，但不同的是，驱动模块目的只是将硬件被操作系统的接口所认知，功能性模块还加入了隐私保护的概念，所有的行为对于使用者来说必须是公开透明的。这不是单纯做好“功能授权”与“信息流向透明”就能解决的问题，还是确保用户的身份不被追踪，用户的偏好不被预测等等。&lt;br /&gt;
这类模块由两部分组成：一部分是“原子接口”，一部分是“应用接口”。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其中“原子接口”只能由操作系统提供，类似于操作系统的 API，但是要符合上文所提到的 Web 的隐私安全性的定义。
&lt;blockquote&gt;
&lt;p&gt;Web 开发者可以直接在网页上进行使用 WASM/JS 围绕“原子接口”进行开发。&lt;/p&gt;
&lt;p&gt;比如说摄像头模块的原子接口，可以做到对相机预览功能的二次开发，或者直接拿到 YUV、RGB、RAW 等格式进行处理等等。但现实情况是，每一个物理硬件都有它的特性，我们只能说这些硬件在出厂的时候通过了可用性的测试，但并无法保证所有的硬件都是一致的，所以我们往往需要加入一个理想数据模型，来结合实际硬件的情况，加入一定的偏移与噪点来消除误差，这其实是需要硬件厂商和系统驱动要去解决的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;其次“应用接口”是基于“原子接口”开发出来的应用。首先操作系统会提供一套默认的“应用接口”，正因为将浏览器的开发成本嫁接到操作系统上，并将之模块化，才有可能将浏览器的开发成本大大降低。
&lt;blockquote&gt;
&lt;p&gt;同时第三方开发者通用也可以在“原子接口”确保安全性与隐私性的基础上使用原生的指令集进行二次开发，这种第三方开发的原生应用，可以上架到应用市场。正如我们可以去设置&lt;code&gt;mailto:&lt;/code&gt;邮件协议的处理程序一样。&lt;/p&gt;
&lt;p&gt;虽然是原生开发，但是并不代表可以绕过“原子接口”去直接使用更加底层的操作系统接口，毕竟是 Web 技术，一定要确保隐私性与安全性。&lt;/p&gt;
&lt;p&gt;但是在应用市场上，会有明确需要通过功能测试与基准测试才能正式上架，在下载的时候，用户也可以看到测试的分数，在功能性与性能之间做出选择。同时也正式因为只能基于“原子接口”，牺牲少量性能换来了更高的安全性，用户不用担心使用第三方摄像头功能模块的时候，数据会被悄悄泄露上传到别的地方去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;对于 Web 开发者如何使用这些功能模块呢？
&lt;ol&gt;
&lt;li&gt;一般情况下会直接使用“应用接口”。大部分接口使用时都需要经过授权；部分接口会有明确的状态信息限制；也会有接口调用日志。&lt;/li&gt;
&lt;li&gt;但是开发者无法拿到接口开发商的信息，因为这些信息很有可能被当作指纹来识别。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8&quot;&gt;第二种是浏览器内核&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;它是一个综合性的模块，也是开发难度最大的模块，它的作用就是定义 Web 技术最基础的输入与输出。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于输入，就是要将键盘、鼠标、触摸、陀螺仪、摄影、声音、环境亮度等输入信号抽象定义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发者无法拿到这些信号的源头（比如键盘的型号、鼠标的型号等等），只能拿到这些输入的值，比如用户点击了屏幕上的哪里，使用手点击的还是鼠标点击的，点击的力度是多大等等，这种是数值。&lt;/li&gt;
&lt;li&gt;有时候这些值还会在精度允许的范围内做一定的模糊，特别是跟现实有关的值，不允许过高的精度（如果需要也需要通过用户允许），以防止有站点采集这些信息作为指纹识别。
&lt;blockquote&gt;
&lt;p&gt;比如说我们可以使用陀螺仪，实现对心跳频率的识别，识别出你是年轻人还是老人，从而做出差异化体验，这种模糊识别是允许的。&lt;/p&gt;
&lt;p&gt;但是要知道，每个人心跳就跟指纹一样，都会有细微的差别，如果陀螺仪的精度过高，那么在 AI 技术的加持下，很有可能就能更进一步精确识别出个体。&lt;br /&gt;
如果这种机制存在，黑客或者一些大型企业就能通过一些手段，在很多网页上注入它们的监控算法，将这些信息收集，只要收集的时间够长，这时候你的个人隐私就与裸奔无异了。你的生活里的信息很可能会被人引导、控制、甚至攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于输出，就是要将画面，音频、震动等信息的输出方式进行封装。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;其中最难的就是“画面”的输出了，虽然我对计算机图形编程并没有多少研究，但是对于 Web 渲染我有一定的使用心得。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请我允许我偏执地认为，HTML+CSS 的绘制，曾经是一种很棒的标准，它除了绘制的功能，还提供了屏幕可读的功能，这对于对于视力障碍人群是很友好的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但现在我并不在觉得它是优秀的设计，Web2.0 蓬勃发展，已经加入了太多太多功能，因为其过去的封闭性，所以标准制定者需要对这些标准的兼容性负责，所以它们现在实在过于膨胀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好在现在有人在开放性上一直做出努力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WebComponent 在一定程度上已经能满足大部分场景，新的提案也一直在推进。&lt;/li&gt;
&lt;li&gt;而 CSS Houdini 的发展则有些迟缓，但我相信它正在以正确的方式在解决问题，它的野心很大，需要开放“解析”、“布局”、“绘制”、“合成”的过程，所以难度自然更大。
&lt;blockquote&gt;
&lt;p&gt;相信未来新的 CSS、HTML 标准应该只能属于“功能性模块“而不是“浏览器内核”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;软件的高内聚与硬件的高内聚并不一样，硬件是会有损耗的，所以当我们更新硬件时，拿到的就是一个全新的设备。&lt;br /&gt;
而软件的问题，则是会跟着历史的进程去向下兼容下去。如果软件保持高内聚而不开放，这就会导致软件的功能会越来越臃肿。相反的如果使用开放的架构，我们可以明确地定义新的标准，果断地遗弃过去的功能，对于兼容性，就直接由过去的功能模块来做就好。新的标准可以更加专注于小范围领域内的逻辑自洽的设计就好了，这也能使之拥有更高的性能，同时也拥有更少的成本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未来，HTML 会专注于表单、结构化、屏幕可读性，这可以让人们基本没有 CSS 的辅助，也能基于这些文本与超文本标记语言，理解到网页的大体内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而 CSS，则是会更进一步融合 canvas-2d/webgl/webgpu 等绘制功能来提供更棒的视觉体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息的输入，则是会围绕 HTML 来展开捕获，而后将之传递给 CSS。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Web%20%E6%9C%AA%E6%9D%A5%E6%8A%80%E6%9C%AF%E7%8C%9C%E6%83%B3%EF%BC%88%E4%B8%80%EF%BC%89#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;综合以上关于技术的几点构想，假如真的成立，那么未来浏览器与 Web 技术的发展会有这几种趋势特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发一个浏览器的成本会越来越低。低到一个人也能通过整个开源社区来独立实现一个比较高效的 Web 浏览器。&lt;/li&gt;
&lt;li&gt;性能与原生差距很低。基于浏览器的二次开发会称为原生软件的开发标准，比如可以替换“功能性模块”来实现更进一步的性能与体验的升级。&lt;/li&gt;
&lt;li&gt;浏览器会更加省电。
&lt;ol&gt;
&lt;li&gt;这也是因为浏览器的模块协同机制的改变，操作系统可以更加精细地调控对各个模块电源的使用来进一步省电，比如降低触摸与鼠标的输入频率。&lt;/li&gt;
&lt;li&gt;Web 技术的历史包袱会更小，对于过时的技术，本身就是存在过过去的硬件性能水平下，那么对于当下的硬件水平，我们可以只提供更少的资源，在确保功能正常的情况下同时省电。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;向兼容性不再是困扰开发者的事情。
&lt;ol&gt;
&lt;li&gt;一方面是浏览器架构的升级，升级核心组件会变得更加简单；&lt;/li&gt;
&lt;li&gt;另一方开发者可以更加激进地不去考虑兼容性的问题，想要使用新的技术，只需要操作系统后台去安装这些模块即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;用户会有更多的选择权与话语权。体现在用户可以更加轻松地杜绝个人信息盗取，这也会为整个互联网的发展带来更加良性的循环，而不是靠着贩卖用户信息牟利。&lt;/li&gt;
&lt;/ol&gt;
</content></entry><entry><title>CSS“文字”渐变，一种比background-clip通用性更好的方案，可以用于SVG中（CSS svg icon gradients, a more versatile solution than background-clip）</title><link href="https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89"/><updated>2021-08-05T15:19:04Z</updated><id>https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89</id><content type="html">&lt;h2 id=&quot;%E7%A4%BA%E4%BE%8B-demo&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E7%A4%BA%E4%BE%8B-demo&quot;&gt;示例 Demo&lt;/a&gt;&lt;/h2&gt;
&lt;main id=&quot;demo&quot;&gt;
  &lt;div id=&quot;text-container&quot;&gt;
    &lt;div class=&quot;gradient-text&quot;&gt;
    SOME
    &lt;svg class=&quot;icon&quot; style=&quot;width: 1em;height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;8288&quot;&gt;&lt;path d=&quot;M512 0C230.4 0 0 230.4 0 512s230.4 512 512 512 512-230.4 512-512S793.6 0 512 0z m0 939.2c-235.2 0-427.2-192-427.2-427.2S276.8 84.8 512 84.8s427.2 192 427.2 427.2-192 427.2-427.2 427.2zM320 363.2m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0ZM704 363.2m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0ZM734.4 555.2H289.6c-17.6 0-33.6 8-46.4 20.8s-17.6 33.6-12.8 51.2C256 763.2 376 857.6 512 857.6s256-97.6 281.6-230.4c4.8-17.6 0-33.6-12.8-51.2-12.8-12.8-30.4-20.8-46.4-20.8zM512 772.8c-84.8 0-161.6-56-187.2-132.8H704c-30.4 81.6-107.2 132.8-192 132.8z&quot; p-id=&quot;8289&quot;&gt;&lt;/path&gt;&lt;/svg&gt;
    TEXT
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;controllers&quot;&gt;
    &lt;fieldset&gt;
      &lt;legend&gt;背景色 Background Color&lt;/legend&gt;
      &lt;input id=&quot;bg-color&quot; type=&quot;color&quot; /&gt;
      &lt;script&gt;
        const bindInputColor = (selector, cssProperty, defaultValue) =&gt; {
          const ele = document.querySelector(selector);
          ele.oninput = () =&gt; demo.style.setProperty(cssProperty, ele.value);
          ele.value = defaultValue;
          ele.oninput();
        };
        bindInputColor(&quot;#bg-color&quot;, &quot;--background-color&quot;, &quot;#ffffff&quot;);
      &lt;/script&gt;
    &lt;/fieldset&gt;
    &lt;fieldset&gt;
      &lt;legend&gt;渐变色 Gradient Color&lt;/legend&gt;
      &lt;label for=&quot;start-color&quot;&gt;开始色 Start Color&lt;/label&gt;
      &lt;input id=&quot;start-color&quot; type=&quot;color&quot; /&gt;
      &lt;label for=&quot;end-color&quot;&gt;结束色 End Color&lt;/label&gt;
      &lt;input id=&quot;end-color&quot; type=&quot;color&quot; /&gt;
      &lt;script&gt;
        bindInputColor(&quot;#start-color&quot;, &quot;--gradient-color-start&quot;, &quot;#1f00ff&quot;);
        bindInputColor(&quot;#end-color&quot;, &quot;--gradient-color-end&quot;, &quot;#ff0000&quot;);
      &lt;/script&gt;
    &lt;/fieldset&gt;
  &lt;/div&gt;
  &lt;style&gt;
    #demo {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #text-container {
      --gradient-color: linear-gradient(
        45deg,
        var(--gradient-color-start),
        var(--gradient-color-end)
      );
      background-color: var(--background-color);
      font-size: 3em;
      font-weight: bold;
      display: inline-block;
    }
    #text-container .gradient-text {
      display: flex;
      align-items: center;
    }
    #text-container .gradient-text {
      background: var(--gradient-color);
      color: var(--background-color);
      position: relative;
      mix-blend-mode: difference;
    }
    #text-container .gradient-text::before {
      content: &quot; &quot;;
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: inherit;
      mix-blend-mode: difference;
      pointer-events: none;
    }
    .controllers {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      width: 100%;
    }
    .controllers fieldset {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
  &lt;/style&gt;
&lt;/main&gt;
&lt;h2 id=&quot;%E8%B5%B7%E5%9B%A0-the-story&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E8%B5%B7%E5%9B%A0-the-story&quot;&gt;起因 The Story&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;探究这个问题的起因，是源于我打算把公司的图标从 font 逐步转化成 svg。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;My plan is convert the company&#39;s icon from font to svg gradually.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然绘制性能有所下降，但是整体的好处是比 font 多得多的：比如“按需引入”，“多色”，“动画”，“可访问性”等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although the drawing performance maybe reduced, the overall benefits are much more than font: &amp;quot;dynamic import&amp;quot;, &amp;quot;multi-color&amp;quot;, &amp;quot;animation&amp;quot;, &amp;quot;accessibility&amp;quot;, etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但之前使用&lt;code&gt;background-clip:text&lt;/code&gt;的方案就不好用了，因为默认情况下，svg 的 path 使用的是&lt;code&gt;fill=&amp;quot;currentColor&amp;quot;&lt;/code&gt;这样的写法。诸多原因，我不得不思考较好的替代的方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But the previous solution of using &lt;code&gt;background-clip:text&lt;/code&gt; doesn&#39;t work well,&lt;br /&gt;
because by default, svg&#39;s path use &lt;code&gt;fill=&amp;quot;currentColor&amp;quot;&lt;/code&gt;. For many reasons, I&lt;br /&gt;
had to think of a better alternative.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%81%9A%E6%B3%95-usage&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E5%81%9A%E6%B3%95-usage&quot;&gt;做法 Usage&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;核心思路是使用&lt;code&gt;mix-blend-mode&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The core idea is to use &lt;code&gt;mix-blend-mode&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;gradient-text&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;SOME TEXT&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token selector&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;--bg-color&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token selector&quot;&gt;.gradient-text&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;--gradient-color&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;--bg-color&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; relative&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;mix-blend-mode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; difference&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token selector&quot;&gt;.gradient-text::before&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; block&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; absolute&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 0&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 0&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 0&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 0&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; inherit&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;mix-blend-mode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; difference&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;pointer-events&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; none&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E5%8E%9F%E7%90%86-principle&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E5%8E%9F%E7%90%86-principle&quot;&gt;原理 Principle&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;DEMO 中，一共有三层定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;body&lt;/code&gt;：我们称之为 &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gradient-text&lt;/code&gt;：我们称之为 &lt;code&gt;CONTENT-LAYER-1&lt;/code&gt; ，它由两部分组成：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;CONTENT-BG-1&lt;/code&gt; ：绘制着我们定义的&lt;code&gt;var(--gradient-color)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONTENT-INNER-2&lt;/code&gt; ：绘制着我们的文本、svg 等内容&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gradient-text::before&lt;/code&gt;：我们称之为 &lt;code&gt;TOP-LAYER-3&lt;/code&gt; ；&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;In Demo, There are three layers defined:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;body&lt;/code&gt;: we call it &lt;code&gt;TOP-LAYER-0&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gradient-text&lt;/code&gt;: we call it &amp;quot;&lt;code&gt;CONTENT-LAYER-1&lt;/code&gt;&amp;quot; and it consists of two parts:
&lt;ol&gt;
&lt;li&gt;&amp;quot;&lt;code&gt;CONTENT-BG-1&lt;/code&gt;&amp;quot;: draws the &lt;code&gt;var(--gradient-color)&lt;/code&gt; we defined&lt;/li&gt;
&lt;li&gt;&amp;quot;&lt;code&gt;CONTENT-INNER-2&lt;/code&gt;&amp;quot;: drawing our text, svg, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gradient-text::before&lt;/code&gt;: we call it &lt;code&gt;TOP-LAYER-3&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以这里总共有四种景受到影响，我们可以逐一推理每一种景发生的混合：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So there are a total of four layer affected here, and we can reason about the mix one by one.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TOP-LAYER-0-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ^ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;；
&lt;ol&gt;
&lt;li&gt;∵ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; == &lt;code&gt;TOP-LAYER-3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;∴ &lt;code&gt;TOP-LAYER-0-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONTENT-BG-1-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ^ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;∵ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;∴ &lt;code&gt;CONTENT-BG-1-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONTENT-INNER-2-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ^ &lt;code&gt;CONTENT-INNER-2&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;∵ &lt;code&gt;TOP-LAYER-0&lt;/code&gt; == &lt;code&gt;CONTENT-INNER-2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;∴ &lt;code&gt;CONTENT-INNER-2-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-3&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TOP-LAYER-3-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ^ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; ^ &lt;code&gt;TOP-LAYER-3&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;∵ &lt;code&gt;CONTENT-BG-1&lt;/code&gt; == &lt;code&gt;TOP-LAYER-3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;∴ &lt;code&gt;TOP-LAYER-3-RES&lt;/code&gt; = &lt;code&gt;TOP-LAYER-0&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到， &lt;code&gt;TOP-LAYER-0-RES&lt;/code&gt; 、 &lt;code&gt;CONTENT-BG-1-RES&lt;/code&gt; 、 &lt;code&gt;TOP-LAYER-3-RES&lt;/code&gt; 最终都等于 &lt;code&gt;TOP-LAYER-0&lt;/code&gt; ，所以它们看上去跟直接看到 &lt;code&gt;TOP-LAYER-0&lt;/code&gt; 的效果一样。像是透明层一般。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As you can see, &lt;code&gt;TOP-LAYER-0-RES&lt;/code&gt;, &lt;code&gt;CONTENT-BG-1-RES&lt;/code&gt;, and &lt;code&gt;TOP-LAYER-3-RES&lt;/code&gt; end up being equal to &lt;code&gt;TOP-LAYER-0&lt;/code&gt;, so they look the same as if you see &lt;code&gt;TOP-LAYER-0&lt;/code&gt; directly. It looks like a transparent layer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只剩下 &lt;code&gt;CONTENT-INNER-2-RES&lt;/code&gt; 绘制的是 &lt;code&gt;TOP-LAYER-3&lt;/code&gt; 的内容，也就是我们最终需要的渐变色。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Only &lt;code&gt;CONTENT-INNER-2-RES&lt;/code&gt; is left to draw the contents of &lt;code&gt;TOP-LAYER-3&lt;/code&gt;, which is the gradient color we eventually need.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E7%BC%BA%E9%99%B7-defects&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E7%BC%BA%E9%99%B7-defects&quot;&gt;缺陷 Defects&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;因为使用混合模式，它需要小心元素所在的父级。如果父级是一个复杂的图层，比如有复杂的背景，那么这个方案就无法生效了。所以父级最好是白色或者黑色&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Because using blend mode, it needs to be careful about the parent layer where the element is located. If the parent is a complex layer, for example with a complex background, then this scheme will not work. so the parent layer should preferably be white or black.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;渐变的颜色不可以是带有透明通道的颜色，但由于这个方案本身就对背景颜色有明确的要求，所以这点可以间接规避。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;The color of the gradient cannot with alpha, but the good thing is that we explicitly require the background color, so this can be circumvented indirectly.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%B0%8F%E6%8F%90%E7%A4%BA-tip&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/CSS%E2%80%9C%E6%96%87%E5%AD%97%E2%80%9D%E6%B8%90%E5%8F%98%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%AF%94background%EF%BC%8Dclip%E9%80%9A%E7%94%A8%E6%80%A7%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%88CSS%20svg%20icon%20gradients,%20a%20more%20versatile%20solution%20than%20background%EF%BC%8Dclip%EF%BC%89#%E5%B0%8F%E6%8F%90%E7%A4%BA-tip&quot;&gt;小提示 Tip&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在复杂的图层中，你可以需要这个 css 属性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In complex layers, you can need this css property:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token selector&quot;&gt;.gradient-text-parent&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token property&quot;&gt;isolation&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; isolate&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>初识go-wasm</title><link href="https://gaubee.com/articles/%E5%88%9D%E8%AF%86go%EF%BC%8Dwasm"/><updated>2021-04-22T12:53:00Z</updated><id>https://gaubee.com/articles/%E5%88%9D%E8%AF%86go%EF%BC%8Dwasm</id><content type="html">&lt;p&gt;https://github.com/Gaubee/big-json-parser&lt;/p&gt;
</content></entry><entry><title>Comlink-v2</title><link href="https://gaubee.com/articles/Comlink%EF%BC%8Dv2"/><updated>2021-07-22T23:59:26Z</updated><id>https://gaubee.com/articles/Comlink%EF%BC%8Dv2</id><content type="html">&lt;p&gt;我是Comlink-v1的重度用户，并在我的公司重努力推广它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am a heavy user of Comlink-v1 and have worked hard to promote it at my company.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它很棒，但仍然有一些问题，比如使用者必须知道它背后的工作原理，有时候还会因为参数传递时，对其进行序列化或者反序列化时引发一些低级的错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&#39;s great, but still has some issues, such as the user having to know how it works behind the scenes, and sometimes triggering some low-level errors when serializing or deserializing it when passing parameters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总的来说，Comlink-v1虽然有些瑕疵，但他解决了很多问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Overall, Comlink-v1 has some flaws, but it solves a lot of problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近我重新思考Comlink-v1存在的一些缺陷，并且尝试对它进行重新实现。在几经尝试后，不得不说，那些缺陷真的很难规避，为此我不得不牺牲它的通用性。所以最终我还是将Comlink-v2给实现了出来。可惜的是我不能将源码公布出来，但我可以提供基础的实现思路。我相信，这个新的思路会给js领域带来新的魔力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Recently I&#39;ve been rethinking some of the flaws in Comlink-v1 and trying to re-implement it. After a few attempts, I have to say that those flaws are really hard to avoid, and for that I had to sacrifice its versatility. So I finally implemented Comlink-v2. Unfortunately I can&#39;t publish the source code, but I can provide the basic idea of the implementation. I believe that this new idea will bring new magic to the JS field.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88-effect-preview&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88-effect-preview&quot;&gt;效果预览 Effect Preview&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这是已经通过测试的代码：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is the code that has been tested:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure&gt;&lt;img src=&quot;https://gaubee.com/img/comlink-v2/effect-preview.jpg&quot; alt=&quot;&quot; width=&quot;1280&quot; height=&quot;1706&quot; loading=&quot;lazy&quot; /&gt;&lt;figcaption&gt;Effect Preview&lt;/figcaption&gt;&lt;/figure&gt;
&lt;h2 id=&quot;%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-implementation-approach&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF-implementation-approach&quot;&gt;实现思路 Implementation approach&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;众所周知，Comlink-v1使用&lt;code&gt;await&lt;/code&gt;来隐式调用&lt;code&gt;then&lt;/code&gt;函数的特性来实现的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As you know, Comlink-v1 uses the feature of &lt;code&gt;await&lt;/code&gt; to implicitly call the &lt;code&gt;then&lt;/code&gt; function to do this.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Comlink-v2中，我努力将所有异步给消除了。众所周知，在js中，同步是异步特性的根基，也正因此我们能将&lt;code&gt;async/await&lt;/code&gt;编译成es5的代码来运行。所以理论上，只要在comlink重摆脱了异步的依赖，那么就彻底拥有了更多的语言特性。比如 &lt;code&gt;instanceof&lt;/code&gt;、&lt;code&gt;prop in obj&lt;/code&gt; 等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Comlink-v2, I tried to eliminate all asynchrony. As you know, synchronization is the basis of asynchronous features in js, and that&#39;s why we can compile &lt;code&gt;async/await&lt;/code&gt; into es5 code and run it. so theoretically, once we get rid of the asynchronous dependency in comlink, we have more features in the language. For example, &lt;code&gt;instanceof&lt;/code&gt;, &lt;code&gt;prop in obj&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为此，我使用&lt;code&gt;Atomic.wait/notify&lt;/code&gt;这对API来实现。当然，在浏览器中，它必须在web-worker中才能正常使用。这确实带来了一些局限性，但相信我，最终的Comlink-v2所带来的特性将会把这些局限性间接消除。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For this, I use the &lt;code&gt;Atomic.wait/notify&lt;/code&gt; pair of APIs. Of course, it has to work in a web-worker to work in a browser. This does introduce some limitations, but believe me, the features that will eventually come with Comlink-v2 will indirectly remove these limitations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Atomic-API的加持下，我们现在可以将一个worker暂停，等待其它线程执行完再将之唤醒。因此，你现在可以完全使用Proxy的魔力了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With the addition of Atomic-API, we can now pause a worker and wait for other threads to finish executing before waking it up. So you can now use the full magic of Proxy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-specific-implementation&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-specific-implementation&quot;&gt;具体实现方法 Specific implementation&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;接下来，要做工作主要有三方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are three main areas of work to be done next.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;要将数据分成三类：cloneable（string、number、boolean、bigint、null、undefined）；symbol；reference（object、function）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;To divide data into three categories: cloneable (string, number, boolean, bigint, null, undefined); symbol; reference (object, function)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;使用Atomic来进行通讯&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Using Atomic for communication&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;内存的引用与释放&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Reference and release of memory&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Comlink-v2中，我们&lt;strong&gt;不再需要注册数据的序列化与反序列化，因为我们拥抱了同步&lt;/strong&gt;。所以对于reference，我们统一使用Proxy来实现，这样能直接消除Comlink-v1的存有的各种副作用。正如你只是在同一个isolate中对一个引用对象进行代理一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In Comlink-v2, we &lt;strong&gt;no longer need serialization and deserialization of registration data, because we embrace synchronization&lt;/strong&gt;. So for references, we use a unified Proxy implementation, which directly eliminates the various side effects present in Comlink-v1. Just as you would just proxy a reference object in the same isolate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其次，就是symbol这个比较特殊的类型。我们无法对symbol进行Proxy代理，但依赖symbol的特性，在不同isolate中的symbol本身就是不共享的，我们可以在不同的isolate中创建一个副本，并为其注册唯一的id。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Secondly, there is the rather special type of symbol. We can&#39;t Proxy symbols, but relying on the properties of symbols, which are themselves unshared in different isolate, we can create a copy of the symbol in a different isolate and register a unique id for it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于Symbol有两点要注意：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are two things to note about Symbol:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;要使用&lt;code&gt;Symbol.keyFor&lt;/code&gt;来判断是否是使用&lt;code&gt;Symbol.for&lt;/code&gt;创建的；&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;To use &lt;code&gt;Symbol.keyFor&lt;/code&gt; to determine if it was created using &lt;code&gt;Symbol.for&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;我们还需要预先对&lt;code&gt;Symbol.iterator,Symbol.hasInstance...&lt;/code&gt;这些特殊的symbol进行预先注册。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;We also need to pre-register the special symbols &lt;code&gt;Symbol.iterator,Symbol.hasInstance... &lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们来谈谈如何使用Atomic来进行通讯：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Next let&#39;s talk about how to use Atomic for communication.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们需要一个&lt;code&gt;shareArrayBuffer&lt;/code&gt;，它用于存储两个线程通讯所需要的全部数据。但是我们不应该使用轮询到方式来让另一个线程知晓何时开始处理数据，所以我们还需要一个&lt;code&gt;messageChannel&lt;/code&gt;，它的作用是用来通知另一个线程开始处理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;First we need a &lt;code&gt;shareArrayBuffer&lt;/code&gt;, which is used to store all the data needed for the two workers to communicate. But we shouldn&#39;t use polling to let the other worker know when to start processing the data, so we also need a &lt;code&gt;messageChannel&lt;/code&gt;, which is used to inform the other thread to start processing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// write message size and content to shareAreayBuffer...&lt;/span&gt;&lt;br /&gt;msgPort&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMesaage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;Please wake me up&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;Atomic&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sab_i32a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// read result from shareArrayBuffer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来就会遇到一个问题，就是调用堆栈的问题。执行一个任务，两个线程可能需要进行多次的交互。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The next problem that comes up is the problem of calling the stack. Executing a task, two threads may need to interact multiple times.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我的解决方案是：记录调用堆栈长度：&lt;br /&gt;
So my solution is to record the call stack lengths:&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// write message size and content to shareAreayBuffer...&lt;/span&gt;&lt;br /&gt;msgPort&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMesaage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;Please wake me up&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; stackLen &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; sab_i32a&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;Atomic&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sab_i32a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// loop&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sab_i32a&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; stackLen &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// read result from shareArrayBuffer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，也是最重要的一点。因为我们模拟了JavaScript中的引用对象，所以，当我们导入一个对象，那么它就会被注册，也就意味着无法主动释放，如果强制释放，可能会造成其它线程使用&lt;code&gt;refId&lt;/code&gt;（引用ID）来寻找时，才发现对象被释放，造成异常。&lt;br /&gt;
对此，我的解决方案是 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakRef&quot;&gt;WeakRef&lt;/a&gt; + &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry&quot;&gt;FinalizationRegistry&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lastly, and most importantly. Since we simulate reference objects in JavaScript, when we import an object, then it is registered, which means that it cannot be actively released, and if it is forced to be released, it may cause an exception when other threads use &lt;code&gt;refId&lt;/code&gt; (reference ID) to look for it, only to find that the object is released.&lt;br /&gt;
For this, my solution is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef&quot;&gt;WeakRef&lt;/a&gt; + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry&quot;&gt;FinalizationRegistry&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只需要监听引用者的内存释放，从而来通知数据提供方的释放对象即可。唯一遗憾的是，我们无法监听&lt;code&gt;symbol&lt;/code&gt;的释放。所以这点要特别注意，不要让两个线程交互过多的&lt;code&gt;symbol&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You only need to listen to the referrer&#39;s memory release to notify the data provider of the released object. The only unfortunate thing is that we can&#39;t listen for &lt;code&gt;symbol&lt;/code&gt; releases. So be careful not to let two workers interact with too many &lt;code&gt;symbol&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-programming-skill&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7-programming-skill&quot;&gt;编程技巧 Programming skill&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;虽然我们使用了同步作为基础作为通讯，但为了可以让其有更加丰富的使用场景，我们也应该支持异步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although we use synchronous as the basis for communication, we should also support asynchronous in order to have a richer use case for it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何让同一套代码同时兼容异步和同步呢？我的建议是使用callback：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;How can we make the same set of code compatible with both asynchronous and synchronous? My suggestion would be to use callback.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// sync&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; res&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;flow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dosomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;res&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;_res&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;callback ❤️ sync&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// async&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;Promise&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cb&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;flow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dosomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;callback ❤️ async&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;%E5%B1%95%E6%9C%9B-look-ahead&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/Comlink%EF%BC%8Dv2#%E5%B1%95%E6%9C%9B-look-ahead&quot;&gt;展望 Look ahead&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最后我来聊一聊它的一些特性所将带来的影响：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Let me conclude by talking about the impact that some of its features will have:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在浏览器中，我们完全可以使用Comlink-v2来代理主线程。从而将业务完全运行在web-worker中。但因为浏览器的局限性，我们需要结合同步和异步的接口来进行实现。这点很像在nodejs中开发native插件。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;In the browser, we could have used Comlink-v2 to proxy the main thread. This allows us to run the business entirely in the web-worker. But because of browser limitations, we need to combine synchronous and asynchronous interfaces to do so. This is much like developing native plugins in nodejs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;我觉得这可以作为JavaScript并发的实现，它可以给我们带来很多想象。虽然Comlink-v1已经做到，但是同步的接口将会更加自然，开发者使用时，局限性更少：想象一下erlang的特性将会基于此实现～&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;I think this can be implemented as JavaScript concurrency, it can give us a lot to imagine. Although Comlink-v1 already does this, the synchronous interface will be more natural and less restrictive for developers to use: imagine the features of erlang will be based on this implementation ~!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;因为少了注册模型的序列化与反序列化，所以它与其它语言更容易交互。（事实上这正是我们公司将要做的事情）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Because there is less serialization and deserialization of registration models, it is easier to interact with other languages. (In fact this is exactly what we are going to do at our company.)&lt;/p&gt;
&lt;/blockquote&gt;
</content></entry><entry><title>封装异步编程中时间的理念</title><link href="https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5"/><updated>2020-09-22T11:17:53Z</updated><id>https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5</id><content type="html">&lt;p&gt;异步编程，本质就是要充分利用时间。但现代异步编程对于时间仍旧是一个很片面的理解，比如关于“超时异常”，我们往往只是定义一个 30s，超过这个时间就是失败。而所谓“健壮的异步程序”，往往也只是堆砌地使用这些定时器而已，这里头缺乏了一个“系统地时间理念”来规范时间的使用与等待。&lt;/p&gt;
&lt;p&gt;从业务或者功能等角度，可以定义出各种时间的概念，比如渲染的、网络的、磁盘的等待。&lt;br /&gt;
但进一步解剖，其实可以用两种时间概念来替代：&lt;br /&gt;
&lt;strong&gt;“我自己花费的时间”&lt;/strong&gt; 与 &lt;strong&gt;“我等待别人的时间”&lt;/strong&gt;&lt;br /&gt;
进一步简化就是：&lt;strong&gt;“计算时间”&lt;/strong&gt; 与 &lt;strong&gt;“等待时间”&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这里我是以一个“程序包”的角度去理解时间，无关“线程/进程”、“网络”、“磁盘”等待。&lt;br /&gt;
接下来一边分享我的理解，一边进行编程所需要的设计封装。&lt;/p&gt;
&lt;h2 id=&quot;%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%EF%BC%88%E6%88%91%E8%87%AA%E5%B7%B1%E8%8A%B1%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5#%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%EF%BC%88%E6%88%91%E8%87%AA%E5%B7%B1%E8%8A%B1%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89&quot;&gt;计算时间（我自己花费的时间）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;和人一样，如果自己是在做正确的事情，那么我们不会认为自己在浪费时间，自己也就没必要给自己“计算耗时”，毕竟“正确的事情”是最总要的，计算耗时反而会转移自己的注意力，不是“正确的事情”。&lt;br /&gt;
所以我们不会去给“计算时间”挂上计时钩子，而是一个程序的执行消耗多少时间也不是固定的，会被设备的状态所影响，比如低电量、一个 CPU 线程中有多个程序在切换调度互相争夺资源 等等。&lt;br /&gt;
但是程序之间可以互相统计对方消耗了多少时间，由此来做出自己的判断。不过这一步往往是“系统内核”在做的，因为是它在决策程序的调度，所以它应该统计并记录每一个程序的执行时间、压力状态。&lt;br /&gt;
这些信息都将帮助整个系统变得更加的稳健，而不是单一地使用超时来决策接下来的作业。&lt;/p&gt;
&lt;h3 id=&quot;%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A&quot;&gt;举个例子：&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;前段时间我就遇到一个 BUG，我封装了一个请求，如果请求超时，那么过一会儿再去请求。结果超时的不是别人，而是自己的封装中，有一些需要进行排队的验证。其实请求的结果已经返回了，而因为排队时间过长导致上层的流程认为需要重试，结果就又重新发起了一次请求，而后请求的结果又一次排队验证，外层又一次认为超时……一般来说因为验证很快，所以不会出现这样的恶性循环，但因为验证模块是共用的，所以很可能被其它模块的调用给塞满任务。&lt;br /&gt;
一个复杂的系统中，出现异常的原因很多，各种模块都有自己的异常情况，如果我一段程序依赖了其它三种模块，那难不成我要考虑这三种模块的所有可能涉及的异常吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;理论上来说我们确实可以通过抽象封装来简化一个已经依赖了很多程序的程序。再通过缓存结果、合并请求等等手段来进行加固。但这样的程序结构在愈发庞大的时候，仍然是包含着内耗的。这就是是为什么很多系统，一开始跑着没问题，跑着跑着就只能“重启”了。&lt;br /&gt;
因为“封装”本就是人面对复杂系统的一种简化措施，它需要配合各种缓存优化才能达到一个更高的可用性。而缓存优化本身就是以一种带有副作用的行为。比如说我们调用缓存时，内存不够了怎么办？一般来说都是没有后路地去写下程序吧，没内存了，重启吧……正是因为大量没有系统性的规范操作，才导致了一个系统无法长时间地运转，当然我们也看过那种自动重启来解决问题的。自动重启在有分布式集群的时候确实蛮实用，但这篇文章探讨的是如何在一开始就规避这些问题，而不是如何补救。&lt;br /&gt;
所以解决问题最好的方法之一，就是面对它们！而不是一味地迷信于一个程序自己“封装”的力量。&lt;br /&gt;
如果“人”不能直接做到对所有依赖程序的异常处理进行最优解，那么这就应该交给系统去做。&lt;br /&gt;
一个程序一个模块对于异常，不应该自己藏着掖着，因为它自己不知道下游的需求场景，所以它最好是暴露出相关的信息。这些信息经过系统统筹，以及调用堆栈的层层决策之后，才有一个真正意义上正确的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以刚才的例子来说：点击按钮发起一个请求，理想中，它应该 0.5s~1s 内就返回结果了，结果到了 800ms 还是没有响应，这时候这个按钮应该要知道，到底出现了什么问题，好让用户能去及时做出一些更加正确的决策，而不是再让用户白白浪费时间。在传统系统中，上游程序并不知道下游发生了什么，但如果系统能告知按钮程序：“其实数据请求已经返回了，是验证排队满了，而验证排队满了是因为另外一个程序在大量调度，可能需要再等上 2s。”当用户得知了这些信息，这时候就等于将选择权交给了用户，让用户有事情可以做了。这对于整个系统长远来说是更益处的，一方面是在当下，模块之间（包括人）可以做出更加正确的事情，另一方面，大量的决策信息，在使用人工智能加持后，对于使用者来说就会越来越好用。比如下次还是遇到这种情况的话，用户愿意等，而且在等待之后的事情并不是与其它程序竞争资源，那么也许就可以让用户插个队~~&lt;/p&gt;
&lt;p&gt;从刚才的例子也可以看出，这里头最重要的其实是“沟通的艺术”。说白了就是，一个模块一个人，如果 ta 想要做决策，那么它需要的是什么样的信息？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;再举个例子：对于&lt;strong&gt;渲染程序&lt;/strong&gt;，往往就是我们的主线程在承载。当我们位于子线程中的逻辑运算过慢的时候，渲染程序并不需要为什么算得慢，而是只是想向用户反应“计算慢了”这个信息。通过这个信息，它可以通过延长动画时间，来向用户表达当前设备的计算压力，也借由这些动画，可以用来减慢用户的操作速度，进而减缓计算模块的响应压力。从而达成一个正循环的机制。所以，在这里，它需要的信息是：“程序现在有多慢”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这与刚才按钮程序想要知道“为什么慢”，这里就说明一个模块所需要的信息就是不一样的。包括人这个模块也是，人能决策的只是 ta 自身能操作的东西，比如开关程序、操作程序、等待结果。比如读一个文件，卡了，系统不应该用户：“磁盘现在很忙，因为&lt;code&gt;system.logs&lt;/code&gt;模在疯狂写入”。而是应该说：“&lt;code&gt;视频&lt;/code&gt;程序导致了文件读取比较慢，可能还需要再等 3 秒钟”。亦或者你直接跟一个正在读写磁盘的程序说一些主板才能听懂的话，那也没意义。&lt;/p&gt;
&lt;h2 id=&quot;%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%EF%BC%88%E6%88%91%E7%AD%89%E5%BE%85%E5%88%AB%E4%BA%BA%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%97%B6%E9%97%B4%E7%9A%84%E7%90%86%E5%BF%B5#%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%EF%BC%88%E6%88%91%E7%AD%89%E5%BE%85%E5%88%AB%E4%BA%BA%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89&quot;&gt;等待时间（我等待别人的时间）&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这其实包含了“别人的计算时间”以及“信息传输时间”。当我们在讨论：处理”等待时间“过长问题的时候，并不是在处理异常，而是将这种定义成非理想流程的执行。过去我们一直将这类流程统一归纳成了错误或者异常，总是想用各种省时省力的方法将它们扭转到所谓“正确的流程上来”，却忘了一分耕耘一分收获。若不认真对待它们，特别是当它们在复杂系统中，自然而然就会混沌起来。&lt;br /&gt;
所以我不建议将它们当成错误或者异常，而是将它们作为正常且必须面对的流程来处理。所以下文我们用“异流”来对其进称呼。&lt;/p&gt;
&lt;p&gt;你可以看到其实有些编程语言就有考虑过这样的设计，比如 Go。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但它是通过多返回值来传递错误，这也是不得已的设计，虽然被人诟病，但其背后的理念支持是多少 BUG 堆叠而来的。可 Go 的哲学导致对它的设计过于简单，所以对于开发者来说，反而也会变得复杂和迷糊。&lt;br /&gt;
还有，大部分静态编程语言都能有根据类型进行捕捉的能力。但这种写法很容易造成雪崩效应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们才需要一个系统的理念来处理它们，上文提到很重要的一点：在异流中，我们需要根据不同的场景来得到不同的信息。&lt;br /&gt;
所以这里我们先对信息进行定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上下文信息
&lt;blockquote&gt;
&lt;p&gt;这点可以用“程序堆栈”来理解，但准确说堆栈只是描述了“上文”，它可以让我们知道已经走过了哪些程序，消耗了多少的资源，“下文”是指它即将做什么任务，即将消耗哪些资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;统计信息
&lt;blockquote&gt;
&lt;p&gt;这里是指对于资源消耗的统计。&lt;br /&gt;
补充一下对于资源的定义：不同的程序、模块是可以自己定义资源的，也可以将自己的资源消耗细分成到某一种资源下的子资源。所以从程序角度来说：资源是一种全局的不断累积或者不断变化的变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们以上文“渲染层动画时长”的实现为例：&lt;/p&gt;
&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token atrule&quot;&gt;&lt;span class=&quot;token rule&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;only&lt;/span&gt; resouce-usage &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;module-name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;my.logic&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;80%&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token property&quot;&gt;--base-transform-duraction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 400ms&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token atrule&quot;&gt;&lt;span class=&quot;token rule&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;only&lt;/span&gt; resouce-usage &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;module-name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;my.logic&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;50%&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token property&quot;&gt;--base-transform-duraction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 100ms&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token atrule&quot;&gt;&lt;span class=&quot;token rule&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;only&lt;/span&gt; resouce-usage &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token property&quot;&gt;module-name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;my.logic&quot;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;20%&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token property&quot;&gt;--base-transform-duraction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 30ms&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;待续~&lt;/em&gt;&lt;/p&gt;
</content></entry><entry><title>浅谈Web Worker关闭的问题</title><link href="https://gaubee.com/articles/%E6%B5%85%E8%B0%88Web%20Worker%E5%85%B3%E9%97%AD%E7%9A%84%E9%97%AE%E9%A2%98"/><updated>2020-05-24T08:46:02Z</updated><id>https://gaubee.com/articles/%E6%B5%85%E8%B0%88Web%20Worker%E5%85%B3%E9%97%AD%E7%9A%84%E9%97%AE%E9%A2%98</id><content type="html">&lt;p&gt;Web Worker是没有提供onclose事件的，但它有提供terminate函数。&lt;br /&gt;
可能官方很自信地觉得Worker只要是用户销毁的，那么就没必要onclose……但其实昨天就遇到这个问题了（在Cordova-Ionic-Webview里头），就是从后台唤起程序，WebWorker没响应了，被杀了……在调试控制台已经看不到这个Worker的身影。&lt;br /&gt;
解决办法我想有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原生层面入手，去监控有什么系统层面的回调会触发&lt;/li&gt;
&lt;li&gt;改成用ServiceWorker试一下&lt;/li&gt;
&lt;li&gt;监控WebWorker的销毁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了简单且通用起见，我先选择了3。&lt;br /&gt;
但其实在官方接口里头是没有相关的接口的，这就只能另辟蹊径。&lt;br /&gt;
一开始我想到的是研究MessageChannel。因为从接口层面来说，它们几乎是一出的，也许底层实现是一样的。&lt;br /&gt;
所以就去研究如何识别MessageChannel是close状态的。最糟糕的方式估计就是pingpong，但这就得额外增加脏代码。&lt;br /&gt;
后来忽然想到transferable这个标准，所以就有了以下的骚操作：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ArrayBuffer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;port1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;byteLength&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果MessagePort是开启的状态，内存对象会被顺利传输，从而打印“0”。否则如果打印“1”，就说明MessagePort已经被关闭。&lt;br /&gt;
用这个方法去实验WebWorker。理论上几乎是一个东西吧……事实却是即便WebWorker执行了terminate，ArrayBuffer仍旧会被传输过去……这就很恐怖了，错觉自己是不是遇上了浏览器内存泄漏的问题……一搜索其实github上三四年前就已经有人提出了，到现在仍旧没有音讯。实在不理解terminate居然没有销毁消息管道……那我发送到子进程的ArrayBuffer到底发到哪里了呢?&lt;/p&gt;
&lt;p&gt;既然这条路不通，我就再换一个操作。我想terminate至少会销毁WebWorker中所有的Promise吧。故而我想起了有这个一个API：LockManager 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 我后来测试在使用&lt;code&gt;new Worker(&#39;data:text/javascript;,&#39;)&lt;/code&gt;这样的&lt;code&gt;data:&lt;/code&gt;协议下的Worker环境，是不支持的。建议还是用https协议。&lt;br /&gt;
它的用法很简单，虽然还是需要在子进程中注入代码，但至少也比pingpong的方案好，毕竟Worker就是要用来执行密集型任务，哪里还能保障一定能返回pingpong呢。所以只要在子进程启动后，执行一个永远不释放的request，然后发一个信号告知主进程开始监听这个request：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/// worker&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; lockReqId &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;process-live-&#39;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;Date&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;locks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lockReqId&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;&lt;span class=&quot;token builtin&quot;&gt;Promise&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;lockReqId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;/// master&lt;/span&gt;&lt;br /&gt;worker&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;message&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; me&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; me&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;string&#39;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; me&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;startsWith&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;process-live-&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    navigator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;locks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;me&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      worker&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;dispatchEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CloseEvent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;close&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方案几乎是完美的。因为是直接跟js引擎的销毁与否进行绑定。不过它只有chrome69+才支持。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;不过pingpong只能识别出Worker不响应，它可能繁忙。如果没有预期中的响应，应该将是否重启WebWorker&lt;/p&gt;
</content></entry><entry><title>发现几个很棒的开源项目</title><link href="https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"/><updated>2020-05-07T07:29:48Z</updated><id>https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE</id><content type="html">&lt;h2 id=&quot;isomorphic-git&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE#isomorphic-git&quot;&gt;&lt;a href=&quot;https://isomorphic-git.org/&quot;&gt;Isomorphic-Git&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用js实现的git，与git保持完全的兼容&lt;/p&gt;
&lt;h2 id=&quot;storybook&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE#storybook&quot;&gt;&lt;a href=&quot;https://www.learnstorybook.com/&quot;&gt;Storybook&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一个管理组件的工具，能部署在本地项目中，方便测试人员进行测试、开发人员互相了解、设计师进行审查&lt;/p&gt;
&lt;h2 id=&quot;warriorjs&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%8F%91%E7%8E%B0%E5%87%A0%E4%B8%AA%E5%BE%88%E6%A3%92%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE#warriorjs&quot;&gt;&lt;a href=&quot;https://warriorjs.com/&quot;&gt;WarriorJS&lt;/a&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;编程游戏，用编程来通关&lt;/p&gt;
</content></entry><entry><title>Promise.race会带来内存泄露</title><link href="https://gaubee.com/articles/Promise.race%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"/><updated>2020-04-23T01:02:06Z</updated><id>https://gaubee.com/articles/Promise.race%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2</id><content type="html">&lt;p&gt;假若有两个promise: a, b，现在它们都&lt;code&gt;Promise.race([a,b])&lt;/code&gt;所包裹。&lt;br /&gt;
此时，如果a先完成了resolve，race也就有了返回值。&lt;br /&gt;
然而，b却迟迟没有被resolve或者reject……&lt;br /&gt;
结果会带来隐式的内存问题，就是a看上去被释放了，但其实没有。&lt;br /&gt;
v8论坛上有类似的bug提交：https://bugs.chromium.org/p/v8/issues/detail?id=9858&lt;/p&gt;
&lt;p&gt;简单地模拟一下实现：&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;race&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;promises&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;resolve&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; p &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; promises&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      p&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;resolve&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; reject&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我实际测试了一下，一些不同版本的v8似乎会有不同的表现，但终归是内存泄漏了，只是好像v12的是直接泄漏了捕捉不到，v13是能在内存堆栈里头看到。&lt;br /&gt;
我在工作的时候发现这个问题也是靠async_hooks的异步资源监控下才看到这个问题的存在。&lt;/p&gt;
&lt;p&gt;解决方案其实也不难，核心问题就是消除引用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先我们需要一个&lt;code&gt;Promise.prototype.safeThen&lt;/code&gt;的实现，因为&lt;code&gt;Promise.prototype.then&lt;/code&gt;是会返回出一个新的promise的。做法其实就是只使用一次then来代理实现。其返回值就是&lt;code&gt;thened: { resolves: Set&amp;lt;Function&amp;gt;, rejects: Set&amp;lt;Function&amp;gt;, isFinished: boolean }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接着我们基于&lt;code&gt;safeThen&lt;/code&gt;来实现&lt;code&gt;Promise.safePromiseRace&lt;/code&gt;，重点在于收集thened对象，并主动进行释放：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function safePromiseRace(...promises){
  return new Promise((resolve, reject)=&amp;gt;{
    const thenedList = []
    const finished = ()=&amp;gt;{
      thenedList.forEach(thened=&amp;gt;{
        thened.resolves.delete(safeResolve);
        thened.rejects.delete(safeReject);
      })
    }
    const safeResolve = (v)=&amp;gt;{resolve(v); finished();}
    const safeReject = (v)=&amp;gt;{reject(v); finished();}
    for(const p of promises){
      thenedList.push(p.safeThen(safeResolve, safeReject))
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><title>小米10使用体验</title><link href="https://gaubee.com/articles/%E5%B0%8F%E7%B1%B310%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C"/><updated>2020-09-22T07:49:30Z</updated><id>https://gaubee.com/articles/%E5%B0%8F%E7%B1%B310%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C</id><content type="html">&lt;p&gt;老妈要换手机了，给她买了个小米10。&lt;br /&gt;
其实本来就是冲着它是一个比较均衡的体感配置才去尝试的，但试用后还是觉得不值这个价钱。&lt;br /&gt;
老婆说这个价格，再添一两千都能买美版的iPhone了😂。我知道iPhone的好处，但我需要的是MIUI的系统，我也不想去折腾刷机什么的，所以就买了小米。&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%80%E4%BA%BF%E5%83%8F%E7%B4%A0&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%8F%E7%B1%B310%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C#%E4%B8%80%E4%BA%BF%E5%83%8F%E7%B4%A0&quot;&gt;一亿像素&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先是一亿像素。对比的产品不是所谓的“友商”，而是我自己在用的MIX2s。&lt;br /&gt;
说实话，差别真的和我MIX2s的1200万像素差别不大。我选择的是阳光明媚的条件进行拍摄，毕竟我妈妈没有拍夜景的需求。&lt;br /&gt;
以下样张是我将两种照片在手机上方大到最大比例然后截屏下来的。毕竟手机屏幕对于我妈来说就是最后的输出端。后面是我用电脑打开图片继续方大看到的东西。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;MI10的一亿像素&lt;/th&gt;
&lt;th&gt;MIX2s的1200万&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://gaubee.com/img/mi10-for-mom/mi10-take-photo.png&quot; alt=&quot;image&quot; width=&quot;1080&quot; height=&quot;2340&quot; loading=&quot;lazy&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://gaubee.com/img/mi10-for-mom/mix2s-take-photo.png&quot; alt=&quot;image&quot; width=&quot;1080&quot; height=&quot;2160&quot; loading=&quot;lazy&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://gaubee.com/img/mi10-for-mom/mi10-take-photo-zoom-in.png&quot; alt=&quot;image&quot; width=&quot;514&quot; height=&quot;514&quot; loading=&quot;lazy&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://gaubee.com/img/mi10-for-mom/mix2s-take-photo-zoom-in.png&quot; alt=&quot;image&quot; width=&quot;430&quot; height=&quot;459&quot; loading=&quot;lazy&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;尽管说一亿跟一千万在二维图片上，应该是&lt;code&gt;3：1&lt;/code&gt;的关系，但我实际看到的并没有预期的效果。可以看到这真实的场景下， 不过是一个糊糊锐化成另外一个糊糊罢了。虽然颜色捕捉有点长进，但想想它们&lt;code&gt;1：3&lt;/code&gt;的价格……&lt;/p&gt;
&lt;h2 id=&quot;90hz%E5%B1%8F%E5%B9%95&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%8F%E7%B1%B310%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C#90hz%E5%B1%8F%E5%B9%95&quot;&gt;90Hz屏幕&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这是我买它的一个重点，体验下来后差强人意。&lt;br /&gt;
我是能明显感觉到60Hz是不能满足我的需求的，毕竟手机上没有动态模糊，所以当我在浏览一个网页，快速地进行页面滚动时，我是捕捉不到信息的，能看到的只是一堆堆文字在重影，这不同于60hz拍摄的视频所带来的舒适感。&lt;br /&gt;
所以我的心理预期是能在90Hz屏幕上，滚动页面的时候，能捕捉到文字信息。&lt;br /&gt;
但结果仍旧是它仍旧达不到我的预期，虽然改变了滚动算法，能在滚动快要结束的时候让我能看清普通速度滑动的文字，但这点优化还不能让我改变交互习惯，我还是会手动地拖拽着屏幕一屏一屏地看。&lt;br /&gt;
不过大的图案在滚动的时候事能看得比较清晰了。比如带颜色的图标，确实是能在滚动中更轻松地被捕捉信息了。&lt;br /&gt;
总结就是着90Hz屏只是让动画流畅了一点，可并没法本质上节约我的时间，提升我的生产力。&lt;/p&gt;
&lt;h2 id=&quot;%E6%8C%AF%E6%84%9F&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%8F%E7%B1%B310%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C#%E6%8C%AF%E6%84%9F&quot;&gt;振感&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这点是肯定的，虽然能感觉出来比不上iPhone的振感，但至少还是基本满足我的预期。&lt;/p&gt;
&lt;h2 id=&quot;%E5%85%AC%E6%94%BE%E5%A3%B0%E9%9F%B3&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%8F%E7%B1%B310%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C#%E5%85%AC%E6%94%BE%E5%A3%B0%E9%9F%B3&quot;&gt;公放声音&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这点是我很看中的一点，我妈不带耳机的，所以我想给她立体音效，让她看视频时音效能更加沉浸。&lt;br /&gt;
虽然这种震撼感比不上去年我给老婆买的 iPad Pro 的那种体验，人家那时4个音响。但对于手机来说，这个改进真的算很不错了。&lt;br /&gt;
不过当屏幕立起来的时候，这立体音响就蔫了……&lt;/p&gt;
&lt;h2 id=&quot;%E5%89%8D%E7%BD%AE%E6%91%84%E5%83%8F%E5%A4%B4&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E5%B0%8F%E7%B1%B310%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C#%E5%89%8D%E7%BD%AE%E6%91%84%E5%83%8F%E5%A4%B4&quot;&gt;前置摄像头&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我难受的是它挖孔没有正圆心对其……&lt;br /&gt;
其实后面的闪关灯也是，差不多差了0.01毫米左右，但这是能明显看出来的。这种错愕感令人无法认同它的工艺……&lt;br /&gt;
画质也是差不多够用的水平，反正这东西对于我和我妈来说基本只是用来微信网络视频，所以瓶颈在于网络运营商的带宽。我也就无所谓了。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;综上，我知道以我的产品定位来说，肯定会有更匹配我需求的机型。&lt;br /&gt;
但我仍旧觉得小米10贵了。&lt;/p&gt;
</content></entry><entry><title>浅谈Async Generator</title><link href="https://gaubee.com/articles/%E6%B5%85%E8%B0%88Async%20Generator"/><updated>2018-07-18T08:15:59Z</updated><id>https://gaubee.com/articles/%E6%B5%85%E8%B0%88Async%20Generator</id><content type="html">&lt;p&gt;会议初学编程的时候，那时候学的还是asp.net，然后看到substrack一个演讲视频：&lt;a href=&quot;https://www.youtube.com/watch?v=lQAV3bPOYHo&quot;&gt;Harnessing The Awesome Power Of Streams&lt;/a&gt;，觉得：“哇！流这种编程思想我要学！”，从此就开始入了nodejs的坑。然而直到现在2018年，async iterator的出现，才勉勉强强提供了一种语法层级的流编程的体验。&lt;/p&gt;
&lt;p&gt;一开始，基于事件编程，开发者通过监听一个个事件（从&lt;code&gt;on(&amp;quot;data&amp;quot;, fn)&lt;/code&gt;开始），来模拟事件流程。这勉强算是一种实现，它最大的问题是需要创建大量的callback，维护它的代价就是需要书写大量冗余的代码与抽象的封装才能勉强达到稳定可用的级别。&lt;br /&gt;
事情的转机从Generator的出现开始，与其并行推广的还有提早一阵子出现的Promise。大部分人对Generator的使用无非就是&lt;code&gt;co&lt;/code&gt;这个库的骚操作。不过确实，单纯Generator这个语法特性，很难在jser里头引起什么大风浪，毕竟js里头基本都是异步编程，Generator除了模拟现在的async/await以外很难有大舞台。&lt;/p&gt;
&lt;h2 id=&quot;async-generator&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E6%B5%85%E8%B0%88Async%20Generator#async-generator&quot;&gt;Async Generator&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有趣的在async iterator这个语法出台，Generator才算正式杀入js的异步编程。&lt;/p&gt;
&lt;h3 id=&quot;%E5%85%A5%E9%97%A8&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E6%B5%85%E8%B0%88Async%20Generator#%E5%85%A5%E9%97%A8&quot;&gt;入门&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;举个简单的例子：&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; stream &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createReadStream&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;./big-file&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; data &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; stream&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种写法相比&lt;code&gt;on(&#39;data&#39;, fn)&lt;/code&gt;这种写法，最大的区别在于资源的控制与利用上：基于事件的监听，nodejs会尽可能也必须尽可能快速地去触发&lt;code&gt;data&lt;/code&gt;事件，而并不知道你到底有多么需要这些&lt;code&gt;data&lt;/code&gt;，反正它就是冲着榨干硬件资源的操作去无脑触发就是了（当然你也可以直接使用文件句柄来手控操作，也能规避这个问题）。&lt;/p&gt;
&lt;h3 id=&quot;%E8%BF%9B%E9%98%B6&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E6%B5%85%E8%B0%88Async%20Generator#%E8%BF%9B%E9%98%B6&quot;&gt;进阶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;再举一个实践的例子，我最近在做的节点扫描：从一个节点扫描出N个节点，然后再从这N个节点中扫描下一级的节点，不断收集，直到满足需求为止，伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Peer&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; origin&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; level&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PeerService&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  peerList &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;origin&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;http://peer.com:777&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; level &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 初始节点&lt;/span&gt;&lt;br /&gt;  async &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;searchPeers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;br /&gt;    enter_port_peers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;peerList&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 初始的节点&lt;/span&gt;&lt;br /&gt;    collection_peers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Peer&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 节点去重用的表&lt;/span&gt;&lt;br /&gt;    parallel_pool &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ParallelPool&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Peer&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1. 并行池，可以同时执行2个任务&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; AsyncIterableIterator&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Peer&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; self &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Generator function 无法与箭头函数混用，所以这里的this必须主动声明在外部。&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;/*递归搜索代码片段*/&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;recursiveSearch&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;skip_when_no_full&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; peers &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; parallel_pool&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;yieldResults&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        ignore_error&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 忽略错误（忽略不可用的节点）&lt;/span&gt;&lt;br /&gt;        skip_when_no_full&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 在池子不填满的情况下是否返回&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; peer &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; peers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;          &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; peer&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;// 3. 先返回节点，然后再递归搜索&lt;/span&gt;&lt;br /&gt;          &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;searchPeers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;peer&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; collection_peers&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; parallel_pool&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; enter_port_peer &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; enter_port_peers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token comment&quot;&gt;// 2. 向并行池中添加任务&lt;/span&gt;&lt;br /&gt;      parallel_pool&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addTaskExecutor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;_searchPeers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;enter_port_peer&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; collection_peers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;recursiveSearch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token comment&quot;&gt;// 如果并行池满了，等待一个任务完成后再继续填充&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;recursiveSearch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;_searchPeers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;br /&gt;    enter_port_peer&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;PEERS&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    collection_peers&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Map&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; Peer&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// TODO: 使用API获取与之相连的节点集合，并使用collection_peers去重&lt;/span&gt;&lt;br /&gt;   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; Peer&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码中有三个重点：&lt;br /&gt;
1️⃣ 并行池的设计，是因为网络的数据请求应该尽可能预先加载，这里默认能同时有2数据请求在执行&lt;br /&gt;
2️⃣ 我在一开始根据一个已知的节点表，把所有的下载任务尽肯能添加到池子中&lt;br /&gt;
3️⃣ 每个任务返回的是一组节点，但以流的思想，拆解成一个个往外返回。外部拿到这个节点后，可以进行一些分析，比如试探这个节点是否正常，延迟多少等等。如果外部觉得节点够多了，这个生成器就不需要再执行下去。如果不够，那么就继续搜索下去。要注意的时候，在返回到外部的时候，因为我们使用了并行池的设计，所以理论上还有其它的一些网络请求任务也在执行。&lt;/p&gt;
&lt;p&gt;当然，有这个并行池的设计，你要把上面的代码改成基于事件触发的也不是不行。无非是多写点代码，多创建一些函数，通过代码拼接来完成整个AsyncIterator肯定也是可以的。async Generator只是提供给我们一种更加直观的写法与思考方式。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9C%AA%E6%9D%A5&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;https://gaubee.com/articles/%E6%B5%85%E8%B0%88Async%20Generator#%E6%9C%AA%E6%9D%A5&quot;&gt;未来&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;语法特性的增加，最大的好处就是减少了错误的发生。&lt;br /&gt;
这可能与其它一些语言的设计哲学并不相同，有的语言追求有且只有一种写法来实现需求。而js则是告诉你你这段代码还能简单+精简+可读+可维护+。&lt;br /&gt;
按现有的提案，管道操作符&lt;code&gt;|&amp;gt;&lt;/code&gt;与函数部分执行&lt;code&gt;fn(1, ?)&lt;/code&gt;这两个语法如果通过提案了，对于流编程也会带来很大的便利性。&lt;/p&gt;
</content></entry></feed>