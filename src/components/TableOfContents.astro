---
import type { MarkdownHeading } from 'astro';

export interface Props {
  headings: MarkdownHeading[];
}

const { headings } = Astro.props;

// Filter to only include h2 and h3 headings for a cleaner ToC
const filteredHeadings = headings.filter(h => h.depth === 2 || h.depth === 3);
---

<div class="toc-container">
  <h3>目录</h3>
  <ul class="toc-list">
    {filteredHeadings.map(heading => (
      <li class={`toc-item depth-${heading.depth}`}>
        <a href={`#${heading.slug}`}>{heading.text}</a>
      </li>
    ))}
  </ul>
</div>

<style>
  .toc-container {
    padding: 1rem;
    background-color: #ffffff;
    border-radius: 0.5rem;
    border: 1px solid var(--c-border);
  }
  h3 {
    margin: 0 0 1rem 0;
    font-size: 1.2rem;
    font-weight: 600;
  }
  .toc-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .toc-item a {
    display: block;
    color: #555;
    text-decoration: none;
    padding: 0.4rem 0;
    font-size: 0.9rem;
    transition: color 0.2s ease-in-out;
  }
  .toc-item a:hover {
    color: var(--c-text);
  }
  .toc-item.depth-3 a {
    padding-left: 1.5rem;
  }
  .toc-item a.active {
    color: hsl(var(--primary));
    font-weight: 600;
  }
</style>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const tocLinks = Array.from(document.querySelectorAll('.toc-item a')) as HTMLAnchorElement[];
    const headings = tocLinks.map(link => {
      const id = link.getAttribute('href')?.slice(1);
      return id ? document.getElementById(id) : null;
    }).filter(Boolean) as HTMLElement[];

    if (headings.length === 0) return;

    // Smooth scroll logic
    tocLinks.forEach(link => {
      link.addEventListener('click', (ev) => {
        ev.preventDefault();
        const href = link.getAttribute('href');
        if (href) {
          const targetElement = document.querySelector(href);
          if (targetElement) {
            targetElement.scrollIntoView({ behavior: 'smooth' });
          }
        }
      });
    });

    // Scroll-spy logic
    let activeHeadingId = '';

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const id = entry.target.getAttribute('id');
        const tocLink = tocLinks.find(a => a.getAttribute('href') === `#${id}`);
        if (entry.isIntersecting) {
          tocLink?.classList.add('active');
        } else {
          tocLink?.classList.remove('active');
        }
      });

      // Determine which active link is the "current" one (highest on screen)
      const activeLinks = document.querySelectorAll('.toc-item a.active');
      let highestVisibleLink = null;
      let minTop = Infinity;

      activeLinks.forEach(link => {
        const id = link.getAttribute('href')?.slice(1);
        const heading = document.getElementById(id!);
        if (heading) {
          const rect = heading.getBoundingClientRect();
          if (rect.top >= 0 && rect.top < minTop) {
            minTop = rect.top;
            highestVisibleLink = link;
          }
        }
      });

      tocLinks.forEach(link => link.classList.remove('active'));
      if (highestVisibleLink) {
        (highestVisibleLink as HTMLElement).classList.add('active');
      }

    }, {
      rootMargin: '0px 0px -80% 0px',
      threshold: 0
    });

    headings.forEach(heading => {
      observer.observe(heading);
    });
  });
</script>
