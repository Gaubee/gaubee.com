基于我给的这些资料，帮我生成一篇循序渐进的从入门到精通的中文文章，参考“张鑫旭”的文章风格。
首先要总结出整个草案解决问题的思路和背后的哲学；接着聊聊这个提案背后的故事和历史、推动者们的思考和博弈；然后展开循序渐进教学；最后同时站在开发者和提案者的角度进行总结和升华。

注意文章的结构格式是：

````
# 这是标题
## 一、这是段落
```ts
// 使用typescript作为示例代码
```
````

---

接下来，请你根据我给你的 TC39-Proposal-Signals 的提案内容，继续生成第二篇文章。
同样的写作思路：

1. 循序渐进的从入门到精通的中文文章
2. 参考“张鑫旭”的文章风格
3. 首先要总结出整个草案解决问题的思路和背后的哲学；接着聊聊这个提案背后的故事和历史、推动者们的思考和博弈；然后展开循序渐进教学；最后同时站在开发者和提案者的角度进行总结和升华。
4. 我个人 Signals 提案的态度，并不是局限于说这个 API 是为框架设计的底层工具。
   1. 对于前端开发者：有了它，其实等于有了开箱即用的响应式编程，那么即便你不用任何 Web 框架，你也能写出高维护性、高鲁棒性的代码。
   2. 对于全栈开发者：很多算法的高性能本质是“空间换时间”，通常情况下我们需要小心翼翼地维护一个数组来做到这点。但 Signals 是一个开箱即用的“计算缓存”，利用它你可以实现复杂的带缓存的计算（比如一些对 Tree/Node 的操作）。
   3. JS 语言的影响非常广泛，甚至到了 IOT 领域，那么 Signals 这种“声明式”的能力符合人类的思维直觉，这将会在很多领域都带来巨大的影响力，正如我第一点提到的一样，即便开发者不使用任何开发框架，也能利用 Signals 写出更高质量的代码。
   4. AI 其实是更加擅长声明式编程的，这对于 AI 写出高质量的代码来说，也是一个利好。

注意文章的结构格式是：

````
# 这是标题
## 一、这是段落
```ts
// 使用typescript作为示例代码
```
````

---

请你结合档我给你的资料，你生成的两篇文章，继续写第三篇文章《Observable VS Signals》。
写作思路：

1. 通过对比的方式，来帮助读者建立认知。
2. 参考“张鑫旭”的文章风格，但用词要准确，语句要精炼。
3. 先对比它们的底层哲学，我给你提供一个思路火花，请你依据我这个思路作为核心切入，目的是快速帮助开发者建立认知和直觉。

   ```
   Observable 其实更像是一个 Array。
   Signals 其实更像是一个 Function。

   Array 是静态的，一旦引入“时间”维度，就变成了动态，那便是 Observable。
   Function 是静态的，一旦引入动态的 Arguments，那便是 Signals。
   ```

   这部分不用给出太多代码，因为前面两篇文章都已经有完整的教程了。

4. 然后不要否定它们之间存在互补和交集，特别是 Signals 的底层特性。
   - 文章需要用 Signals 来模拟解决 Observable 所要解决的某个问题，推导出 Observable 的优势的不可替代性。
   - 反过来可以用 Observable 来模拟 Signals，推导出 Signals 的优势的不可替代性。
   - 注意这个过程中要耐心地完成推导，证明它们是可以互相替代的。
5. 聊一聊背压(backpress)与 Observable 和 Signals 的关系和思考（这里要客观，不要鼓吹）
   1. Signals 的特性导致它天然规避了数据流背压问题，但也同时意味着它对于背压的处理能力其实是单一的：就是丢弃。
6. 最后做一些简单的总结（因为这里要做总结，所以文章其它地方需要总结的，可以统一挪到这里来）。
   - 我个人的看法是，Observable 更像是复杂指令集，Signals 更像是精简指令集。
   - Observable 想要强大起来，以目前的提案所放出的内容，其实能做的事情比较有限。但理论上未来 RxJS 那些高级功能能否是可以通过垫片实现的。
   - Signals 跟倾向于函数式编程，更容易建立社区。即便是那些 Observable 更擅长做的东西，理论上 Signals 也能通过社区库的封装来做到，也能做得不差。
     > 比如说，关于 click 的绑定，我可以构建一个 `const eventState = new Signal.State<Event|null>(null)`这样一个状态，这个的思路在于“消费”。
     > 这种思路不同于 Observable 需要处理每一个 Event。Signal 可以通过`eventState`来修改`button.disabled`，这与直接实现 throttle 不同，它可以自洽，从而可以避免很多问题。当然如果用 signals 的方式去实现 throttle ，也和 RxJS 的 throttle 不同。
   - 但也正因为如此，signals 需要看到各种各样的“状态”，建立这些状态之间的依赖关系，所以像 throttle 这种异步行为，存在多个状态，从 signals 的角度来说，实现起来其实很繁琐。虽然社区会有一些很好的封装，但我个人觉得，signals 其实并不适合这种“异步”的心智模型。负担太大了。
   - 反而是 Observable 天生就是一种异步流的心智模型，可以用来帮忙消解这种复杂度。

在文章开始之前，我需要补充一些客观情况：

1. Observable 虽然参考了 RxJS，但是它裁剪了很多 operator，像 debounce、throttle 等等，我不知道这些能否通过现有的 operator 来实现，这是一个兼容性问题，需要展开讨论一下。
2. Rxjs 有背压，但是 Observable 提案中并没有提到背压相关的内容，这同样也是一个兼容性问题，需要展开讨论一下。

注意文章的结构格式是：

````
# 这是标题
## 一、这是段落
```ts
// 使用typescript作为示例代码
```
````
