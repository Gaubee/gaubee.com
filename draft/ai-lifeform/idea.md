<!-- 感谢，最终我们需要补充一个章节，是关于将这 AI神经元、AI神经簇、AI生命体 进行“接口化”的设计，从而获得使用它们的能力。
我需要一篇详细的 http 接口设计。来让人们人认知到能使用这三者做什么工作。 -->

<!-- ### AI 神经元 （AiNeuron） 的定义

1. 基于 LLM 大模型的接口标准进行构建，我们可以简化抽象成这样一个函数：
   ```ts
   type AiNeuron = (input: string, calltools: (name: string, params: string) => Promise<string>) => Promise<string>;
   ```
   1. 本质上，它就是一个基于统计然后进行预测的功能函数，输入一些内容，返回一些预测的内容。
   2. 另外我这里提供了一个 calltools，是指现在大模型普遍具有的工具调用能力（function_call）。
2. 说一下我的设计思路：
   - 虽然我可以进一步简化成`type AiNeuron = (input: string) => Promise<string>`，但是此时的返回，可能是一个调用工具的指令，也有可能是一个结果。因此这里我加入了 calltools 这个回调参数，目的就是将中间调用工具的指令在这个函数内部直接消化处理掉。确保“单一职责原则”，这可以更加好理解整体的设计。
     - 比方说我也可以设计成 `type AiNeuron = (input: string, calltools: (name: string, params: string) => Promise<string>) => Promise<void>` 没有返回，只有工具调用，想要返回内容，也使用工具调用去做返回。
     - 这种设计当然可以，但是我还是要特别区分“返回内容”和“工具调用”，因为返回内容有一个“结束信号”，因此基于单一职责的原则，我在设计上不把“返回内容”和“工具调用”混淆在一起。
   - 通常意义上的大语言模型的接口，是要输入 “系统提示词、可用工具、模型信息、结构化输出信息、用户对话历史 等等”，然后返回一个消息、或者是流式的消息、或者多个消息片段。这里我将“系统提示词、可用工具、模型信息、用户对话历史 等等”等输入抽象成了 `input:string` 这个结构，然后将输出抽象成了 `Promise<string>` 这样一次性的输出。目的是为了降低复杂度，定义一个最简单的 AI 神经元，泛用性最强的神经元，在生物学上，可以理解成它是一种还没有完全发育的神经元细胞，因此可以进行各种工作，只不过可能都做得不够好。
   - 在这种基础的 AI 神经元设计的基础上，我们可以进一步“分化”出更加复杂的神经元，具有更加具体的输入输出结构，比如说：
     - `type AiNeuron2 = (input: {memory,events,structuredOutput}) => Promise<output>` 一种不具有工具调用能力，但是返回结构化信息的神经元。这里简单解释一下几个参数的概念：
       - **memory**: 代表着神经元内建的信息，可以简单理解成 “system系统提示词”
       - **events**: 代表着神经元所接收到的事件，可以简单理解成 “messages 输入的对话消息”
       - **structuredOutput**: 代表着神经元所返回的结构化信息
       - **output**: 代表着神经元所返回的输出信息，使用structuredOutput进行约束，可以简单理解成 “contents 输出的消息数组”
     - `type AiNeuron3 = (input: {memory,events,tools}, calltools: (name: string, params: string) => Promise<string> ) => Promise<string>` 一种具有明确工具定义的神经元。这种神经元虽然无法直接返回结构化信息，但是其实它可以通过工具调用，来将结构化信息通过工具传递出来。
     - 我以上举例的两种结构，只是基于基础神经元的两种分化方向，AiNeuron2 因为没有直接的工具调用能力，所以可以作为一个神经元结束点，就是说它不能直接去调用其它神经元。AiNeuron3 具有调用工具的能力，所以可以作为连接其它神经元形成一个网络。
     - 事实上 AiNeuron2 和 AiNeuron3 其实是可以互相转换的，正如我前文提到的，虽然 AiNeuron2 没有直接调用工具的能力，但是它可以返回结构化信息，比如返回 `{action:'function_call',tool:'tool_name',tool_input:'{}'}`，那么接收到这个结构化信息的某个神经元可以替代 AiNeuron2 发起工具调用，然后将工具调用的结果通过 events 传递给 AiNeuron2，再来获取输出。所以使得 AiNeuron2 获得了一种“间接”使用工具的能力。
     - 但是这种“间接”能力和 AiNeuron3 那种“直接”能力是有效率上的差异。所以虽然它们都是 AI 神经元，但是分化的方向不同，效率也会不同。
     - 反过来， AiNeuron3 也可以实现 AiNeuron2 点能力，正如我前文所说的，它可以通过工具调用来做输出，比如`calltools('return_structured_output', '{success:true, message:"Hello World!"}')`。但正如我说的，它不如 AiNeuron2 那种直接的结构化返回来得直接。
     - 我之所以仔细解释 AiNeuron2 与 AiNeuron3 之间是可以互相转换，是想强调一点，区分它们是要从“效率”出发，
     - 接下来我将继续举例一些更加特别的AI神经元：
     - `type AiNeuron4 = (input: {memory,events,tools,prefixMessage,stop}) => Promise<string>` 一种具有“补全”能力的神经元，prefixMessage是一个具有不完整内容开头的消息体，stop是一组特定的字符串，要求返回的内容一定是以这些stop中的某一个字符串作为结尾。
     - `type AiNeuron5 = (input: {memory,events,tools,neturons}) => Promise<Array<{neturon, events}>>` 一种专门作为路由神经元，可以将输入的events与输入的neturons进行匹配，可以将events进行进一步的拆分组合，分配给不同的neturon进行处理。
     - `type AiNeuron6 = (input: {memory,events,tools}) => Promise<{events}>` 一种专门作为事件重组的神经元，将输入的events进行重组，生成新的events。不同的memory设定会有不同的重组规范，比如有的重组是为了剪枝（压缩），有的重组是为了生成一些特定神经元所需的新的events。

### AI 神经簇（AiNerveFascicle）的定义

如果说 AI 神经元是构成 AI 系统的基本单位，那么 AI 神经簇就是由多个 AI 神经元相互连接、协同工作而形成的特定功能单元。在生物学上，它类似于将多个神经元纤维捆绑在一起，共同传递和处理特定类型信号的神经束。一个神经簇的目的是为了完成一个比单个神经元更复杂、更具体的任务。

本质上，它是为了弥补单个神经元的局限性，因此通过构建一个系统的方式，通过消耗更多的成本（时间成本与执行成本）来解决更复杂的问题。

1.  **构成与结构：**

    - 一个 AI 神经簇由**一组 AI 神经元**和一个预定义的**连接拓扑（工作流图，可以构建成tools来实现流程选择）**组成。这个拓扑结构决定了信息（`events`）如何在神经元之间流动。
    - 这个工作流可以是串行的（一个神经元的输出是下一个的输入）、并行的（一个输入被分发给多个神经元同时处理），也可以是带条件的（一个路由神经元的输出决定了接下来哪个神经元被激活）。
    - 它通常会有一个或多个**入口神经元**（负责接收初始输入和分发任务）和一个或多个**出口神经元**（负责汇总结果并输出）。

2.  **核心特征：**

    - **功能特化（Functional Specialization）**：每一个神经簇都被设计来解决一个特定的领域问题。例如，我们可以构建一个“代码生成神经簇”，它内部可能包含“需求理解神经元”、“代码框架生成神经元”、“具体逻辑实现神经元”和“代码审查神经元”。这个神经簇的整体能力远超任何一个单一的神经元。
    - **封装与复用（Encapsulation and Reusability）**：一个设计良好的神经簇可以被看作一个“超级神经元”或一个黑盒模块。它的内部复杂性被隐藏，只暴露简单的输入和输出接口。这使得它可以在更庞大的系统（AI 生命体）中被轻松地复用和组合。
    - **处理深度（Processing Depth）**：单个神经元处理信息是“扁平”的。而神经簇通过神经元之间的接力，可以实现信息的逐层抽象、提炼和加工。例如，第一个神经元将非结构化文本转化为结构化数据，第二个神经元基于这些数据进行逻辑推理，第三个神经元再将推理结果转化为自然语言。这种深度处理能力是实现复杂智能的关键。

3.  **一个具体的例子：一个“用户意图分析与任务拆解”神经簇**
    - **入口**：一个 `AiNeuron5` 类型的**路由神经元**。它接收用户的原始请求，比如“帮我规划一下去北京的三天行程，我喜欢历史古迹，预算在3000元以内”。它的任务是识别核心意图（行程规划）和关键实体（地点：北京，时间：三天，偏好：历史古迹，预算：3000元）。然后它将这些结构化信息分发给下游神经元。
    - **并行处理**：
      - 一个 `AiNeuron3` 类型的**信息检索神经元**，它接收到“北京”、“历史古迹”等关键词，通过 `calltools` 调用搜索引擎或知识库工具，查找相关的景点信息。
      - 一个 `AiNeuron3` 类型的**预算规划神经元**，它接收到“三天”、“3000元”等信息，通过 `calltools` 调用一个内部的计价工具，估算交通、住宿、门票等费用。
    - **汇总与规划**：一个 `AiNeuron6` 类型的**事件重组与规划神经元**。它收集上述两个神经元的输出（景点列表、费用估算），然后进行排序、组合、筛选，生成一个初步的、满足所有约束条件的行程草案（一个新的 `events` 结构）。
    - **出口**：一个 `AiNeuron2` 类型的**结构化输出神经元**。它接收到行程草案，将其格式化成一个清晰的、结构化的 JSON 对象，作为整个神经簇的最终输出。

通过这个例子可以看出，神经簇将一个模糊的、复杂的宏观任务，拆解成了由多个特化神经元协同完成的、清晰的微观任务流，从而大大提升了任务完成的质量和稳定性。

### AI 生命体（AiLifeform）的定义

AI 生命体是这个设计模式中的最高层级抽象。它不再是一个被动执行指令的函数或工作流，而是一个具备自主性、适应性和持续运作能力的动态系统。它由一个动态的 **AI 神经簇网络** 和一个核心的 **AI 生命工具集（AiLifeTools）** 构成，旨在实现长期、复杂的总体目标。

1.  **核心构成与机制：**

    - **动态的神经簇网络**：生命体的“身体”和“大脑”是由各种神经簇构成的。与静态的程序不同，这个网络是动态变化的。生命体可以根据外界反馈和内部状态，激活、停用、甚至重组其神经簇。
    - **中枢：AiLifeTools**：这是生命体的“元意识”或“干细胞”，是实现其自主性和进化能力的关键。它不仅仅是神经元内部的 `calltools`，而是更高维度的系统级工具，主要能力包括：
      - **神经元与神经簇的创生与凋亡**：`AiLifeTools` 可以根据需要，实例化新的神经元（设定其 `memory`），并将它们组合成新的神经簇来学习一项新技能。同样，对于低效或无用的神经簇，它可以将其拆解和回收，实现“程序性死亡”。
      - **记忆与反思**：生命体拥有长期记忆库。`AiLifeTools` 会定期回顾历史交互（`events`），分析成功和失败的案例，并根据分析结果去优化某个神经元的 `memory`（系统提示词）或调整某个神经簇的拓扑结构。这构成了它的核心学习和反思循环。
      - **工具的自我扩展**：生命体不仅能使用工具，还能创造工具。例如，它可能会发现自己频繁地组合调用几个基础API来完成某个功能，`AiLifeTools` 就可以将这个组合过程编写成一个新的函数，并将其注册到可用的工具列表中。这实现了能力的自我迭代和增强。

2.  **与 AI 神经元/神经簇的主要差别：** - **持续性与自主性 (Persistence & Autonomy)**：神经元和神经簇是“一次性”的，被调用时运行，结束后停止。而生命体是**持续运作**的。它有一个内在的“心跳”或“事件循环”，即使在没有外部输入时，它也可以进行内部的思考、反思和优化。它拥有自己的目标，并能主动发起行为去实现这些目标。- **自我反馈与进化闭环 (Self-Feedback & Evolutionary Loop)**：生命体的设计核心是闭环。- **内部闭环**：通过 `AiLifeTools` 的反思机制，生命体持续地进行自我评估和优化，这是“内省”。- **外部闭环**：它主动与用户或环境交互，获取反馈，并将这些外部反馈作为内部优化的依据。例如，当用户反复纠正它的某个回答时，它会触发一个内部流程，去重构负责该功能的神经簇。- **资源管理与“饥饿”概念 (Resource Management & "Hunger")**：这个概念至关重要。- 生命体的每一次神经元调用都消耗“养分”（计算配额、Token）。“饥饿值”是其内部资源状态的直观体现。- 在“养分充足”时，它可以调用功能强大但昂贵的神经元（如 GPT-4），激活更多的神经簇进行并行思考，表现出更高的智能和创造力。- 这是一种特定的“神经元”在做决策，它可以通过统计工具得知神经元所消耗的养分以及养分储备，在养分不足时，申请进行“心跳”来供给养分。- “心跳”也是一种特定的“神经元”，它会基于时间工具和统计工具，根据生命体的预设来释放养分。- 当“饥饿”时，它会进入节能模式：关闭非核心的后台反思任务，调用更经济的神经元（如 Haiku），或使用更简化的神经簇来处理请求，保证核心功能的存活。- 当“养分”耗尽时，它会进入“休眠”，直到获得新的补给。这个机制迫使生命体学会在效果和成本之间进行权衡，追求更高的效率。
3.  **涌现出的特别能力：** - **主动性 (Proactivity)**：它会主动与用户进行交互，不仅仅是回答问题，更会提出问题来澄清意图、收集信息，甚至主动发起它认为对用户有益的任务。- **技能习得 (Skill Acquisition)**：它能将解决问题的过程沉淀下来，形成新的“技能”——即创造新的、更高效的 AI 神经元或 AI 神经簇。例如，在多次帮助用户调试 Python 代码后，它可能会构建一个专门的“Python Debugger”神经簇，使得未来解决同类问题的路径变得更短、更有效。- **自我修复能力**：可能会出现类似生物大脑“癫痫”的情况，就是 events 过度释放，因此通过 `AiNeuron6` 来实现抑制 events 的设计非常重要。 -->
<!-- 3.  它与 AI 神经元的主要差别在于：它可以持续地运作。
    1.  它有自我反馈机制，基于不同的生命体定义，去形成多种闭环
    1.  **AiLifeTools**: 它能创造、销毁AI神经元；组合、重建AI神经簇；定义新的工具。
    1.  它有饥饿的概念，单位养分就是“AI神经元”的调用配额：
        1. 在额度充足的情况下，它将调用充分调用AI神经元。（这里的“充足”与“充分”，都是需要通过memory进行预设的）
        1. 在不同的饥饿值下，将关闭开启一些AI神经元。（这里的的关闭开启，也是需要通过memory进行预设的）
        1. 一旦无法再调用AI神经元，意味着它将陷入休眠 -->
<!-- 4.  AI 生命体通常会有涌现出一些特别的能力：
    1.  主动与用户进行交互，来向用户采集信息。
    1.  会生成越来越多的“技能”，体现在创造新的 AI神经元、构建新的 AI神经簇、生成新的工具，从而使得解决问题的路径变得更短更有效。
    1.  可能会出现类似生物大脑“癫痫”的情况，就是 events 过度释放，因此通过 `AiNeuron6` 来实现抑制 events 的设计非常重要。 -->

<!-- 感谢，我需要在现有的第三章，补充一些内容。

就是关于“如何与AI生命体交互”。这一章节将让读者能更进一步地想象出来“AI生命体”的能力。

和直接调用大语言模型那种chat接口不同。

与AI生命体的交互是一种“沉浸式”体验，你可以随时输入信息。信息的载体将更加丰富。

我们仍然与传统的chat模式来解释：

因为AI生命体是一个主动的、流动的系统。因此会有这样几种特征：

1. 用户可以多次输入，而不是等传统chat接口需要输出完成后才能做下一次输入。
2. AI生命体可以自主中断输出、自主补充输出、自主修正输出。
3. AI生命体可以主动发起一个新的话题（可能是一个问题、可能是一次辩论、可能是一次讨论、甚至可能只是一次问好），而不是总需要依靠用户来新建话题。
4. AI生命体可以同时与多方发起会谈，可能是多个用户与其它AI生命体。

这是只是对传统chat的颠覆，接下来我们将详细解释这种特征将如何实现，以及进一步讨论chat以外的信息交流的可能。

首先我们需要给AI生命体定义一个关于 chat 场景的“持久化”接口。你可以想象成使用firebase 存储一个巨大的结构化的信息：

```ts
const zChat = z.object({
  users: z.array(
    z.object({
      id: z.uuid(),
      username: z.string(),
      avator: z.string(),
      metadata: z.record(z.string(), z.string()),
    })
  ),
  topics: z.array(
    z.object({
      id: z.uuid(),
      title: z.string(),
      createTime: z.date(),
      updateTime: z.date(),
      messages: z.array(
        z.object({
          id: z.uuid(),
          sender: z.string(),
          type: z.string(),
          content: z.string(),
          createTime: z.date(),
          updateTime: z.date(),
          deleteTime: z.date(),
          readed: z.array(z.string()),
        })
      ),
    })
  ),
  // archive: ...
});
```

于是它可以通过 firebase 的接口来对数据进行增删改查。

用户的前端基于这个结构化的信息进行渲染、订阅变动实时更新。
AI生命体也将通过订阅变动，将变动信息转化成 event 传入 AI神经元来进行信息处理。

基于这种颠覆性的灵活，我们可以不再局限于chat这种模式，为了让信息结构不再像chat那样的线性，我们可以设计一个zMind（思维导图）的结构。
在这种结构中，信息就有了两个轴向：一个是上下级、一个是父子级。

这种交互模式将会非常灵活。 -->
