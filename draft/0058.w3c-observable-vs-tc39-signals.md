---
title: w3c-observable-vs-tc39-signals
date: 2025-04-09T06:59:40.546Z
updated: 2025-04-09T07:14:17.478Z
---

今天聊聊前端界正在暗流涌动的两大提案——**Observable** 和 **Signals**。

我先简单粗暴地总结一下这两个提案的本质：
**如果说 Observable ≈ 动态的 Array，那么 Signals ≈ 动态的 Function。**

---

## 一、Observable：流动的盛宴，时间的数组

咱们先想想**数组 (Array)**。它是个啥？就是一个值的**集合**，对吧？你可以 `map` 它，`filter` 它，`reduce` 它。这些操作都是同步的，作用在数组这个**静态**的、空间上的集合。

现在，给这个静态的数组加上**时间维度**，会发生什么？

它就“活”了！不再是一堆固定在那儿的值，而是变成了一个**随着时间不断有新值“流”过来**的序列。这，就是 **Observable**！

- **值的序列**：就像数组里的元素一个接一个，Observable 发出的值也是一个接一个，只不过是在时间轴上展开。`click` 事件、WebSocket 消息，不就是这样吗？
- **操作符 (Operators)**：数组有 `map`, `filter` 这些方法，Observable 也有！这些操作符就像是数组方法的“时间版”，它们不处理静态集合，而是处理这个**动态的事件流**。你想对流里的每个值做点转换？用 `map`！想过滤掉某些值？用 `filter`！想在流结束前只取几个值？用 `take`！
- **核心思想**：Observable 把我们熟悉的“集合操作”从**空间维度**扩展到了**时间维度**。它关注的是如何处理**一连串随时间发生的事件**。

**所以，当你需要处理的是一串接一串、需要各种转换、过滤、合并等操作的“动态数据序列”时，把它想象成一个“会动的数组”——Observable，思路是不是就清晰多了？** 它就像一条数据加工流水线，或者说，是一条会随着时间自动填充和滚动的传送带。

---

## 二、Signals：智慧的计算，响应的函数

接下来看 **Signals**。咱们先想想**函数 (Function)**。它干啥的？接收输入（参数 Arguments），执行一段计算逻辑，返回一个输出。函数本身定义是**静态**的。你想让它根据不同的输入产生不同的输出，你就得**重新调用**它，并传入新的参数。

现在，给这个静态的函数加上**动态依赖**，会发生什么？

这个函数就“智能”了！它不再需要你手动调用来更新。它的“参数”不再是固定的值，而是变成了其他的 **Signals**（这些 Signals 本身的值可能在变）。更神奇的是：

- **自动感知变化**：这个“动态函数”（也就是 `Signal.Computed`）能够**自动知道**它的“输入参数”（依赖的 Signals）变了。
- **自动重新计算（且懒惰）**：当依赖变化后，它**不会立刻**重新计算，而是等到有人真正需要它的新结果（调用 `.get()`）时，**才去**重新计算。如果依赖没变，它就直接返回上次缓存的结果。
- **源头活水**：那这些动态变化的“参数”源头是哪来的？就是 `Signal.State`！你可以把它看作是这个“动态函数系统”里最基础的、**可以被手动改变的输入源**。

**所以，当你需要根据一些可能变化的基础状态，计算出另一些衍生状态，并希望这个计算过程是自动的、高效的（只在需要时计算、只在结果变化时触发后续更新）时，把它想象成一个“会自动更新的智能函数”——Signals，是不是感觉抓住了重点？** 它就像一个电子表格里的单元格，它的值可以是一个公式（依赖其他单元格），当其他单元格变化时，它的值会自动更新（当然，是在你需要看它的时候才算）。

---

## 三. 类比虽好，细节更关键 (深入理解)

用“动态数组”和“动态函数”来理解 Observable 和 Signals 非常直观，但咱们也得清楚，任何类比都有局限性。它们之间还有一些重要的差异，这个类比没能完全覆盖：

1.  **推 (Push) vs. 拉 (Pull) / 混合模式：**

    - **Array/Function**：通常是**拉**模式。你主动去迭代数组，或者主动去调用函数。
    - **Observable**：是纯粹的**推**模式。数据（事件）来了，它主动推送给订阅者 (Observer)。
    - **Signals**：是一种**推拉结合 (Push-Pull Hybrid)**。当依赖的 `State` 变化时，它会**推送通知**给依赖它的 `Computed` 或 `Watcher`（告知它们“可能脏了”），但 `Computed` 的**重新计算**则是在你**拉取**（调用 `.get()`）时才发生的。`Watcher` 的副作用执行也是被通知后**异步调度**执行的（通常也是拉取最新的值）。

2.  **取消 (Cancellation) / 清理 (Disposal)：**

    - **Observable**：处理的是可能无限的流，**取消订阅**是其核心能力之一，非常重要。它关系到停止接收数据和释放资源。
    - **Signals**：`Computed` 的生命周期通常与使用它的地方绑定。其清理主要是通过 `Watcher` 的 `unwatch` 来实现的，当你不再需要某个副作用 (effect) 时，需要取消对相关 Signal 的监视，以便让不再被引用的 Signal 能够被垃圾回收。重点在于**资源管理和避免内存泄漏**。

3.  **显式状态 (Explicit State)：**

    - **Signals** 体系中有一个非常明确的 `Signal.State`，代表**可变的、基础的状态源**。这是其“动态函数”类比中，“动态参数”的源头。Observable 本身不直接管理状态，它只负责传递事件/数据。

4.  **内置保证 (Built-in Guarantees)：**
    - **Signals** 的设计核心包含了**无毛刺 (Glitch-free)** 更新和**缓存 (Memoization)**。这些是其实现精确、高效状态联动的基础，是“动态函数”类比之外的重要特性。Observable 虽然可以通过操作符实现类似缓存的效果，但不是其固有的核心机制。

---

## 四、场景再审视：动态数组 vs. 动态函数，用在哪？

现在，用咱们的新视角再看看它们适合的场景：

- **用“动态数组”(Observable) 的时候：**

  - 处理一连串用户点击、按键、鼠标移动事件。（事件的**序列**处理）
  - 实时接收和处理 WebSocket 或 SSE 数据流。（数据的**时间流**处理）
  - 构建复杂的拖拽交互、动画序列。（需要**编排**时间上的事件）
  - 当你需要像处理数组一样，对**一串随时间到来的数据**进行 `map`, `filter`, `debounce`, `switchMap` 等操作时。

- **用“动态函数”(Signals) 的时候：**
  - UI 组件的状态和视图绑定。（当**输入状态**变了，**输出视图**自动更新）
  - 表单中计算总价、剩余字数、校验状态等。（当基础**输入**变了，**衍生计算值**自动更新）
  - 数据仪表盘，多个图表依赖同一份筛选条件。（当**共享状态**变了，所有**依赖它的计算/展示**自动更新）
  - 当你需要定义一些**计算逻辑**，这些逻辑依赖于其他**可能变化的值**，并希望系统能**自动、高效**地维护它们之间的同步时。

---

## 五、殊途同归？未来展望

Observable 和 Signals，一个像是在时间轴上挥洒自如的“动态数组”，一个像是精准响应依赖变化的“动态函数”。它们都源于解决现代 Web 开发中的复杂性问题，但切入点和核心机制迥然不同。

- **Observable** 更像是一个**通用的异步事件/数据流处理工具**。如果 W3C 提案能顺利落地，它会成为 Web 平台处理流式数据和复杂事件交互的内置利器。
- **Signals** 则更专注于**状态管理和响应式更新的核心机制**。TC39 的提案若能成功，有望统一各个前端框架的响应式底层，带来更好的互操作性和性能。它更像是构建响应式系统的**基础设施**。

它们并非取代关系，很可能在未来并存，甚至协同工作。你可以用 Observable 这条“动态数组流水线”来获取和初步处理数据，然后把结果注入到 Signals 这个“动态函数计算网络”中，驱动 UI 的最终更新。

理解它们如同“动态数组”和“动态函数”的本质差异，能帮助我们更清晰地思考何时、何地、以及如何运用它们。
