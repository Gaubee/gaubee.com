<!doctype html><html lang=zh-CN><meta charset=utf-8><title>浅谈Async Generator · Gaubee</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/css/main.css rel=stylesheet><link href=/webmanifest.json rel=manifest><meta content=#ec407a name=theme-color><link href=/articles.atom rel=alternate title="Gaubee's Articles Atom feed" type=application/atom+xml><link href=/events.atom rel=alternate title="Gaubee's Events Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><header id=header><h1><a href=/ >Gaubee</a></h1><a href=#navigation-toggle id=nav-toggle>显示导航 Show navigation</a><nav><ul><li><a href=/ >主页 Home</a><li class=current><a href=/articles>文章 Articles</a><li><a href=/events>小事件 Events</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>浅谈Async Generator</h1><p class=meta>发布于 <time datetime=7/17/2018 itemprop=datePublished>7/17/2018</time> · 最后修改时间 <time datetime=7/18/2018 itemprop=dateModified>7/18/2018</time> · 标签： <a href=/blog/tags/javascript class=tag>javascript</a> <a href=/blog/tags/cogitation class=tag>cogitation</a></header><div itemprop=articleBody><p>会议初学编程的时候，那时候学的还是asp.net，然后看到substrack一个演讲视频：<a href="https://www.youtube.com/watch?v=lQAV3bPOYHo">Harnessing The Awesome Power Of Streams</a>，觉得：“哇！流这种编程思想我要学！”，从此就开始入了nodejs的坑。然而直到现在2018年，async iterator的出现，才勉勉强强提供了一种语法层级的流编程的体验。<p>一开始，基于事件编程，开发者通过监听一个个事件（从<code>on("data", fn)</code>开始），来模拟事件流程。这勉强算是一种实现，它最大的问题是需要创建大量的callback，维护它的代价就是需要书写大量冗余的代码与抽象的封装才能勉强达到稳定可用的级别。<br>事情的转机从Generator的出现开始，与其并行推广的还有提早一阵子出现的Promise。大部分人对Generator的使用无非就是<code>co</code>这个库的骚操作。不过确实，单纯Generator这个语法特性，很难在jser里头引起什么大风浪，毕竟js里头基本都是异步编程，Generator除了模拟现在的async/await以外很难有大舞台。<h2 id=async-generator tabindex=-1><a href=#async-generator class=header-anchor>Async Generator</a></h2><p>有趣的在async iterator这个语法出台，Generator才算正式杀入js的异步编程。<h3 id=%E5%85%A5%E9%97%A8 tabindex=-1><a href=#%E5%85%A5%E9%97%A8 class=header-anchor>入门</a></h3><p>举个简单的例子：<pre class=language-js><code class=language-js><span class="token keyword">const</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span>fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">'./big-file'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token keyword">await</span><span class="token punctuation">(</span><span class="token keyword">const</span> data <span class="token keyword">of</span> stream<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre><p>这种写法相比<code>on('data', fn)</code>这种写法，最大的区别在于资源的控制与利用上：基于事件的监听，nodejs会尽可能也必须尽可能快速地去触发<code>data</code>事件，而并不知道你到底有多么需要这些<code>data</code>，反正它就是冲着榨干硬件资源的操作去无脑触发就是了（当然你也可以直接使用文件句柄来手控操作，也能规避这个问题）。<h3 id=%E8%BF%9B%E9%98%B6 tabindex=-1><a href=#%E8%BF%9B%E9%98%B6 class=header-anchor>进阶</a></h3><p>再举一个实践的例子，我最近在做的节点扫描：从一个节点扫描出N个节点，然后再从这N个节点中扫描下一级的节点，不断收集，直到满足需求为止，伪代码如下：<pre class=language-ts><code class=language-ts><span class="token keyword">type</span> <span class="token class-name">Peer</span> <span class="token operator">=</span> <span class="token punctuation">{</span> origin<span class="token operator">:</span><span class="token builtin">string</span><span class="token punctuation">;</span> level<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">PeerService</span> <span class="token punctuation">{</span>
  peerList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>origin<span class="token operator">:</span><span class="token string">'http://peer.com:777'</span><span class="token punctuation">,</span> level <span class="token operator">:</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 初始节点</span>
  async <span class="token operator">*</span><span class="token function">searchPeers</span><span class="token punctuation">(</span>
    enter_port_peers <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>peerList<span class="token punctuation">,</span> <span class="token comment">// 初始的节点</span>
    collection_peers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> Peer<span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 节点去重用的表</span>
    parallel_pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ParallelPool<span class="token operator">&lt;</span>Peer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 1. 并行池，可以同时执行2个任务</span>
  <span class="token punctuation">)</span><span class="token operator">:</span> AsyncIterableIterator<span class="token operator">&lt;</span>Peer<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// Generator function 无法与箭头函数混用，所以这里的this必须主动声明在外部。</span>
    <span class="token comment">/*递归搜索代码片段*/</span>
    <span class="token keyword">const</span> <span class="token function function-variable">recursiveSearch</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span>skip_when_no_full<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> peers <span class="token keyword">of</span> parallel_pool<span class="token punctuation">.</span><span class="token function">yieldResults</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        ignore_error<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 忽略错误（忽略不可用的节点）</span>
        skip_when_no_full<span class="token punctuation">,</span> <span class="token comment">// 在池子不填满的情况下是否返回</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> peer <span class="token keyword">of</span> peers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">yield</span> peer<span class="token punctuation">;</span><span class="token comment">// 3. 先返回节点，然后再递归搜索</span>
          <span class="token keyword">yield</span><span class="token operator">*</span> self<span class="token punctuation">.</span><span class="token function">searchPeers</span><span class="token punctuation">(</span><span class="token punctuation">[</span>peer<span class="token punctuation">]</span><span class="token punctuation">,</span> collection_peers<span class="token punctuation">,</span> parallel_pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<p><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> enter_port_peer <span class="token keyword">of</span> enter_port_peers<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>
<span class="token comment">// 2. 向并行池中添加任务</span><br>
parallel_pool<span class="token punctuation">.</span><span class="token function">addTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span><br>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_searchPeers</span><span class="token punctuation">(</span>enter_port_peer<span class="token punctuation">,</span> collection_peers<span class="token punctuation">)</span><span class="token punctuation">,</span><br>
<span class="token punctuation">)</span><span class="token punctuation">;</span><br>
<span class="token keyword">yield</span><span class="token operator"><em></em></span> <span class="token function">recursiveSearch</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如果并行池满了，等待一个任务完成后再继续填充</span><br>
<span class="token punctuation">}</span><br>
<span class="token keyword">yield</span><span class="token operator"></span> <span class="token function">recursiveSearch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>
<span class="token punctuation">}</span><br>
<span class="token keyword">private</span> <span class="token keyword">async</span> <span class="token function">_searchPeers</span><span class="token punctuation">(</span><br>
enter_port_peer<span class="token operator">:</span> <span class="token keyword">typeof</span> <span class="token constant">PEERS</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>
collection_peers<span class="token operator">:</span> Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> Peer<span class="token operator">></span><span class="token punctuation">,</span><br>
<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>
<span class="token comment">// TODO: 使用API获取与之相连的节点集合，并使用collection_peers去重</span><br>
<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">as</span> Peer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>
<span class="token punctuation">}</span><br>
<span class="token punctuation">}</span></code></pre><p><p>以上代码中有三个重点：<br>1️⃣ 并行池的设计，是因为网络的数据请求应该尽可能预先加载，这里默认能同时有2数据请求在执行<br>2️⃣ 我在一开始根据一个已知的节点表，把所有的下载任务尽肯能添加到池子中<br>3️⃣ 每个任务返回的是一组节点，但以流的思想，拆解成一个个往外返回。外部拿到这个节点后，可以进行一些分析，比如试探这个节点是否正常，延迟多少等等。如果外部觉得节点够多了，这个生成器就不需要再执行下去。如果不够，那么就继续搜索下去。要注意的时候，在返回到外部的时候，因为我们使用了并行池的设计，所以理论上还有其它的一些网络请求任务也在执行。<p>当然，有这个并行池的设计，你要把上面的代码改成基于事件触发的也不是不行。无非是多写点代码，多创建一些函数，通过代码拼接来完成整个AsyncIterator肯定也是可以的。async Generator只是提供给我们一种更加直观的写法与思考方式。<h2 id=%E6%9C%AA%E6%9D%A5 tabindex=-1><a href=#%E6%9C%AA%E6%9D%A5 class=header-anchor>未来</a></h2><p>语法特性的增加，最大的好处就是减少了错误的发生。<br>这可能与其它一些语言的设计哲学并不相同，有的语言追求有且只有一种写法来实现需求。而js则是告诉你你这段代码还能简单+精简+可读+可维护+。<br>按现有的提案，管道操作符<code>|></code>与函数部分执行<code>fn(1, ?)</code>这两个语法如果通过提案了，对于流编程也会带来很大的便利性。</div><footer></footer></article></main><footer id=footer><div><nav><a href=https://twitter.com/gaubeebangeel rel="me nofollow" target=_blank>Twitter</a> · <a href="https://github.com/gaubee/gaubee.com/tree/main/./src/articles/浅谈Async Generator.md" rel=nofollow target=_blank>Edit this page on GitHub</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>除非有特别的说明, 该站点所有直接内容都使用许可证：<a href=https://creativecommons.org/licenses/by/4.0/deed.zh>署名 4.0 国际 (CC BY 4.0)</a></small><blockquote><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用</small> <small style=display:block><a href=https://beian.mps.gov.cn/#/query/webSearch>闽ICP备17026139号-1</a></small></blockquote></footer><script src=/js/dark-mode-toggle.mjs type=module></script><script src=/js/time-elements.mjs type=module></script><script src=/js/main.mjs type=module></script>