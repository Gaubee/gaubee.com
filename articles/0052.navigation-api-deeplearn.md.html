<!DOCTYPE html><html lang="zh-CN"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/icon-192x192.png"><meta name="generator" content="Astro v5.13.9"><title>深入理解 Navigation API</title><meta name="description" content="GauBee's personal blog"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.B3vRBseb.js"></script><link rel="stylesheet" href="/_astro/editor.ByX6VvEs.css"></head> <body class="bg-white text-zinc-900 transition-colors duration-300 dark:bg-zinc-900 dark:text-zinc-50">  <div class="flex max-w-7xl mx-auto"> <aside class="hidden lg:block sticky top-0 h-screen w-64 flex-shrink-0 py-8 pr-8"> <aside class="w-64 p-4 pr-8"><nav class="flex flex-col space-y-2"><a href="/" class="flex items-center gap-4 py-3 px-6 text-lg font-semibold no-underline text-zinc-900 dark:text-zinc-100 rounded-full transition-colors duration-200 ease-in-out hover:bg-gray-200 dark:hover:bg-zinc-800"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-house" aria-hidden="true"><path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"></path><path d="M3 10a2 2 0 0 1 .709-1.528l7-6a2 2 0 0 1 2.582 0l7 6A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path></svg><span>主页</span></a><a href="/events" class="flex items-center gap-4 py-3 px-6 text-lg font-semibold no-underline text-zinc-900 dark:text-zinc-100 rounded-full transition-colors duration-200 ease-in-out hover:bg-gray-200 dark:hover:bg-zinc-800"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss" aria-hidden="true"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg><span>时事快讯</span></a></nav></aside> </aside> <main class="flex-1 min-w-0"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="1r9xoI" prefix="r13" component-url="/_astro/MobileNav.GHWk5zau.js" component-export="default" renderer-url="/_astro/client.DcVwxw19.js" props="{&quot;title&quot;:[0,&quot;深入理解 Navigation API&quot;]}" ssr client="load" opts="{&quot;name&quot;:&quot;MobileNav&quot;,&quot;value&quot;:true}" await-children><div id="mobile-topbar" class="sticky top-0 z-50 flex h-14 items-center justify-between border-b border-zinc-200 bg-white/80 px-4 backdrop-blur-sm dark:border-zinc-800 dark:bg-zinc-900/80 lg:hidden"><div class="w-6"></div><div class="absolute left-1/2 -translate-x-1/2 text-sm font-semibold text-zinc-700 dark:text-zinc-300">深入理解 Navigation API</div><button type="button" aria-label="Open menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu" aria-hidden="true"><path d="M4 5h16"></path><path d="M4 12h16"></path><path d="M4 19h16"></path></svg></button></div><template data-astro-template> <div class="space-y-4"> <astro-island uid="D5LMs" prefix="r7" component-url="/_astro/TableOfContentsCard.DZ19Aq2Y.js" component-export="default" renderer-url="/_astro/client.DcVwxw19.js" props="{&quot;headings&quot;:[1,[[0,{&quot;depth&quot;:[0,2],&quot;slug&quot;:[0,&quot;一-设计哲学-the-why&quot;],&quot;text&quot;:[0,&quot;一、 设计哲学 (The “Why”)&quot;]}],[0,{&quot;depth&quot;:[0,4],&quot;slug&quot;:[0,&quot;导航生命周期的完整定义&quot;],&quot;text&quot;:[0,&quot;“导航生命周期”的完整定义：&quot;]}],[0,{&quot;depth&quot;:[0,2],&quot;slug&quot;:[0,&quot;二-解决问题的思路-the-how&quot;],&quot;text&quot;:[0,&quot;二、 解决问题的思路 (The “How”)&quot;]}],[0,{&quot;depth&quot;:[0,4],&quot;slug&quot;:[0,&quot;state-vs-searchparams-的使用时机&quot;],&quot;text&quot;:[0,&quot;state vs. searchParams 的使用时机&quot;]}],[0,{&quot;depth&quot;:[0,2],&quot;slug&quot;:[0,&quot;三-背后的故事与动机-the-context&quot;],&quot;text&quot;:[0,&quot;三、 背后的故事与动机 (The “Context”)&quot;]}],[0,{&quot;depth&quot;:[0,2],&quot;slug&quot;:[0,&quot;四-与其它提案的联动-synergies&quot;],&quot;text&quot;:[0,&quot;四、 与其它提案的联动 (Synergies)&quot;]}],[0,{&quot;depth&quot;:[0,2],&quot;slug&quot;:[0,&quot;五-关于-navigation-api-polyfill&quot;],&quot;text&quot;:[0,&quot;五、 关于 Navigation API Polyfill&quot;]}]]]}" ssr client="load" opts="{&quot;name&quot;:&quot;TableOfContentsCard&quot;,&quot;value&quot;:true}" await-children><div class="rounded-xl border bg-card text-card-foreground shadow"><div class="p-6 pt-0"><ul><li><a href="#一-设计哲学-the-why">一、 设计哲学 (The “Why”)</a></li><li><a href="#导航生命周期的完整定义">“导航生命周期”的完整定义：</a></li><li><a href="#二-解决问题的思路-the-how">二、 解决问题的思路 (The “How”)</a></li><li><a href="#state-vs-searchparams-的使用时机">state vs. searchParams 的使用时机</a></li><li><a href="#三-背后的故事与动机-the-context">三、 背后的故事与动机 (The “Context”)</a></li><li><a href="#四-与其它提案的联动-synergies">四、 与其它提案的联动 (Synergies)</a></li><li><a href="#五-关于-navigation-api-polyfill">五、 关于 Navigation API Polyfill</a></li></ul></div></div><!--astro:end--></astro-island> <!-- <TagsCard client:load tags={allTags} />
          <ArchiveCard client:load postsByMonth={postsByMonth} /> --> </div> </template><!--astro:end--></astro-island> <div class="p-6">  <article class="prose dark:prose-invert max-w-none"> <h2 id="一-设计哲学-the-why">一、 设计哲学 (The “Why”)</h2>
<ol>
<li><strong>将导航的“语义”交还浏览器：</strong> 传统 SPA 路由（基于 <code>history.pushState</code>/<code>replaceState</code>）本质上是在“欺骗”浏览器。我们只是改变了 URL 和一些历史记录状态，但浏览器本身并不知道一次真正的“导航”正在发生。Navigation API 的核心哲学是<strong>让浏览器真正理解并参与到 SPA 的导航过程中</strong>。它不再仅仅是被动地记录历史条目，而是主动地管理导航生命周期。</li>
<li><strong>以用户意图为中心，而非技术实现：</strong> <code>pushState</code> 是一个低级、命令式的操作。Navigation API 则更加声明式和事件驱动。它关注的是用户发起的导航意图（如点击链接、前进/后退按钮）或程序触发的导航请求 (<code>navigation.navigate()</code>)，并围绕这个意图提供了一套完整的生命周期事件 (<code>navigate</code>, <code>navigatesuccess</code>, <code>navigateerror</code>, <code>currententrychange</code>)。这使得开发者可以更好地响应和控制导航流程。</li>
<li><strong>标准化与健壮性：</strong> 在 Navigation API 出现之前，每个前端框架都需要在 <code>history</code> API 之上构建自己复杂的路由管理逻辑，包括处理并发导航、滚动恢复、焦点管理、可访问性（ARIA Live Regions 通知等）。这导致了实现碎片化和潜在的健壮性问题。Navigation API 旨在提供一个<strong>标准化的、更健壮的底层基础</strong>，让框架和开发者能在此之上构建更可靠、更一致的用户体验。</li>
<li><strong>拥抱异步本质：</strong> 现代 Web 应用的导航往往涉及异步操作（代码分割加载、数据获取）。<code>history</code> API 对此无能为力。Navigation API 通过 <code>NavigateEvent.intercept(handler)</code> 明确地支持了异步导航处理，允许开发者在导航真正完成（URL 变更、DOM 更新）之前执行异步任务，并且可以优雅地处理成功、失败或取消。</li>
</ol>
<section class="sup">
<h4 id="导航生命周期的完整定义">“导航生命周期”的完整定义：</h4>
<p>“导航生命周期”在 Navigation API 的语境下，指的是从<strong>用户或程序发起导航意图</strong>开始，到<strong>导航最终完成（成功或失败），并且浏览器状态（URL、历史记录、DOM）更新</strong>为止的整个过程，以及期间由浏览器管理和触发的一系列事件和状态。</p>
<p>其关键阶段和事件包括：</p>
<ol>
<li>
<p><strong>导航触发 (Initiation):</strong></p>
<ol>
<li>用户行为：点击链接 (<code>&#x3C;a></code>)、提交表单（如果未被阻止且目标是当前标签页）、点击浏览器前进/后退/刷新按钮。</li>
<li>程序化调用：<code>navigation.navigate()</code>, <code>navigation.reload()</code>, <code>navigation.back()</code>, <code>navigation.forward()</code>, <code>navigation.traverseTo()</code>。</li>
</ol>
</li>
<li>
<p><strong><code>navigate</code> 事件分发 (Intent &#x26; Interception):</strong></p>
<ol>
<li>浏览器捕获导航意图，<strong>在任何实际状态改变（URL、History）之前</strong>，在 <code>window.navigation</code> 上触发 <code>navigate</code> 事件。</li>
<li>该事件 (<code>NavigateEvent</code>) 提供了导航的详细信息（目标 URL、状态、是否用户触发 <code>userInitiated</code> 等），以及控制导航的方法：</li>
<li><code>canIntercept</code>: 是否可以调用 <code>intercept()</code> (通常对于跨域导航等情况为 false)。</li>
<li><code>preventDefault()</code>: 同步取消导航。</li>
<li><code>intercept({ handler })</code>: <strong>核心机制</strong>。声明应用将接管导航处理（通常是异步的，如加载数据、更新 DOM）。浏览器会等待 <code>handler</code> 这个 async 函数关联的 Promise 完成。<code>handler</code> 会接收到一个 <code>AbortSignal</code> (<code>event.signal</code>) 用于处理后续导航触发的取消。</li>
</ol>
</li>
<li>
<p><strong>处理阶段 (Processing - if intercepted):</strong></p>
<ol>
<li>如果调用了 <code>intercept(options)</code>，浏览器等待 <code>options.handler</code> 的 Promise。</li>
<li>开发者在此 <code>handler</code> 中执行异步操作（fetch 数据、懒加载模块、渲染视图）。</li>
<li>如果在此期间发生<strong>新的导航</strong>，之前 <code>intercept</code> 的 <code>handler</code> 关联的 <code>AbortSignal</code> 会被触发 (aborted)，开发者应中止当前处理并让 <code>handler</code> 的 Promise reject 或快速 resolve。</li>
</ol>
</li>
<li>
<p><strong>提交阶段 (Commitment):</strong></p>
<ol>
<li><strong>如果未拦截或拦截成功完成 (handler Promise resolves):</strong></li>
<li>浏览器更新 URL。</li>
<li>更新 <code>navigation.currentEntry</code>。</li>
<li>将新的或更新后的 <code>NavigationHistoryEntry</code> 添加/更新到历史记录堆栈中。</li>
<li>触发 <code>navigatesuccess</code> 事件，表示导航逻辑成功完成。</li>
<li>更新 DOM（如果是由 <code>intercept</code> handler 负责的）。</li>
<li>触发 <code>currententrychange</code> 事件，因为 <code>currentEntry</code> 已改变。</li>
<li>浏览器可能执行默认行为，如滚动恢复、焦点管理、触发无障碍通知。</li>
<li><strong>如果拦截失败 (handler Promise rejects) 或导航被阻止:</strong></li>
<li>URL 和历史记录<strong>不</strong>发生改变。</li>
<li>触发 <code>navigateerror</code> 事件，表示导航逻辑失败。<code>currententrychange</code> <strong>不</strong>触发。</li>
</ol>
</li>
</ol>
<p>这个完整的生命周期由浏览器原生管理，提供了比 <code>popstate</code> + <code>pushState</code> 更为健壮和可预测的控制流，特别是对于异步操作和并发导航的处理。</p>
</section>
<h2 id="二-解决问题的思路-the-how">二、 解决问题的思路 (The “How”)</h2>
<ol>
<li><strong>显式导航生命周期管理：</strong>
<ol>
<li><strong><code>navigate</code> 事件：</strong> 核心入口。导航意图发生时触发。提供信息并允许控制：
<ol>
<li>检查目标 (<code>event.destination.url</code>, <code>event.destination.getState()</code>)。</li>
<li>同步取消 (<code>event.preventDefault()</code>)。</li>
<li>**关键：**通过 <code>event.intercept({ handler })</code> 声明接管导航，执行异步逻辑。<code>handler</code> (async function) 的 Promise 决定导航结果。浏览器等待此 Promise。</li>
</ol>
</li>
<li><strong><code>navigatesuccess</code> / <code>navigateerror</code> 事件：</strong> 在 <code>intercept</code> 的 <code>handler</code> 成功 resolve 或 reject 后（或无拦截时导航完成后）触发，提供明确的完成/失败信号。</li>
<li><strong><code>currententrychange</code> 事件：</strong> 当 <code>navigation.currentEntry</code> 发生变化时（导航成功完成、调用 <code>updateCurrentEntry()</code>）触发，响应当前历史条目状态更新。</li>
</ol>
</li>
<li><strong>更精细的历史记录管理：</strong>
<ol>
<li><strong><code>NavigationHistoryEntry</code> 对象：</strong> 结构化历史条目，含 <code>key</code> (唯一标识), <code>id</code> (同文档唯一), <code>url</code>, <code>index</code>, 和 <code>getState()</code> 获取关联状态。</li>
<li><strong><code>navigation.entries()</code>：</strong> 访问整个历史堆栈（只读视图）。</li>
<li><strong><code>navigation.updateCurrentEntry({ state })</code>：</strong> 在不触发导航的情况下，更新当前历史条目的状态（使用结构化克隆存储）。用于保存页面临时状态（表单、滚动位置等）。</li>
<li><strong><code>navigation.traverseTo(key)</code>：</strong> 直接导航到历史记录中指定 <code>key</code> 的条目，而非仅相对前进/后退。<strong>不</strong>会丢弃后续历史。</li>
</ol>
</li>
<li><strong>原生处理常见 SPA 痛点：</strong>
<ol>
<li><strong>滚动恢复：</strong> API 设计为浏览器实现更可靠的自动滚动恢复提供了基础（具体策略可能由浏览器决定）。开发者也可在 <code>navigate({scroll:"after-transition"|"manual"})</code> 或 <code>navigatesuccess</code> 中手动处理，或利用 <code>history.scrollRestoration</code>。</li>
<li><strong>焦点管理：</strong> 导航成功后，浏览器可以应用更智能的默认焦点行为（如 <code>autofocus</code> 或聚焦 <code>&#x3C;body></code>）。开发者也可在 <code>navigate({focusReset:"after-transition"|"manual"})</code> 或 <code>navigatesuccess</code> 中手动管理。</li>
<li><strong>可访问性 (A11y)：</strong> 标准化事件（尤其 <code>navigatesuccess</code>）为 ARIA live regions 或平台辅助技术提供了宣告页面转换的可靠时机。浏览器自身也可能利用此信号发出通知。</li>
<li><strong>并发处理（关键优势）：</strong> API 内建处理快速连续导航的机制。后续导航意图会通过 <code>AbortSignal</code> (<code>event.signal</code>) <strong>中止</strong>正在进行的 <code>intercept</code> handler，确保响应最新意图，防止竞态条件。
<blockquote>
<p>当一个导航被 <code>event.intercept({ handler })</code> 拦截并且 <code>handler</code> 的 Promise 正在进行中时，如果此时发生了<strong>另一次</strong>导航（用户点击、代码调用 <code>navigate()</code> 等），提案和规范对此有明确的处理机制：<strong>不是排队等待，而是后者取代前者 (Superseding)</strong>。具体流程如下：</p>
</blockquote>
<ol>
<li><strong>导航 A 触发:</strong> <code>navigate</code> 事件 A 触发。</li>
<li><strong>拦截 A:</strong> 代码调用 <code>eventA.intercept({ handler: handlerA })</code>。<code>handlerA</code> (async function) 开始执行。</li>
<li><strong>导航 B 触发 (在 <code>handlerA</code> 完成前):</strong> 用户点击链接或代码调用 <code>navigation.navigate()</code> 触发了新的导航 B。</li>
<li><strong>新 <code>navigate</code> 事件:</strong> 浏览器立即为导航 B 触发一个新的 <code>navigate</code> 事件 B。</li>
<li><strong>中止信号触发:</strong> <strong>关键点：<strong>与</strong>事件 A</strong> 关联的 <code>NavigateEvent</code> (<code>eventA</code>) 上的 <code>signal</code> (<code>eventA.signal</code>) 属性（这是一个 <code>AbortSignal</code>）会立即被浏览器<strong>触发 <code>abort</code></strong>。</li>
<li><strong>旧 <code>handler</code> 处理中止:</strong>
<ol>
<li><code>handlerA</code> 内部的代码<strong>应该</strong>监听这个 <code>eventA.signal</code>。可以通过 <code>eventA.signal.aborted</code> 检查状态，或者使用 <code>eventA.signal.addEventListener('abort', ...)</code>。</li>
<li>当检测到信号中止时，<code>handlerA</code> <strong>应该</strong>尽快停止其工作（例如，中止进行中的 <code>fetch</code> 请求，取消定时器，停止 DOM 更新）并让其返回的 Promise <strong>reject</strong> (通常使用一个表示中止的特定错误，如 <code>DOMException('AbortError')</code>) 或快速 resolve。</li>
</ol>
</li>
<li><strong>旧导航结果:</strong> 由于 <code>handlerA</code> 的 Promise 通常会因中止而 reject (或者即使 resolve，浏览器也知道它被中止了)，导航 A <strong>不会</strong>进入“提交阶段”。它不会更新 URL，不会触发 <code>navigatesuccess</code>。它可能会（也应该会）触发 <code>navigateerror</code> (如果 Promise reject 了)，但这代表的是被中止的导航 A 的失败，而不是导航 B 的状态。浏览器实质上<strong>抛弃 (discards)</strong> 了被中止的导航 A 的后续流程。</li>
<li><strong>新导航 B 继续:</strong> 导航 B 的 <code>navigate</code> 事件 (<code>eventB</code>) 现在正常处理。它可以被 <code>preventDefault()</code>, 或者也被 <code>intercept()</code> 等。它接管了导航流程。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="state-vs-searchparams-的使用时机"><code>state</code> vs. <code>searchParams</code> 的使用时机</h4>
<ol>
<li>
<p><strong><code>searchParams</code> (URL 查询参数):</strong></p>
<ol>
<li><strong>用途:</strong> 用于表示资源<strong>状态</strong>的关键参数，这些状态应该<strong>反映在 URL 中</strong>。它们定义了“你正在看什么”。</li>
<li><strong>特点:</strong>
<ol>
<li>可见、可编辑（用户可以直接修改 URL）。</li>
<li>可分享、可收藏。</li>
<li>通常是字符串键值对。</li>
<li>搜索引擎可索引。</li>
<li>改变 <code>searchParams</code> 通常意味着请求<strong>不同或过滤后</strong>的数据子集。</li>
</ol>
</li>
<li><strong>使用场景:</strong>
<ol>
<li>分页 (<code>?page=2</code>)</li>
<li>排序 (<code>?sort=price_desc</code>)</li>
<li>过滤 (<code>?category=electronics&#x26;brand=xyz</code>)</li>
<li>搜索词 (<code>?q=navigation+api</code>)</li>
<li>选项卡或视图切换（如果每个视图代表根本不同的内容切片，如 <code>?tab=details</code>）。</li>
<li>任何需要<strong>持久化</strong>、<strong>可链接</strong>地表示应用内容状态的情况。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong><code>navigation.currentEntry.getState()</code> / <code>navigation.navigate(url, { state: ... })</code> / <code>navigation.updateCurrentEntry({ state: ... })</code>:</strong></p>
<ol>
<li><strong>用途:</strong> 用于存储与<strong>特定历史记录条目</strong>相关联的、<strong>非 URL 可见</strong>的应用状态。它更多是关于“当你访问这个 URL 时，当时的 UI 处于什么临时状态”。</li>
<li><strong>特点:</strong>
<ol>
<li>用户不可见，不影响 URL 字符串。</li>
<li>不可直接分享或收藏（分享 URL 不会带上 <code>state</code>）。</li>
<li>可以存储更复杂的结构化数据（只要满足结构化克隆算法）。</li>
<li>与特定历史记录条目 (<code>NavigationHistoryEntry</code>) 绑定，通过 <code>back/forward/traverseTo</code> 导航回该条目时，可以恢复。</li>
<li>修改 <code>state</code> (通过 <code>updateCurrentEntry</code>) <strong>不</strong>会触发完整的导航生命周期（不触发 <code>navigate</code> 事件），只会触发 <code>currententrychange</code>。</li>
</ol>
</li>
<li><strong>使用场景:</strong>
<ol>
<li><strong>滚动位置恢复:</strong> 保存页面的精确滚动位置，以便返回时恢复 (虽然浏览器可能提供默认行为，但 <code>state</code> 可用于更精细的控制)。</li>
<li><strong>临时 UI 状态:</strong> 例如，模态框是否打开、某个 <code>&#x3C;details></code> 元素是否展开、手风琴面板状态。</li>
<li><strong>部分填写的表单数据:</strong> 用户填写了一半表单，导航离开又回来，可以恢复输入。</li>
<li><strong>列表中的高亮项:</strong> 用户在列表页点击一项进入详情，返回时希望之前点击的项仍然高亮。</li>
<li><strong>特定于访问的状态:</strong> 需要在同一次会话中、通过历史导航恢复的、与 URL 内容本身不直接相关的界面状态。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong><code>state</code> 是否被克隆存储?</strong></p>
<ol>
<li><strong>是的</strong>。传递给 <code>navigate()</code>, <code>updateCurrentEntry()</code> 或最初与 <code>pushState/replaceState</code> 关联的 <code>state</code> 对象，会被浏览器使用<strong>结构化克隆算法 (Structured Clone Algorithm)</strong> 进行克隆，然后存储。</li>
<li><strong>Implications:</strong>
<ol>
<li><strong>无法存储:</strong> 函数、DOM 节点、Error 对象、某些类的实例（除非它们特殊处理过）、带有循环引用的对象。</li>
<li><strong>可以存储:</strong> 原始类型、普通对象、数组、<code>Date</code>, <code>RegExp</code>, <code>Blob</code>, <code>File</code>, <code>FileList</code>, <code>ArrayBuffer</code>, <code>ImageData</code>, <code>Map</code>, <code>Set</code> 等。</li>
<li>性能考虑：存储非常大的对象可能会影响性能。</li>
<li>由于是克隆，后续修改原始对象不会影响存储的状态，反之亦然。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>选择依据:</strong>
问自己：这个状态是否需要体现在 URL 中？是否需要用户能够收藏或分享这个状态？这个状态是定义了资源内容本身，还是仅仅是用户与该资源交互时的临时界面状态？前者用 <code>searchParams</code>，后者用 <code>state</code>。它们可以并存。</p>
<h2 id="三-背后的故事与动机-the-context">三、 背后的故事与动机 (The “Context”)</h2>
<p>Navigation API (曾用名 App History API) 的诞生源于 Web 开发者社区和浏览器供应商多年来对 SPA 路由现状的普遍不满。<code>history</code> API 设计于 Web 早期，并未预见到现代复杂单页应用的导航需求。框架作者们（如 React Router, Vue Router, Angular Router）不得不花费大量精力来弥补底层 API 的不足。</p>
<p>你可以通过提案链接了解到这个提案发展的过程：<a href="https://github.com/WICG/navigation-api">github.com/WICG/navigation-api</a></p>
<p>也可以通过这个视频快速地了解其背后的故事：<a href="https://www.youtube.com/watch?v=cgKUMRPAliw">The history API is dead. Long live the navigation API | HTTP 203 YouTube</a></p>
<h2 id="四-与其它提案的联动-synergies">四、 与其它提案的联动 (Synergies)</h2>
<ol>
<li>
<p><strong>View Transitions API (依然是黄金搭档，但集成方式不同):</strong></p>
<ol>
<li>
<p>Navigation API 定义<strong>导航逻辑和时机</strong>，View Transitions API 处理<strong>视觉状态间的平滑过渡</strong>。</p>
</li>
<li>
<p><strong>集成方式：</strong> 在 Navigation API 的 <code>navigate</code> 事件监听器中：</p>
</li>
<li>
<p>调用 <code>event.intercept({ handler })</code> 来接管导航。</p>
</li>
<li>
<p>在 <code>handler</code> 这个异步函数内部，使用 <code>document.startViewTransition()</code> 包裹你的 DOM 更新和可能的数据获取逻辑。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#E1E4E8">navigation.</span><span style="color:#B392F0">addEventListener</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"navigate"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">event</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">event.canIntercept) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">document.startViewTransition) {</span></span>
<span class="line"><span style="color:#6A737D">    // 如果浏览器不支持 View Transitions</span></span>
<span class="line"><span style="color:#E1E4E8">    event.</span><span style="color:#B392F0">intercept</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#B392F0">      handler</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">async</span><span style="color:#E1E4E8"> () </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        /* 直接更新DOM */</span></span>
<span class="line"><span style="color:#E1E4E8">      },</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // 使用 View Transitions</span></span>
<span class="line"><span style="color:#E1E4E8">  event.</span><span style="color:#B392F0">intercept</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#F97583">    async</span><span style="color:#B392F0"> handler</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">      // ★ 在 intercept 的 handler 内部调用 startViewTransition</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> transition</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> document.</span><span style="color:#B392F0">startViewTransition</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">async</span><span style="color:#E1E4E8"> () </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // 异步加载数据（如果需要）</span></span>
<span class="line"><span style="color:#F97583">        const</span><span style="color:#79B8FF"> data</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#B392F0"> fetchData</span><span style="color:#E1E4E8">(event.destination.url);</span></span>
<span class="line"><span style="color:#6A737D">        // 更新 DOM</span></span>
<span class="line"><span style="color:#B392F0">        updateTheDOM</span><span style="color:#E1E4E8">(data);</span></span>
<span class="line"><span style="color:#E1E4E8">      });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">      // 可以选择等待过渡动画完成 (transition.finished)</span></span>
<span class="line"><span style="color:#6A737D">      // 或仅等待伪元素创建/DOM更新完成 (transition.updateCallbackDone)</span></span>
<span class="line"><span style="color:#6A737D">      // 或甚至不等待，取决于你的逻辑需求</span></span>
<span class="line"><span style="color:#F97583">      try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        await</span><span style="color:#E1E4E8"> transition.updateCallbackDone; </span><span style="color:#6A737D">// 至少等 DOM 更新完成</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (e) {</span></span>
<span class="line"><span style="color:#6A737D">        // 处理 DOM 更新或数据获取中的错误</span></span>
<span class="line"><span style="color:#E1E4E8">        console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"DOM update failed:"</span><span style="color:#E1E4E8">, e);</span></span>
<span class="line"><span style="color:#F97583">        throw</span><span style="color:#E1E4E8"> e; </span><span style="color:#6A737D">// 重新抛出，让 navigateerror 触发</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    },</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre>
</li>
</ol>
</li>
<li>
<p><strong>其它可能相关的领域 (间接):</strong></p>
<ol>
<li><strong>Speculation Rules API:</strong> 标准化的导航流程有助于更准确地触发 prefetch。
<ol>
<li>当 Navigation API 的 <code>navigate</code> 事件触发时，如果 Speculation Rules 已经成功 <code>prefetch</code> 了所需的数据或代码块，那么在 <code>intercept</code> handler 中执行的相应 <code>fetch</code> 或动态 <code>import()</code> 调用会显著加快，从而缩短导航的感知时间。</li>
<li>而 <code>&#x3C;link rel="prefetch"></code> 也可以达到预取效果，但 Speculation Rules 提供了更现代、更灵活、可能更强大的机制来做同样的事情，尤其是在动态识别和管理预取目标方面。</li>
<li><strong><code>eagerness</code> 控制 (虽然此特性还在演进)：</strong> 意图是允许开发者提示预取的紧迫性（例如，<code>eager</code> 可能意味着在用户悬停时就开始）。（注意：<code>eagerness</code> 的具体实现和行为仍在讨论和标准化中，浏览器可能有自己的策略）。</li>
<li>参考文章 <a href="https://developer.chrome.com/blog/speculation-rules-improvements">对 Speculation Rules API 的改进</a></li>
</ol>
</li>
<li><strong>Performance Timeline / Reporting API:</strong>
<code>navigatesuccess</code> 和 <code>navigateerror</code> 为性能监控和错误报告提供了更精确的时间点和上下文。</li>
</ol>
</li>
</ol>
<h2 id="五-关于-navigation-api-polyfill">五、 关于 Navigation API Polyfill</h2>
<p>为 Navigation API 编写一个功能完善的 Polyfill 挑战巨大，因为它试图在用户空间模拟浏览器内核级的导航管理（所以完全模拟是不现实的，只能说尽量，而且用户使用的时候要小心一些边缘情况）。</p>
<blockquote>
<p>目前市面上比较成熟的 Polyfill 仓库是 <a href="https://github.com/virtualstate/navigation">github.com/virtualstate/navigation</a> （esm-bundle 差不多需要 105kb）</p>
</blockquote>
<ol>
<li>
<p><strong>Polyfill 实现的核心难点 (普遍性挑战):</strong></p>
<p>模拟 Navigation API 的行为，尤其是在尝试复刻其所有功能时，会遇到一些根本性的限制，导致 Polyfill 的行为与原生 API 存在开发者和用户都能感知到的差异：</p>
<ol>
<li>
<p><strong>无法真正实现“事前”拦截浏览器历史导航 (<code>popstate</code>)</strong></p>
<ol>
<li><strong>挑战:</strong> 这是最核心的差异之一。原生 <code>navigate</code> 事件在浏览器实际更改 URL 或历史记录<strong>之前</strong>触发，允许开发者通过 <code>event.preventDefault()</code> 完全取消导航，或通过 <code>event.intercept()</code> 在状态改变前执行异步逻辑。然而，Polyfill 赖以感知浏览器前进/后退操作的 <code>popstate</code> 事件，是在 URL 和历史指针<strong>已经改变之后</strong>才触发。</li>
<li><strong>显著差异/局限性:</strong>
<ol>
<li><strong>无法阻止 <code>popstate</code> 导航:</strong> Polyfill 无法在 <code>popstate</code> 触发时真正阻止浏览器历史状态的改变。它最多只能在事件触发后，尝试通过 <code>history.pushState</code> 或 <code>history.replaceState</code> 将状态“修正”回来，但这会导致地址栏 URL 短暂闪烁成目标 URL 再变回来，用户可以明显感知。</li>
<li><strong>无法实现可靠的 <code>popstate</code> 前置校验:</strong> 开发者不能依赖 Polyfill 在用户点击后退按钮时，进行类似“您有未保存的更改，确定要离开吗？”的同步确认（因为状态已变）。原生 API 的 <code>navigate</code> 事件则可以完美支持此场景。</li>
</ol>
</li>
<li><strong>例子:</strong> 用户在表单页点击后退。使用原生 API，<code>navigate</code> 事件可以在 URL 变化前弹出确认框阻止导航。使用 Polyfill，<code>popstate</code> 触发时 URL 已变，Polyfill 尝试修正会引发 URL 闪烁，且阻止逻辑发生在状态改变之后。</li>
</ol>
</li>
<li>
<p><strong>无法控制浏览器原生 UI 和行为</strong></p>
<ol>
<li><strong>挑战:</strong> Polyfill 运行在 JavaScript 用户空间，对浏览器本身的 UI 组件和底层行为控制力为零。</li>
<li><strong>显著差异/局限性:</strong>
<ol>
<li><strong>加载指示器:</strong> Polyfill 无法控制浏览器的标签页加载微调器（spinner）或进度条。在 <code>intercept()</code> 执行异步操作期间，浏览器不会像原生导航那样显示加载状态，除非开发者手动模拟一个加载指示器。用户可能会感觉应用“卡顿”而不是“正在加载”。</li>
<li><strong>地址栏 URL 显示:</strong> 原生 API 在 <code>intercept()</code> 执行期间，地址栏通常会保持旧 URL，直到导航成功提交才更新。Polyfill 无法控制这一点，尤其是在 <code>popstate</code> 场景下，地址栏内容已经提前改变。</li>
<li><strong>原生滚动恢复/焦点管理:</strong> Polyfill 无法改变浏览器对 <code>history.scrollRestoration</code> 的处理方式，也无法完全复刻原生导航后复杂的默认焦点管理逻辑（例如 <code>autofocus</code> 属性在导航后的行为）。开发者需要手动实现滚动和焦点逻辑，其效果可能与原生默认行为有细微但可感知的差异。</li>
<li><strong>无障碍 (A11y) 通知:</strong> Polyfill 无法触发平台原生的导航成功/失败的无障碍通知。开发者必须手动更新 ARIA live regions 来宣告状态变化。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>难以拦截或阻止某些导航触发方式</strong></p>
<ol>
<li><strong>挑战:</strong> JavaScript 对某些浏览器内置的导航机制无能为力。</li>
<li><strong>显著差异/局限性:</strong>
<ol>
<li><strong>直接 <code>location</code> API 调用:</strong> 如 <code>location.assign()</code>, <code>location.replace()</code>, <code>location.href = ...</code>。Polyfill <strong>无法</strong>在这些调用实际执行并导致页面跳转或重载<strong>之前</strong>拦截它们。这是 Polyfill 的一个硬性限制，“做不到”阻止这类导航。
<blockquote>
<p>web-worker 中的 location 的定义是藏在原型链上的，所以可以覆写 self.location。
而 main-thread 中的 location 是直接锁定在 window.location 上，同时 location 本身的属性也都锁死在 location 自身的对象上，完全没有使用原型链，所以基本锁死了所有的修改的可能。</p>
</blockquote>
</li>
<li><strong>非 JS 触发的导航:</strong> 如 <code>&#x3C;meta http-equiv="refresh"></code> 或用户通过浏览器扩展触发的导航，Polyfill 基本无法介入。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>状态管理 (<code>getState/state</code>)：跨页面加载的历史上下文恢复挑战</strong></p>
<ol>
<li>
<p><strong>挑战:</strong> 尽管 <code>history.state</code> 支持结构化克隆且能在页面刷新后恢复<strong>当前</strong>条目的状态，但 Polyfill 面临的根本挑战在于<strong>恢复页面刷新前整个导航历史的上下文视图</strong>。页面重载会清除 Polyfill 在 JavaScript 内存中维护的内部历史表示（所有条目的 key, id, url, state 等信息）。为了在刷新后模拟 <code>navigation.entries()</code>、<code>navigation.traverseTo(key)</code> 等 API，Polyfill 必须尝试恢复这些丢失的信息，通常采取以下两种策略，每种策略都有其固有的、显著的局限性：</p>
</li>
<li>
<p><strong>Polyfill 策略 A: 将整个 <code>navigation.entries()</code> 存入当前 <code>history.state</code></strong></p>
<ol>
<li><strong>挑战:</strong> 这会导致该 <code>state</code> 对象的大小极易触及并超过浏览器对<strong>单个 <code>history.state</code> 对象的大小限制</strong>（该限制因浏览器而异，通常在几百 KB 到若干 MB）。</li>
<li><strong>显著差异/局限性:</strong>
<ol>
<li><strong>强加的存储限制:</strong> Polyfill 迫使开发者不仅要限制<strong>每个</strong>历史条目的 <code>state</code> 大小，而且应用的<strong>历史记录深度</strong>（<code>navigation.entries()</code> 的长度）本身也成为一个严格的限制因素。随着历史变长，<code>history.state</code> 会迅速达到上限，导致 Polyfill 无法保存新的历史信息或在刷新后恢复完整的上下文，行为变得不可靠或直接失败。这与原生 API（仅受单个条目大小限制，不受历史总长度的直接限制）的行为模式构成显著差异。</li>
<li><strong>性能开销:</strong> 序列化和反序列化整个大型历史表示对象，在每次导航（更新 <code>state</code>）和页面加载（恢复 <code>state</code>）时都会带来额外的性能开销。</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>Polyfill 策略 B: 使用外部存储 (<code>sessionStorage</code> 或者 IndexedDB) 持久化 Polyfill 历史表示</strong></p>
<ol>
<li><strong>挑战 (使用 <code>sessionStorage</code>):</strong> 将 Polyfill 的内部历史表示序列化为字符串存入 <code>sessionStorage</code>。</li>
<li><strong>显著差异/局限性 (使用 <code>sessionStorage</code>):</strong>
<ol>
<li><strong>类型限制与序列化复杂性:</strong> <code>sessionStorage</code> 仅能存储字符串。即使底层 <code>history.state</code> 支持结构化克隆，为了存入 <code>sessionStorage</code>，Polyfill 必须进行序列化。为了保持一致性，这里就需要额外引入类似 superjson 这样的库来做自定义的序列化反序列化。</li>
<li><strong>更严格的大小限制:</strong> <code>sessionStorage</code> 的大小限制（通常 5-10MB）可能比浏览器对单个 <code>history.state</code> 的限制更严格，进一步压缩了 Polyfill 能管理的总历史状态空间。</li>
<li><strong>同步读写性能:</strong> 在页面加载时同步读取和解析 <code>sessionStorage</code> 数据会阻塞主线程，影响启动性能。</li>
</ol>
</li>
<li><strong>挑战 (使用 IndexedDB):</strong> 将 Polyfill 的历史表示存入容量更大的 IndexedDB。</li>
<li><strong>显著差异/局限性 (使用 IndexedDB):</strong>
<ol>
<li><strong>同步/异步接口冲突:</strong> IndexedDB 是一个<strong>异步</strong> API，而 Navigation API 的核心部分（如 <code>navigation.entries()</code>, <code>navigation.currentEntry</code>, <code>entry.getState()</code>）是<strong>同步</strong>设计的。Polyfill 无法在调用这些同步方法时<strong>同步地</strong>从 IndexedDB 获取所需数据。这意味着：
<ol>
<li>刷新后首次调用这些同步 API 可能返回空、不完整或过时的数据，直到异步加载完成后状态才更新，这与原生 API 的即时可用性形成<strong>根本性差异</strong>。</li>
<li>如果 Polyfill 强制使用异步接口的设计，一方面开发者会感知到 API 行为的不一致，另一方面，应用启动的速度会受到一些影响，甚至会影响启动的正确性。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>并发导航处理中的可见状态风险 (非精确性导致的可感知问题)</strong></p>
<ol>
<li><strong>挑战:</strong> 虽然时序的微小差异本身不易察觉，但 Polyfill 在模拟 <code>AbortSignal</code> 和管理并发状态时若不够健壮，可能导致<strong>可感知的</strong>副作用。</li>
<li><strong>显著差异/局限性:</strong>
<ol>
<li><strong>状态更新冲突:</strong> 如果 Polyfill 未能及时或完全中止前一个 <code>intercept</code> handler（尤其当 handler 代码未良好响应中止信号时），旧 handler 可能在后续导航开始处理后，仍然修改了 DOM 或应用状态，导致界面短暂显示错误内容或数据不一致，用户可能看到“闪烁”或错误的中间状态。</li>
<li><strong>资源浪费:</strong> 未能中止的操作（如后台请求）会继续运行，消耗用户资源。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>使用 Navigation API Polyfill 的关键注意事项 (基于显著差异)</strong></p>
<ol>
<li><strong>弥补核心功能差距:</strong> 认识到 Polyfill <strong>无法</strong>真正实现 <code>popstate</code> 的事前拦截（影响离开确认等场景），也无法控制原生 UI（加载指示器、滚动/焦点）或触发平台级无障碍通知。<strong>开发者必须手动实现</strong>这些缺失的 UI 反馈和辅助功能。同时，应规范使用 <code>navigation.navigate()</code>，避免 Polyfill 难拦截的 <code>location</code> API 调用。</li>
<li><strong>在限制内管理状态与性能:</strong> 由于 Polyfill 跨页面加载恢复历史上下文的挑战（常依赖 <code>sessionStorage</code>），<strong>必须严格限制 <code>state</code> 中存储数据的复杂度和大小</strong>，并注意<strong>控制历史记录深度</strong>，以防超出存储限制或遭遇序列化问题。确保 <code>intercept</code> Handler <strong>健壮地处理 <code>AbortSignal</code></strong> 以应对并发。最后，<strong>优先条件加载</strong> Polyfill，并进行<strong>性能评估</strong>。</li>
</ol>
</li>
</ol> </article>  </div> </main> <aside class="hidden lg:block sticky top-0 h-screen w-64 flex-shrink-0 py-8 pl-8"> <div class="space-y-4"> <div class="rounded-xl border bg-card text-card-foreground shadow"><div class="p-6 pt-0"><ul><li><a href="#一-设计哲学-the-why">一、 设计哲学 (The “Why”)</a></li><li><a href="#导航生命周期的完整定义">“导航生命周期”的完整定义：</a></li><li><a href="#二-解决问题的思路-the-how">二、 解决问题的思路 (The “How”)</a></li><li><a href="#state-vs-searchparams-的使用时机">state vs. searchParams 的使用时机</a></li><li><a href="#三-背后的故事与动机-the-context">三、 背后的故事与动机 (The “Context”)</a></li><li><a href="#四-与其它提案的联动-synergies">四、 与其它提案的联动 (Synergies)</a></li><li><a href="#五-关于-navigation-api-polyfill">五、 关于 Navigation API Polyfill</a></li></ul></div></div> <div class="rounded-xl border bg-card text-card-foreground shadow"><div class="flex flex-col space-y-1.5 p-6"><div class="font-semibold leading-none tracking-tight">Tags</div></div><div class="p-6 pt-0"><div class="flex flex-wrap gap-2"><a href="/tags/article" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">article</a><a href="/tags/event" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">event</a><a href="/tags/rust" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">rust</a><a href="/tags/iced" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">iced</a><a href="/tags/gui" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">gui</a><a href="/tags/multiplatform" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">multiplatform</a><a href="/tags/mobile" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">mobile</a><a href="/tags/web" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">web</a><a href="/tags/Kotlin" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">Kotlin</a><a href="/tags/linux" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">linux</a><a href="/tags/dns" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">dns</a><a href="/tags/javascript" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">javascript</a><a href="/tags/async" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">async</a><a href="/tags/reactive" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">reactive</a><a href="/tags/html&amp;css" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">html&amp;css</a><a href="/tags/cogitation" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">cogitation</a><a href="/tags/tools" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">tools</a><a href="/tags/efficiency" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">efficiency</a><a href="/tags/trivial" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">trivial</a><a href="/tags/lift" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">lift</a><a href="/tags/C++" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">C++</a></div></div></div> <div class="rounded-xl border bg-card text-card-foreground shadow"><div class="flex flex-col space-y-1.5 p-6"><div class="font-semibold leading-none tracking-tight">Archive</div></div><div class="p-6 pt-0"><ul><li><a href="/archive/2025/09">2025-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2025/06">2025-06<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2025/05">2025-05<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2025/04">2025-04<!-- --> (<!-- -->12<!-- -->)</a></li><li><a href="/archive/2025/03">2025-03<!-- --> (<!-- -->9<!-- -->)</a></li><li><a href="/archive/2024/05">2024-05<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2024/04">2024-04<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/archive/2023/05">2023-05<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2023/04">2023-04<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2023/03">2023-03<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2022/10">2022-10<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2022/04">2022-04<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2021/12">2021-12<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/archive/2021/07">2021-07<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2021/04">2021-04<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2020/10">2020-10<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2020/09">2020-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2020/05">2020-05<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2020/04">2020-04<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2020/03">2020-03<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2018/07">2018-07<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2017/10">2017-10<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2017/03">2017-03<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/10">2016-10<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2016/09">2016-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/08">2016-08<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/07">2016-07<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/05">2016-05<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/03">2016-03<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/02">2016-02<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2015/02">2015-02<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2014/09">2014-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2014/04">2014-04<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2014/03">2014-03<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2014/02">2014-02<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2014/01">2014-01<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2013/12">2013-12<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2013/10">2013-10<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2013/09">2013-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2013/08">2013-08<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2013/07">2013-07<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2013/06">2013-06<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2013/05">2013-05<!-- --> (<!-- -->4<!-- -->)</a></li></ul></div></div> </div> </aside> </div> <astro-island uid="Tziuc" prefix="r11" component-url="/_astro/BackToTop.SXSzft_N.js" component-export="default" renderer-url="/_astro/client.DcVwxw19.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;BackToTop&quot;,&quot;value&quot;:true}" await-children><button type="button" aria-label="Back to top" class="fixed right-8 bottom-8 z-50 flex h-12 w-12 items-center justify-center rounded-full bg-zinc-900/20 text-white shadow-lg backdrop-blur-sm backdrop-saturate-200 transition-opacity duration-300 hover:bg-zinc-700 dark:bg-zinc-100/20 dark:text-zinc-900 dark:hover:bg-zinc-300 opacity-0"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-up" aria-hidden="true"><path d="m5 12 7-7 7 7"></path><path d="M12 19V5"></path></svg></button><!--astro:end--></astro-island>  </body></html>