<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, article"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>单页应用 路由系统 与 链接跳转、页面渲染 三者之间的最佳实践</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
</head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="target" href="/articles/">Articles</a> <a class="" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="article-wrapper"><main><h1>单页应用 路由系统 与 链接跳转、页面渲染 三者之间的最佳实践</h1><p>随着 Google Chrome 的升级改进，Polymer 上使用的接口接近稳定，所以我就将 Polymer 拿出来进行重新学习。 学习 Polymer 和其它框架不一样的是，其它框架，遇到问题，只能是阅读源码或者寻求社区帮助。Polymer 遇到问题，最重要的想法就是：这是原生的接口，用原生开发的思想去解决。那么问题往往就迎刃而解了。</p><p>这篇文章涉及到的是如标题所示的路由系统 与 链接跳转、页面渲染三者之间的关系。</p><p>以往的开发思维就是：绑定就是一切！大部分 MV*框架过来的人包括我的思维都有一个定视流程：链接的改变 → 触发路由改变 → 触发改变状态机 → 触发渲染页面上要显示那部分的内容。 这是一个很正确的流程，这种绑定是稳定的，就等于即便是触发链条上某一个节点，后面的节点也能正确的触发渲染。</p><p>然而这里有一个很重要的问题需要去重视：渲染性能。</p><p>就因为这是一条因果链，所以我们惯性思维往往就是使用统一的数据源来进行管理。这也导致了我跑到<a href="https://github.com/PolymerElements/paper-tabs">Polymer/paper-tabs</a>下头发了一个相关的提问： (https://github.com/PolymerElements/paper-tabs/issues/182)。</p><p>但后来我从原生的角度去进行思考后，想到了问题所在，这不是框架或者组件的问题，而是思维方式的问题。纠正后，我现在的思维方式是这样的：</p><p>首先：链接、链接选择器（列表菜单、tabs 等带选择的组件） 这类的组件数据绑定归为一起。确保页面上的元素的联动关系不变：比如在窄屏有一个竖向的导航，宽屏有一个横向导航，二者的数据绑定是要一致的。</p><p><img src="/assets/vertical-layout-EnUAUA-u.png" alt="image"></p><p><img src="/assets/landscape-layout-ChLE1mQj.png" alt="image"></p><p>当用户点击链接后，我们要做的就是将 loading 效果打开。而此时的<strong>内容部分</strong>、<strong>标题</strong>不改发生改变。如果是旧思维的单数据源绑定关系链的话，标题肯定会跟变，内容部分也会进入不友好的空白状态（或者会带一个 loading 提示）。 但我们遵从原生的特性的话：比如用户在浏览器地址栏中键入另外一个地址，页面不会马上发生改变，而是依旧显示当前页面状态，并显示一个 loading 的信号。因为你可能会进行取消操作，那么当前页面依旧会友好地为用户服务。 同理，在用户点击链接后，我们要做的仅仅是把 loading 效果打开就行了。效果如如下</p><p><img src="/assets/show-loading-BebHO-b7.png" alt="image"></p><p>当页面数据加载下来，紧接的就是页面切换动画了（PS：要注意的是用户可能在加载期间点击了其它链接，所以我们要在每次加载前的时候生成一个 render_id，并在加载完成后进行渲染前对比这个 render_id 是否匹配。以免错误地渲染）。在页面完成切换后，那么这时候就用户就可以确认他已经切换到他想要的页面了。</p><p>在视觉上认可后，由于这时候动画已经执行完毕，我们可以对路由进行改变了， 最后路由的改变单向影响到链接选择器组件上。</p><p><img src="/assets/change-link-BqJGtOlG.png" alt="image"></p><p>综上所属：<strong>路由与链接选择器的关系是单向绑定的关系</strong>，这点很重要，如果加载出错了，那么链接选择器应该回滚选择，回滚到什么状态，应该问路由，然后再去显示错误的信息。</p><p>很常见的双向绑定的结果就是，当加载出错，处理函数获取 404 的内容并显示，那么链接选择器切换到 404 选项，而双向绑定把这个结果反映到路由上，这是错误的！因为当用户发现错误进行刷新页面的时候，由于链接变成了 404，那么他怎么刷新都是 404，所以切记使用 路由 → 链接选择器 这样的单向绑定。</p><hr><p>最后一张图总结：</p><p><img src="/assets/summary-Ct4O0Plh.png" alt="image"></p><p>参考源码： https://gist.github.com/Gaubee/b3f1cb93b7fb593fd3d00a834ffd8332</p></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>