<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, article"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>View Transitions API (Level-2 cross-document)</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
<link rel="manifest" href="/manifest.webmanifest"><script id="vite-plugin-pwa:register-sw" src="/registerSW.js"></script></head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="target" href="/articles/">Articles</a> <a class="" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="article-wrapper"><main><h1>View Transitions API (Level-2 cross-document)</h1><p>上一篇文章咱们聊了 <a href="/article/0054.css-view-transitions-1">View Transitions API (Level-1 single-document)</a> 如何优雅地解决了 SPA（单页应用）里那为了动画而扭曲 DOM、编写复杂 JS 的痛点。通过 <code>document.startViewTransition</code>、快照机制和神奇的伪元素树，它成功地将 <strong>DOM 状态更新</strong> 与 <strong>视觉过渡动画</strong> 解耦，让开发者能轻松实现丝滑的同文档视图切换。</p><p>但是，Level 1 的能力仅限于“家里面”（同一个文档）。一旦涉及到“出门串门”（跨文档导航，比如从 <code>a.html</code> 跳到 <code>b.html</code>），那熟悉的白屏闪烁又回来了。MPA（多页应用）的用户体验难道就只能停留在“上古时代”吗？</p><p>W3C 的大佬们显然不满足于此。于是，<strong>CSS View Transitions Module Level 2</strong> 应运而生，它的核心使命，就是<strong>将 Level 1 的丝滑体验，延伸到传统的跨文档导航场景</strong>，并在此基础上增加更多强大的功能！</p><p>今天，咱们就接着上一篇的步伐，重点探索 Level 2 的世界，看看它是如何打通跨文档的“任督二脉”，以及它带来了哪些令人兴奋的新特性！</p><h2>一、初心不改：Level 2 的核心目标与设计哲学</h2><p>Level 2 继承并扩展了 Level 1 的核心哲学：<strong>解耦 DOM 更新与视觉过渡</strong>。但它的目标更宏大：</p><ol><li><strong>拥抱 MPA：</strong> 正视 MPA 在 Web 生态中的重要地位，为其提供现代化的过渡体验。</li><li><strong>声明式优先：</strong> 尽可能通过简单的 CSS（<code>@view-transition</code> 规则）来启用跨文档转场，降低接入成本。</li><li><strong>生命周期钩子：</strong> 在跨文档导航的关键节点（旧页面卸载前、新页面展现前）提供 JS 事件 (<code>pageswap</code>, <code>pagereveal</code>)，赋予开发者精细控制的能力。</li><li><strong>能力增强：</strong> 不仅仅是解决跨文档问题，还基于实践反馈，加入了选择性转场、样式复用、自动命名、嵌套转场、分层捕获等一系列“武功秘籍”。</li></ol><p>简而言之，Level 2 就是要在尊重并兼容传统 MPA 架构的前提下，将流畅转场的能力普及化、标准化，并让它变得更强大、更灵活。</p><h2>二、入门：跨文档转场，只需“一句咒语”？</h2><p>想让你的 MPA 页面跳转也动起来？Level 2 说，基础操作很简单：</p><p><strong>核心开关：<code>@view-transition</code> 规则</strong></p><p>你需要在<strong>跳转前</strong>和<strong>跳转后</strong>两个页面的 CSS 中，都加入这个新的 <code>@</code> 规则，并设置 <code>navigation</code> 描述符：</p><pre class="language-css"><code class="language-css"><span class="token comment">/* 在 page-a.html 和 page-b.html 的 CSS 里都要有 */</span>
<span class="token atrule"><span class="token rule">@view-transition</span></span> <span class="token punctuation">{</span>
  <span class="token property">navigation</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span> <span class="token comment">/* 关键先生！告诉浏览器，我想自动开启跨文档转场 */</span>
<span class="token punctuation">}</span></code></pre><p>只要加上这句，并且满足以下<strong>浏览器自动触发的条件</strong>：</p><ol><li><strong>同源（Same Origin）</strong>：安全第一，必须的。</li><li><strong>用户触发导航</strong>：点击链接、提交表单、浏览器前进/后退等。地址栏输入、书签等不算。</li><li><strong>页面可见</strong>：导航期间页面得在前台。</li><li><strong>无跨域重定向</strong>：中间不能有跨域跳转搅局。</li><li><strong>双方同意</strong>：两个页面都得写上 <code>navigation: auto;</code>。</li></ol><p>那么，恭喜你！从 <code>page-a.html</code> 跳转到 <code>page-b.html</code> 时，默认的<strong>交叉淡入淡出 (cross-fade)</strong> 效果就会自动应用。是不是比 Level 1 的 <code>document.startViewTransition</code> 更“傻瓜化”？</p><p>当然，这只是起点。默认效果往往不能满足我们骚动的心，我们需要更精妙的控制。</p><h2>三、进阶：掌控生命周期，定制跨文档之旅</h2><p>Level 1 里我们有 <code>startViewTransition</code> 的回调和返回的 <code>ViewTransition</code> 对象（包含 <code>ready</code>, <code>finished</code> 等 Promise）。在 Level 2 的跨文档场景下，流程变了，控制方式也随之升级：</p><p><strong>跨文档生命周期 &amp; JS 钩子：</strong></p><ol><li><p><strong>用户操作 (Old Document):</strong> 点击链接/后退等。</p></li><li><p><strong><code>pageswap</code> 事件 (Old Document - <code>window</code> 上监听):</strong> 这是旧页面被换掉前的<strong>最后机会</strong>！</p><ul><li>你可以通过 <code>event.viewTransition</code>（如果转场条件满足，它就是个 <code>ViewTransition</code> 对象，否则为 <code>null</code>）来搞事情。</li><li><strong>用途：</strong><ul><li>检查导航信息（<code>event.activation</code>），比如 <code>navigationType</code> 是不是 <code>traverse</code> (前进/后退)。</li><li>动态给转场添加类型 <code>event.viewTransition.types.add('my-type')</code>，用于后续 CSS 选择性应用动画（见下文）。</li><li>根据某些条件决定<strong>跳过转场</strong> <code>event.viewTransition.skipTransition()</code>。</li><li>在 <code>event.viewTransition.finished</code> Promise 中执行清理工作（注意，这可能在页面从 BFCache 恢复后才触发）。</li></ul></li></ul><pre class="language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"pageswap"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>event<span class="token punctuation">.</span>viewTransition<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 不满足转场条件</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"旧页面拜拜前，最后搞点事！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 例如：给后退导航加个特殊类型</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>activation<span class="token punctuation">.</span>navigationType <span class="token operator">===</span> <span class="token string">"traverse"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    event<span class="token punctuation">.</span>viewTransition<span class="token punctuation">.</span>types<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"going-back"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>捕获旧状态 &amp; 卸载旧页面。</strong></p></li><li><p><strong><code>pagereveal</code> 事件 (New Document - <code>window</code> 上监听):</strong> 新页面 DOM 加载完毕，<strong>首次渲染前</strong>触发。</p><ul><li>同样通过 <code>event.viewTransition</code>（如果转场是从旧页面成功启动的，这里就会有值）来操作。</li><li><strong>用途：</strong><ul><li>在新页面侧确认转场是否依然有效，或根据新页面的状态决定跳过。</li><li>可以在这里修改转场类型 <code>event.viewTransition.types.add/remove/clear()</code>。</li><li>等待 <code>event.viewTransition.ready</code> 来执行需要新旧状态都捕获完成才能开始的 JS 动画（类似 Level 1）。</li><li><strong>重要：</strong> Level 2 里，这个 <code>event.viewTransition</code> 的 <code>updateCallbackDone</code> Promise 是一开始就 resolved 的（因为 DOM 更新是浏览器导航完成的，不是由你的回调触发）。</li></ul></li></ul><pre class="language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"pagereveal"</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>event<span class="token punctuation">.</span>viewTransition<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 没有进行转场</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"新页面来了，我瞅瞅！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 例如：如果 URL 包含 #no-transition，就跳过</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">"no-transition"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    event<span class="token punctuation">.</span>viewTransition<span class="token punctuation">.</span><span class="token function">skipTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 可以等 ready 后用 JS 控制动画</span>
  <span class="token keyword">await</span> event<span class="token punctuation">.</span>viewTransition<span class="token punctuation">.</span>ready<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"新旧状态都好了，准备浪起来！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// document.documentElement.animate(...)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>捕获新状态 &amp; 执行动画 &amp; 完成。</strong></p></li></ol><p><strong>新状态何时稳定？靠“渲染阻塞”！</strong></p><p>Level 2 没有 <code>updateCallback</code> Promise 了，浏览器怎么知道新页面何时“准备就绪”可以拍新照片了？答案是<strong>渲染阻塞机制 (Render-blocking mechanism)</strong>。</p><p>开发者可以通过给 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>, <code>&lt;script&gt;</code>, 甚至新增的 <code>&lt;link rel=&quot;expect&quot; href=&quot;#element-id&quot;&gt;</code> (等待特定元素出现) 添加 <code>blocking=&quot;render&quot;</code> 属性，来告诉浏览器：“等这些关键资源加载/执行/元素就位后，再算我新页面稳定了，才能拍快照、启动动画！”</p><pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
  <span class="token comment">&lt;!-- 样式必须先应用 --></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>style.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
  <span class="token comment">&lt;!-- 默认就是 render-blocking --></span>
  <span class="token comment">&lt;!-- 这个 JS 可能调整布局，等它执行完 --></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>layout-fix.js<span class="token punctuation">"</span></span> <span class="token attr-name">blocking</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>render<span class="token punctuation">"</span></span> <span class="token attr-name">async</span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token comment">&lt;!-- 等主要内容区域加载并解析出来 --></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>expect<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#main-content<span class="token punctuation">"</span></span> <span class="token attr-name">blocking</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>render<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span></code></pre><p><strong>注意：</strong> 过度使用 <code>blocking=&quot;render&quot;</code> 会让旧页面卡住太久，体验反而下降。要确保阻塞的资源能快速加载。</p><h2>四、精通：Level 2 的独门绝技，让转场更溜！</h2><p>Level 2 不仅仅是把 Level 1 搬到了跨文档，还带来了许多激动人心的新功能：</p><ol><li><p><strong>选择性视图转场 (Selective View Transitions):</strong></p><ul><li><p><strong>痛点：</strong> Level 1 里所有转场都一样，想根据不同交互（如导航 VS 卡片展开）应用不同动画比较麻烦。</p></li><li><p><strong>Level 2 方案：</strong> 引入 <strong><code>types</code></strong> 的概念。</p><ul><li><strong>设置类型：</strong><ul><li>通过 JS 在 <code>pageswap</code> / <code>pagereveal</code> 里 <code>event.viewTransition.types.add('your-type')</code>。</li><li>或者直接在 <code>@view-transition</code> 规则里声明：<pre class="language-css"><code class="language-css"><span class="token atrule"><span class="token rule">@view-transition</span></span> <span class="token punctuation">{</span>
  <span class="token property">navigation</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">types</span><span class="token punctuation">:</span> slide-nav card-expand<span class="token punctuation">;</span> <span class="token comment">/* 声明默认类型 */</span>
<span class="token punctuation">}</span></code></pre></li></ul></li><li><strong>匹配类型：</strong> 使用新的 CSS 伪类：<ul><li><code>:active-view-transition</code>: 匹配有<strong>任何</strong>转场活动时的 <code>&lt;html&gt;</code>。</li><li><code>:active-view-transition-type(type1, type2...)</code>: 匹配活动转场的 <code>types</code> <strong>包含</strong>括号里<strong>至少一个</strong>类型时的 <code>&lt;html&gt;</code>。</li></ul></li></ul></li><li><p><strong>示例：</strong></p><pre class="language-css"><code class="language-css"><span class="token comment">/* 默认淡入淡出 */</span>
<span class="token selector">::view-transition-old(root)</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> fade-out 0.3s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">::view-transition-new(root)</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> fade-in 0.3s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 如果是导航滑动类型 */</span>
<span class="token selector">:root:active-view-transition-type(slide-nav) ::view-transition-old(root)</span> <span class="token punctuation">{</span>
  <span class="token property">animation-name</span><span class="token punctuation">:</span> slide-left-out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">:root:active-view-transition-type(slide-nav) ::view-transition-new(root)</span> <span class="token punctuation">{</span>
  <span class="token property">animation-name</span><span class="token punctuation">:</span> slide-right-in<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></li><li><p><strong>好处：</strong> 可以用清晰的 CSS 规则，为不同类型的转场定义不同的动画，逻辑分离。</p></li></ul></li><li><p><strong>样式复用 (<code>view-transition-class</code>):</strong></p><ul><li><p><strong>痛点：</strong> 很多元素 <code>view-transition-name</code> 不同，但想用同一套动画，写一堆 <code>::view-transition-group(name1)</code>, <code>::view-transition-group(name2)</code>... 太累。</p></li><li><p><strong>Level 2 方案：</strong> <code>view-transition-class</code> CSS 属性 + 类选择器语法。</p><pre class="language-css"><code class="language-css"><span class="token comment">/* 给所有卡片加上 class */</span>
<span class="token selector">.card</span> <span class="token punctuation">{</span>
  <span class="token property">view-transition-class</span><span class="token punctuation">:</span> my-card<span class="token punctuation">;</span>
  <span class="token comment">/* name 还是需要的，比如用 auto */</span>
  <span class="token property">view-transition-name</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 用类选择器选中所有这些卡片的 group */</span>
<span class="token selector">::view-transition-group(*.my-card)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 注意这个 *.classname 语法 */</span>
  <span class="token property">animation-timing-function</span><span class="token punctuation">:</span> ease-in-out<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></li><li><p><strong>好处：</strong> DRY！极大简化了对共享动画行为的元素的样式定义。</p></li></ul></li><li><p><strong>自动 <code>view-transition-name</code>:</strong></p><ul><li><strong>痛点：</strong> 手动给列表项等大量元素起名字太烦。</li><li><strong>Level 2 方案：</strong> <code>view-transition-name: auto;</code><ul><li>有 <code>id</code> 就用 <code>id</code>。</li><li>没 <code>id</code> 浏览器内部生成唯一标识。</li></ul></li><li><strong>跨文档注意！！！</strong> <code>auto</code> 生成的、非 <code>id</code> 的名字，在<strong>新旧文档间不会匹配</strong>！这意味着它们总是触发进入/退出动画，而不是平滑过渡。想让元素在新旧页面平滑连接，还是要确保它们有<strong>相同且稳定</strong>的 <code>view-transition-name</code>（用 <code>id</code> 或手动指定相同 name）。</li></ul></li><li><p><strong>嵌套视图转场 (<code>view-transition-group</code> CSS 属性):</strong></p><ul><li><p><strong>痛点：</strong> Level 1 的扁平伪元素树无法处理父元素的 <code>clip-path</code>, <code>overflow: hidden</code>, <code>filter</code>, <code>opacity</code> 或复杂的 3D 变换，导致动画效果失真。</p></li><li><p><strong>Level 2 方案：</strong> <code>view-transition-group</code> CSS 属性，允许你指定一个父级 <code>view-transition-name</code> (或 <code>nearest</code>, <code>contain</code>)，从而构建嵌套的伪元素树。</p><pre class="language-css"><code class="language-css"><span class="token selector">.container</span> <span class="token punctuation">{</span>
  <span class="token property">view-transition-name</span><span class="token punctuation">:</span> container<span class="token punctuation">;</span>
  <span class="token property">clip-path</span><span class="token punctuation">:</span> <span class="token function">circle</span><span class="token punctuation">(</span>50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.content-inside</span> <span class="token punctuation">{</span>
  <span class="token property">view-transition-name</span><span class="token punctuation">:</span> content<span class="token punctuation">;</span>
  <span class="token comment">/* 让 content 的 group 成为 container group 的子元素 */</span>
  <span class="token property">view-transition-group</span><span class="token punctuation">:</span> container<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 现在可以给 container group 加 clip-path 动画 */</span>
<span class="token selector">::view-transition-group(container)</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> clip-reveal 0.5s<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></li><li><p><strong>好处：</strong> 动画能更好地反映 DOM 的层级和效果（如剪裁、滤镜），实现更复杂的视觉效果。</p></li></ul></li><li><p><strong>分层捕获 (Layered Capture - 底层改进):</strong></p><ul><li><strong>痛点：</strong> Level 1 的快照是扁平图片，<code>border</code>, <code>background-gradient</code>, <code>box-shadow</code>, <code>filter</code> 等效果无法独立动画，只能跟着图片一起变形或淡变，很生硬。</li><li><strong>Level 2 方案：</strong> 浏览器不再只拍一张扁平快照，而是捕获元素的多个 CSS 属性层（如背景、边框、阴影、滤镜、透明度、内边距等），并在动画时对这些<strong>属性本身</strong>进行插值。</li><li><strong>好处：</strong> 动画效果大大丰富！边框可以平滑变色变形，渐变背景可以流畅过渡，阴影和滤镜也能动起来，视觉表现力提升一个档次！这使得转场感觉更“原生”，而不是简单的图片切换。</li></ul></li></ol><h2>五、注意事项与未来展望</h2><ul><li><strong>安全：</strong> 依然严格限制同源，并处理了跨域重定向问题。</li><li><strong>兼容性：</strong> <strong>划重点！Level 2 目前 (2025-4-7) 仍是 W3C 工作草案 (Working Draft)</strong>，API 和行为可能变化，浏览器支持尚不完善或处于实验阶段。生产环境使用务必谨慎，关注 Can I use 和浏览器厂商动态。</li><li><strong>性能：</strong> 复杂的嵌套、大量的独立元素、消耗大的动画依然需要关注性能测试和优化。</li><li><strong>调试：</strong> 现代浏览器开发者工具正在逐步增强对 View Transitions（包括 Level 2 特性）的调试支持。</li></ul><h2>六、总结：MPA 的春天，体验的飞跃</h2><p>CSS View Transitions Module Level 2 是对 Level 1 的一次意义重大的扩展和增强。它不仅将丝滑的转场体验带给了更广泛的 MPA 网站，还通过 <code>types</code>、<code>view-transition-class</code>、<code>auto</code> name、<code>view-transition-group</code> 属性以及底层的分层捕获，极大地提升了转场的灵活性、开发效率和视觉表现力。</p><p>虽然还是草案，但它描绘的未来无疑是激动人心的。掌握了 View Transitions Level 1 和 Level 2，你就拥有了打造下一代 Web 流畅体验的利器。</p><p>希望这篇结合了 Level 1 回顾与 Level 2 深入的探索，能让你对 View Transitions 有一个更全面、更深入的认识。赶紧动手尝试（在支持的实验性浏览器中），感受这触手可及的未来吧！</p><p><strong>参考资料：</strong></p><ul><li><a href="https://www.w3.org/TR/css-view-transitions-1/">W3C CSS View Transitions Module Level 1 Spec</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API">MDN 文档: View Transitions API</a></li><li><a href="https://developer.chrome.com/docs/web-platform/view-transitions/cross-document">Cross-document view transitions for multi-page applications</a></li><li><a href="https://caniuse.com/cross-document-view-transitions"><code>caniuse View Transitions (cross-document)</code></a><ul><li>chrome 126+</li><li>safari 18.2+</li></ul></li></ul></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>