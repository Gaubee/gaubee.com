<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, article, Kotlin"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>MutableSharedFlow 随记</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
</head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="target" href="/articles/">Articles</a> <a class="" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="article-wrapper"><main><h1>MutableSharedFlow 随记</h1><p>MutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。 因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。 举个例子：</p><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> sharedFlow <span class="token operator">=</span> MutableSharedFlow<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
launch <span class="token punctuation">{</span>
    sharedFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token comment">// 这里通常不会有任何打印</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
sharedFlow<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。 这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。</p><hr><p>因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。</p><hr><p>最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。 但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。 这个方案唯一的好处就是代码量相对比较少。</p><hr><p>还有一种方案是使用 Channel：</p><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">val</span> sharedFlow <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">consumeAsFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">shareIn</span><span class="token punctuation">(</span><span class="token function">currentCoroutineContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SharingStarted<span class="token punctuation">.</span>Lazily<span class="token punctuation">)</span>
launch <span class="token punctuation">{</span>
    sharedFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token comment">// 这里通常不会有任何打印</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>这个方案其实是创建了一个 Channel，两个 Flow。 其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。 第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。</p><p>这个方案只能说勉勉强强达到我们的需求，但问题也很多：</p><ol><li>它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。</li><li>flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 <code>launch sharedFlow.collect</code> ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。<blockquote><p>这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:</p><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> MAX <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
launch <span class="token punctuation">{</span>
  <span class="token comment">/// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"start send"</span></span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span>MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"send(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">i</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">val</span> flow <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">receiveAsFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">shareIn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SharingStarted<span class="token punctuation">.</span>Lazily<span class="token punctuation">)</span>
launch <span class="token punctuation">{</span>
  flow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"collect1(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
launch <span class="token punctuation">{</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>
  flow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"collect2(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></blockquote></li><li>这里用 consumeAsFlow 还是 receiveAsFlow 都一样</li></ol><hr><p>但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手： 试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。 其实标准做法是这样的：</p><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> sharedFlow <span class="token operator">=</span> MutableSharedFlow<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onSubscription</span> <span class="token punctuation">{</span>
    sharedFlow<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
launch <span class="token punctuation">{</span>
    sharedFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token comment">// 这里通常不会有任何打印</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。</p><hr></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>