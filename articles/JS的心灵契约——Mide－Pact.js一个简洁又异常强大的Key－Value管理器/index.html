<!doctype html><html lang=zh-CN><meta charset=utf-8><title>JS的心灵契约——Mide-Pact.js一个简洁又异常强大的Key-Value管理器 · Gaubee</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/css/main.css rel=stylesheet><link href=/webmanifest.json rel=manifest><meta content=#ec407a name=theme-color><link href=/articles.atom rel=alternate title="Gaubee's Articles Atom feed" type=application/atom+xml><link href=/events.atom rel=alternate title="Gaubee's Events Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><header id=header><h1><a href=/ >Gaubee</a></h1><a href=#navigation-toggle id=nav-toggle>显示导航 Show navigation</a><nav><ul><li><a href=/ >主页 Home</a><li class=current><a href=/articles>文章 Articles</a><li><a href=/events>小事件 Events</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>JS的心灵契约——Mide-Pact.js一个简洁又异常强大的Key-Value管理器</h1><p class=meta>发布于 <time datetime=8/20/2016 itemprop=datePublished>8/20/2016</time> · 最后修改时间 <time datetime=10/29/2016 itemprop=dateModified>10/29/2016</time> · 标签： <a href=/blog/tags/javascript class=tag>javascript</a> <a href=/blog/tags/tools class=tag>tools</a></header><div itemprop=articleBody><h1 id=%E5%89%8D%E8%A8%80 tabindex=-1><a href=#%E5%89%8D%E8%A8%80 class=header-anchor>前言</a></h1><p><a href=https://gist.github.com/Gaubee/e32b0001413d641b224c1f9c9d359161>mind-pact.js</a><br>这个东西，以前做过，但是做得不够好，而且是整合在以前开发的MVVM框架里头，作为Model层。<br>这两天整理了一下，凝练了核心的思想。<p>这个库，是一个key-value管理器。简单的说就是：<pre class=language-js><code class=language-js>model<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"a.b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>model<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{ b:1 }</span></code></pre><p><strong>最重要的特性：支持表达式</strong>：<pre class=language-js><code class=language-js>model<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a['b']"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span></code></pre><p>但我们知道JS的表达式里头是可以支持函数的定义等等的，这里做了一定的限制，但又不会失去灵活性，具体看如下API描述：<h1 id=api-%E6%96%87%E6%A1%A3 tabindex=-1><a href=#api-%E6%96%87%E6%A1%A3 class=header-anchor>API 文档</a></h1><h2 id=mp(basedata) tabindex=-1><a href=#mp(basedata) class=header-anchor>MP(basedata)</a></h2><ul><li><strong>basedata</strong> (<em>except Primitive values</em>) : 除了<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Primitive_values>Primitive values</a> 以外的任意对象</ul><h2 id=mp.prototype.set(paths%2C-value%2C-context) tabindex=-1><a href=#mp.prototype.set(paths%2C-value%2C-context) class=header-anchor>MP.prototype.set(paths, value, context)</a></h2><ul><li><strong>paths</strong> (<em>string</em>) : <s>懒得描述</s><li><strong>value</strong> (<em>any</em>) : <s>懒得描述</s><li><strong>context</strong> (<em>object | null</em>) : 表达式的上下文对象，具体怎么用后面描述</ul><h2 id=mp.prototype.get(paths%2C-context) tabindex=-1><a href=#mp.prototype.get(paths%2C-context) class=header-anchor>MP.prototype.get(paths, context)</a></h2><ul><li><strong>paths</strong> (<em>string</em>) : <s>懒得描述</s><li><strong>context</strong> (<em>object | null</em>) : 表达式的上下文对象，具体怎么用后面描述</ul><p>这里说一下这个<strong>context</strong>对象的作用把。就是前面说到的“JS的表达式里头是可以支持函数的定义等等的，这里做了一定的限制，但又不会失去灵活性”的一个解决方案，比如说：<pre class=language-js><code class=language-js><span class="token comment">// 原始表达式</span><br>a<span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>b<span class="token punctuation">;</span><br><span class="token comment">// 提取出function部分后变成：</span><br>a<span class="token operator">+</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>b<br><span class="token comment">//context就是提取出来的对象：</span><br>context <span class="token operator">=</span> <span class="token punctuation">{</span><br>  <span class="token function function-variable">foo</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>如何深入去用我就不多说了<h2 id=mp.customtype(getter-%5B%2C-setter%5D) tabindex=-1><a href=#mp.customtype(getter-%5B%2C-setter%5D) class=header-anchor>MP.CustomType(getter [, setter])</a></h2><blockquote><p>自定义数据类型</blockquote><ul><li><strong>getter</strong> (<em>string| [string,any] | function($cur_key, $pre_path_str, $full_path_str)</em>) : 支持三种格式：字符串表达式、字符串表达式+上下文，函数<li><strong>setter</strong> (<em>string| [string,any] | function($cur_key, $new_value, $pre_path_str, $full_path_str)</em>) : <em>此参数可空</em></ul><p>自定义数据类型，为什么不直接使用JS内置的Getter、Setter呢？这个自定义类型的优势如下：<ol><li>支持字符串，而且是<strong>鸭子类型</strong>的数据，这就意味着可以序列化，使用JSON来传递这个动态数据的Getter、Setter。<li>更为丰富的上下文信息，JS原始的setter、getter是只能知道自己的this对象，而CustomType在运行getter、setter可以知道自己所在的调用时的具体路径</ol><p>值得注意的是这里的表达式会比<code>MP.prototype.get/set</code>中的表达式更为强大，因为内置了一些关键字。这里统一讲一下关键字：<table><thead><tr><th style=text-align:center>关键字<th style=text-align:center>支持get/set<th style=text-align:center>支持CustomType的getter/setter<th style=text-align:center>描述<th style=text-align:center>备注<tbody><tr><td style=text-align:center>__vm<td style=text-align:center>√/√<td style=text-align:center>√/√<td style=text-align:center>model实例对象本身<td style=text-align:center><tr><td style=text-align:center>__context<td style=text-align:center>√/√<td style=text-align:center>√/√<td style=text-align:center>上下文对象<td style=text-align:center><tr><td style=text-align:center>__global<td style=text-align:center>√/√<td style=text-align:center>√/√<td style=text-align:center>全局对象<td style=text-align:center>浏览器环境中指向window<tr><td style=text-align:center>$cur_key<td style=text-align:center>×/×<td style=text-align:center>√/√<td style=text-align:center>当前对象所在this中的key<td style=text-align:center>a.b.c = CustomType( * , * )，这里指向的就是"c"<tr><td style=text-align:center>$pre_path_str<td style=text-align:center>×/×<td style=text-align:center>√/√<td style=text-align:center><em>看备注</em><td style=text-align:center>上述条件，这里指向"a.b"<tr><td style=text-align:center>$full_path_str<td style=text-align:center>×/×<td style=text-align:center>√/√<td style=text-align:center><em>看备注</em><td style=text-align:center>上述条件，这里指向"a.b.c"<tr><td style=text-align:center>$cur_value<td style=text-align:center>×/×<td style=text-align:center>√/×<td style=text-align:center>当前缓存值<td style=text-align:center>初始化是null，每运行一次getter都会被更新<tr><td style=text-align:center>$new_value<td style=text-align:center>×/×<td style=text-align:center>×/√<td style=text-align:center>setter所要赋予的值<td style=text-align:center><tr><td style=text-align:center>$old_value<td style=text-align:center>×/×<td style=text-align:center>×/√<td style=text-align:center>当前缓存值<td style=text-align:center>同$cur_value，只是这里只能在setter中使用</table><p>所以围绕这些关键字，来实现一个基础的CustomType对象，就是<code>fullName=firstName lastName</code>。<br>实现代码如下：<br><strong>版本1</strong><blockquote><p>这个是单纯的getter，简单直观，但是问题在于"me."这个写死在表达式中了，就意味着如果这个数据发生迁移或者复制到其它地方，就会运行出现问题。</blockquote><pre class=language-js><code class=language-js>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"me"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>    firstname<span class="token operator">:</span> <span class="token string">"Gaubee"</span><span class="token punctuation">,</span><br>    lastname<span class="token operator">:</span> <span class="token string">"Bangeel"</span><span class="token punctuation">,</span><br>    fullname<span class="token operator">:</span> <span class="token function">CustomType</span><span class="token punctuation">(</span><span class="token string">"me.firstname+' '+me.lastname"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>版本2</strong><blockquote><p>这里用到了<code>__vm</code>与<code>$pre_path_str</code>两个关键字，其中<code>$pre_path_str</code>用来替代版本1中的"me."，然后由于使用了<code>$pre_path_str</code>关键字，解析就不会用<code>__vm.get(*)</code>自动包裹这个关键字，所以需要手动添加这段代码，结果如下：</blockquote><pre class=language-js><code class=language-js>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"me"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>    firstname<span class="token operator">:</span> <span class="token string">"Gaubee"</span><span class="token punctuation">,</span><br>    lastname<span class="token operator">:</span> <span class="token string">"Bangeel"</span><span class="token punctuation">,</span><br>    fullname<span class="token operator">:</span> <span class="token function">CustomType</span><span class="token punctuation">(</span><span class="token string">"__vm.get($pre_path_str+'.firstname')+' '+__vm.get($pre_path_str+'.lastname')"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>版本3</strong><blockquote><p>这里实现了Setter，要值得注意的是，setter的表达式里头，多个语句的分割是<code>,</code>而不是<code>;</code>，因为这个单个表达式，简而言之就是解析是把表达式处理成<code>return *</code>，所以如果使用<code>;</code>就会导致<code>;</code>后面的语句不运行（PS：<strong>不要利用这点来实现局部变量的定义，虽然var声明会自动前置，但是请使用context来声明局部变量，否则如果变量名不在context中，会被直接包裹成<code>__vm.get(key)</code>进行处理</strong>）。另外值得注意的是这里表达式最后返回是<code>null</code>，如果返回<code>null/undefined/false</code>，那么就意味着$new_value最后是存储到默认的缓存中；如果返回的不是空值，那么就会被当成是路径，直接将$new_value赋值到这个路径所指定的对象中。</blockquote><pre class=language-js><code class=language-js>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"me"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><br>    firstname<span class="token operator">:</span> <span class="token string">"Gaubee"</span><span class="token punctuation">,</span><br>    lastname<span class="token operator">:</span> <span class="token string">"Bangeel"</span><span class="token punctuation">,</span><br>    fullname<span class="token operator">:</span> <span class="token function">CustomType</span><span class="token punctuation">(</span><span class="token string">"__vm.get($pre_path_str+'.firstname')+' '+__vm.get($pre_path_str+'.lastname')"</span><span class="token punctuation">,</span><br>        <span class="token string">"($new_value=$new_value.split(' ')),\<br>        __vm.set($pre_path_str+'.firstname',$new_value[0]),\<br>        __vm.set($pre_path_str+'.lastname',$new_value[1]),\<br>        null"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1 id=%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82 tabindex=-1><a href=#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82 class=header-anchor>技术实现细节</a></h1><blockquote><p>这部分是讲到一些效率优化、解析处理等实现细节。</blockquote><h2 id=1 tabindex=-1><a href=#1 class=header-anchor>1</a></h2><p>因为不是以往的<code>a.b.c</code>这样耿直的用<code>.</code>来分割了，而MP涉及到表达式，即便用了缓存，如果遇到数组<code>a.1</code>~<code>a.1000</code>，那么缓存还有用么？<br>这个是在开始做的时候一个难点，最后实现确实我用了缓存，但是不是耿直用。这里缓存的不是<code>路径:函数</code>，而是<code>模式:函数</code>。基于模式的缓存，比如说<code>a.1</code>与<code>a.1000</code>，这两者的模式是一样的，所以只用了同一个模式工厂函数，而后将<code>a.1/1000</code>传入模式工厂函数中，返回一个带着闭包的函数。怎么解释看下面这个实例：<pre class=language-js><code class=language-js><span class="token constant">MP</span><span class="token punctuation">.</span><span class="token function">formatKey</span><span class="token punctuation">(</span><span class="token string">"a.b[A.B+C-D(E,F)].c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">/*[ 'a', 'b', <br>function(__vm) {<br>    return PLA(matchs[0], __vm, __context) +<br>        PLA(matchs[1], __vm, __context) -<br>        PLA(matchs[2], __vm, __context)(<br>            PLA(matchs[3], __vm, __context),<br>            PLA(matchs[4], __vm, __context)<br>        )<br>}<br>, 'c']<br>这里返回的数组中的第三个对象，就是模式工厂返回的函数，其中matchs、__context都是处于闭包中，<br>所以同样模式的表达式（`@+@-@(@,@)`）可以公用这个模式工厂。<br>*/</span></code></pre><p>因为我认为在一个WebApp中，取值路径可能有上万个，但是模式不过那么几种——应用里头的字符串就那些。所以基于模式的匹配是很靠谱的一种解决方案，即便有动态的模式，使用context也能化繁为简，充分利用模式缓存。<h2 id=2 tabindex=-1><a href=#2 class=header-anchor>2</a></h2><p>另外，看上面那个formatKey返回的数组数据，可以发现其实<code>[ * ]</code>包裹起来的部分其实是会被解析成函数的，所以<code>[ * ]</code>内外是有性能区别的，也因此，能在外部写<code>a.1</code>这种违反JS语法的写法，正常JS写法是<code>a[1]</code>，而为了性能，我建议是使用<code>a.1</code>。上面说到模式，这里说道表达式，就不得不说一下解析：<br>这里是提取<code>x.x.x</code>作为<strong>路径单元</strong>，<code>[ * ]</code>作为<strong>模式单元</strong>，所以上述例子里头<code>[A.B+C-D(E,F)]</code>开头的<code>A.B</code>是被会识别成<strong>路径单元</strong>，最后模式才<strong>不是</strong>：<code>@.@+@-@(@,@)</code><h2 id=3 tabindex=-1><a href=#3 class=header-anchor>3</a></h2><p>动态的赋值。如果一个路径是<code>a.b.c.d</code>，而<code>a</code>属性本身就是空的话，那么在<code>model.set('a.b.c.d',value)</code>的过程中，会动态创建值给<code>a b c d</code>，如果路径某一部分的key是整数，那么动态创建的就会是数组：<pre class=language-js><code class=language-js>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"A.B.1.C"</span><span class="token punctuation">,</span><span class="token string">"ccc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">//{ B: [ , { C: 'ccc' } ] }</span></code></pre><hr><p>【<strong>8/21 6:08</strong>】 目前功能有限，但代码就不到400行，接下来会加入动态监听功能，有了这个MP才完整。</div><footer></footer></article></main><footer id=footer><div><nav><a href=https://twitter.com/gaubeebangeel rel="me nofollow" target=_blank>Twitter</a> · <a href=https://github.com/gaubee/gaubee.com/tree/main/./src/articles/JS的心灵契约——Mide－Pact.js一个简洁又异常强大的Key－Value管理器.md rel=nofollow target=_blank>Edit this page on GitHub</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>除非有特别的说明, 该站点所有直接内容都使用许可证：<a href=https://creativecommons.org/licenses/by/4.0/deed.zh>署名 4.0 国际 (CC BY 4.0)</a></small><blockquote><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用</small></blockquote></footer><script src=/js/dark-mode-toggle.mjs type=module></script><script src=/js/time-elements.mjs type=module></script><script src=/js/main.mjs type=module></script>