<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, article"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>Observable vs Signals：响应式江湖的两大流派深度对决</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
</head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="target" href="/articles/">Articles</a> <a class="" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="article-wrapper"><main><h1>Observable vs Signals：响应式江湖的两大流派深度对决</h1><p>在探讨了 Observable 和 Signals 各自的理念与实现后，你可能会有些疑问：这两个家伙，都号称搞定“响应式”，它们到底有啥不一样？我该用哪个？</p><p>别急，这一篇，咱就来掰扯掰扯 Observable 和 Signals 这对“响应式双雄”，通过对比，帮你建立更直观的认知。</p><h2>一、核心哲学：动态数组 vs 动态函数</h2><p>要快速抓住两者的神髓，不妨来看一个有点“玄学”但颇为形象的比喻：</p><blockquote><p>Observable ≈ 动态数组 (Array + 时间) Signals ≈ 动态函数 (Function + 动态参数)</p></blockquote><p>这话怎么理解呢？</p><p><strong>Observable：时间轴上的珍珠项链</strong></p><p>想象一个数组 <code>Array</code>，它是一系列<strong>静态</strong>的值的集合。现在，给这个数组加上<strong>时间</strong>维度——这些值不是同时存在的，而是随着时间推移，一个接一个地“推送”给你。这就构成了 Observable 的核心意象：一个<strong>随时间发生的事件序列（Stream）</strong>。</p><p>Observable 关注的是<strong>整个序列的处理</strong>。你像处理数组一样，可以对这个事件流进行 <code>map</code>（转换每个事件）、<code>filter</code>（过滤掉某些事件）、<code>reduce</code>（聚合整个流的结果）、<code>take</code>（只取前几个）、<code>debounce</code>（防抖动）等等操作。它的核心在于<strong>处理流经的数据</strong>，以及这些数据在时间维度上的<strong>模式和关系</strong>。你订阅一个 Observable，就像是在说：“嘿，这条项链上的每一颗珍珠（事件）来了，都告诉我一声，我好对它（们）做点什么。”</p><p><strong>Signals：自动响应变化的计算单元</strong></p><p>再来看函数 <code>Function</code>。一个纯函数，给定相同的输入，总是返回相同的输出。它描述了一种<strong>计算关系</strong>。现在，让这个函数的“输入参数”变成<strong>动态的、可变的</strong>，并且当这些输入参数（也就是依赖的状态）变化时，函数的“输出”（计算结果）也能<strong>自动、高效地更新</strong>。这就是 Signals 的核心意象：一个<strong>响应依赖变化的计算单元</strong>。</p><p>Signals 关注的是<strong>状态以及状态之间的依赖关系</strong>，并确保当读取一个 Signal 时，总是能得到基于当前<strong>最新且一致</strong>的依赖状态计算出的值。它内部维护着一张“依赖图”，像蜘蛛网一样，当源头状态（<code>Signal.State</code>）变化时，它会精确地通知可能受影响的计算节点（<code>Signal.Computed</code>），但计算本身是<strong>惰性</strong>的。你读取一个 Signal，就像是在问：“喂，根据你现在所依赖的那些最新值，你当前的结果是啥？”</p><p><strong>简单总结一下核心区别：</strong></p><ul><li><p><strong>Observable</strong>：<strong>它是对某一种数据的线性的过滤、处理、转化</strong></p></li><li><p><strong>Signals</strong>：<strong>它是对某一种数据的线性的过滤、处理、转化</strong></p></li><li><p><strong>Observable</strong>: <strong>它是对某一种数据的持续的线性的过滤、处理、转化</strong>。</p><blockquote><p>处理<strong>异步事件流</strong>，关注<strong>序列</strong>、<strong>时间</strong>和<strong>流转换</strong>。它是**推（Push）**模型的延伸（事件源主动推送）。</p></blockquote></li><li><p><strong>Signals</strong>: <strong>它是对多个数据进行交织</strong>。</p><blockquote><p>管理<strong>响应式状态</strong>，关注<strong>依赖关系</strong>、<strong>自动更新</strong>和<strong>一致性</strong>。它是**拉（Pull）**模型的优化（读取时才计算），但也包含推送通知（<code>Watcher</code>）。</p></blockquote></li></ul><h2>二、互相“扮演”：边界与不可替代性</h2><p>虽然哲学不同，但在某些场景下，它们似乎可以互相模拟对方的功能。这种模拟尝试，恰恰能帮助我们看清各自的“舒适区”和“短板”。</p><p><strong>场景 1：用 Signals 模拟 Observable (处理事件流)</strong></p><p>Observable 的经典场景是处理 DOM 事件流，比如监听按钮点击。我们尝试用 Signals 来模拟：</p><pre class="language-ts"><code class="language-ts"><span class="token comment">// --- 使用 Observable ---</span>
<span class="token comment">// import { Observable } from 'rxjs'; // 或原生 Observable (如果支持)</span>
<span class="token comment">// import { fromEvent, map, filter } from 'rxjs/operators'; // RxJS operators</span>

<span class="token comment">// const clicks$ = fromEvent(buttonElement, 'click').pipe(</span>
<span class="token comment">//   map(event => ({ x: event.clientX, y: event.clientY })),</span>
<span class="token comment">//   filter(coords => coords.x > 100)</span>
<span class="token comment">// );</span>
<span class="token comment">// clicks$.subscribe(coords => console.log('Observable Click (x > 100):', coords));</span>

<span class="token comment">// --- 尝试用 Signals 模拟 ---</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Signal <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"signal-polyfill"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> effect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"signal-utils/subtle/microtask-effect"</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> latestClickEvent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Signal</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">State</span><span class="token generic class-name"><span class="token operator">&lt;</span>MouseEvent <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 1. 手动将事件源连接到 Signal State</span>
buttonElement<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// Signals 通常关心“状态”，所以我们只记录“最新”的事件状态</span>
  latestClickEvent<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 使用 effect 响应状态变化</span>
<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> event <span class="token operator">=</span> latestClickEvent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取 Signal，建立依赖</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 初始状态或清除状态时忽略</span>

  <span class="token comment">// 在 effect 内部处理事件</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Signals Effect triggered by click state change"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> coords <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> event<span class="token punctuation">.</span>clientX<span class="token punctuation">,</span> y<span class="token operator">:</span> event<span class="token punctuation">.</span>clientY <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 模拟 filter</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>coords<span class="token punctuation">.</span>x <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Signals Handling Click (x > 100):"</span><span class="token punctuation">,</span> coords<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 在这里执行基于事件的逻辑...</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 注意：这个 effect 会在每次点击时触发（因为 event 对象总是新的）</span>
  <span class="token comment">// 如果想模拟 Observable 的 filter 效果（只在满足条件时触发后续逻辑），</span>
  <span class="token comment">// 可能需要更复杂的 Signals 组合或在 effect 内部判断。</span>

  <span class="token comment">// 问题：如果需要在事件处理后“消费”掉它（避免重复处理），可能需要手动 set(null)？</span>
  <span class="token comment">// latestClickEvent.set(null); // ? 这又引入了手动状态管理</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>推导与思考:</strong></p><ul><li><strong>可以模拟，但“内味儿”不对</strong>: Signals 确实可以通过 <code>State</code> + <code>effect</code> 来响应事件的发生。但这种模式更像是“状态变更驱动的副作用”，而不是“流处理”。</li><li><strong>丢失序列信息</strong>: <code>Signal.State</code> 通常只关心当前（或最新）的状态。它天然不适合保存和处理事件的<strong>历史序列</strong>。如果你想实现 <code>bufferCount</code> (缓冲 N 个事件) 或 <code>pairwise</code> (前后两个事件配对) 这类需要访问历史事件的操作，用 Signals 会非常别扭，需要手动维护额外的状态来存储历史。</li><li><strong>流转换能力缺失</strong>: Observable 强大的操作符（<code>map</code>, <code>filter</code>, <code>debounceTime</code>, <code>throttleTime</code>, <code>switchMap</code> 等）是其核心优势，专门用于处理和转换事件流。用 Signals 模拟这些操作通常需要编写更多的命令式逻辑或组合多个 <code>Computed</code> Signals，远不如 Observable 操作符简洁直观。</li><li><strong>核心差异凸显</strong>: 这再次印证了 Observable <strong>为处理事件序列而生</strong>。它提供了丰富的工具来操纵、组合和响应随时间发生的离散事件流。而 Signals 则更关注<strong>状态快照及其依赖</strong>。</li></ul><p><strong>场景 2：用 Observable 模拟 Signals (处理派生状态)</strong></p><p>Signals 的核心优势在于管理派生状态，如 <code>fullName = computed(() =&gt; firstName + lastName)</code>。我们尝试用 Observable 来模拟：</p><pre class="language-ts"><code class="language-ts"><span class="token comment">// --- 使用 Signals ---</span>
<span class="token comment">// import { Signal } from "signal-polyfill";</span>
<span class="token comment">// const firstName = new Signal.State("Zhang");</span>
<span class="token comment">// const lastName = new Signal.State("San");</span>
<span class="token comment">// const fullName = new Signal.Computed(() => `${firstName.get()} ${lastName.get()}`);</span>
<span class="token comment">// console.log(fullName.get()); // "Zhang San"</span>
<span class="token comment">// lastName.set("Si");</span>
<span class="token comment">// console.log(fullName.get()); // "Zhang Si" (自动、懒惰、缓存)</span>

<span class="token comment">// --- 尝试用 Observable 模拟 ---</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
  BehaviorSubject<span class="token punctuation">,</span>
  combineLatest<span class="token punctuation">,</span>
  map<span class="token punctuation">,</span>
  distinctUntilChanged<span class="token punctuation">,</span>
  tap<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"rxjs"</span><span class="token punctuation">;</span>

<span class="token comment">// 1. 用 BehaviorSubject (或类似) 模拟 State Signal (需要初始值，并能记住最新值)</span>
<span class="token keyword">const</span> firstName$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BehaviorSubject</span><span class="token punctuation">(</span><span class="token string">"Zhang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> lastName$ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BehaviorSubject</span><span class="token punctuation">(</span><span class="token string">"San"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 模拟 Computed Signal</span>
<span class="token keyword">const</span> fullName$ <span class="token operator">=</span> <span class="token function">combineLatest</span><span class="token punctuation">(</span><span class="token punctuation">[</span>firstName$<span class="token punctuation">,</span> lastName$<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
  <span class="token comment">// 2. combineLatest 合并依赖源的最新值</span>
  <span class="token function">tap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>f<span class="token punctuation">,</span> l<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Observable: combining </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>f<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>l<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 观察组合时机</span>
  <span class="token comment">// 3. map 执行计算</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Observable: Computing fullName..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 观察计算时机</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// 4. distinctUntilChanged 实现缓存/记忆化 (只在值变化时发出)</span>
  <span class="token function">distinctUntilChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 模拟读取 (需要订阅来获取值)</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Subscribing to fullName$..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fullName$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Observable fullName:"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// BehaviorSubject 会立即发出初始值触发计算和订阅回调</span>
<span class="token comment">// 输出: Observable: combining Zhang and San \n Observable: Computing fullName... \n Subscribing to fullName$... \n Observable fullName: Zhang San</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"\nUpdating lastName$..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lastName$<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">"Si"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 发出新值</span>
<span class="token comment">// 输出: Observable: combining Zhang and Si \n Observable: Computing fullName... \n Observable fullName: Zhang Si</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"\nUpdating firstName$..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
firstName$<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">"Li"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 发出新值</span>
<span class="token comment">// 输出: Observable: combining Li and Si \n Observable: Computing fullName... \n Observable fullName: Li Si</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"\nUpdating lastName$ to Si again (no change)..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lastName$<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">"Si"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 值未变</span>
<span class="token comment">// 输出: Observable: combining Li and Si \n Observable: Computing fullName... (但 distinctUntilChanged 阻止了下游的 subscribe 回调)</span></code></pre><p><strong>推导与思考:</strong></p><ul><li><strong>可以模拟，但更“重”</strong>: Observable 通过 <code>BehaviorSubject</code> (或其他能存储最新值的 Subject)、<code>combineLatest</code>、<code>map</code> 和 <code>distinctUntilChanged</code> 的组合，可以模拟出 <code>Computed</code> Signal 的效果。</li><li><strong>手动依赖与组合</strong>: 你需要<strong>手动</strong>选择合适的组合操作符（如 <code>combineLatest</code>）来声明依赖关系，这不像 Signals 那样在计算函数中读取时<strong>自动</strong>完成。</li><li><strong>惰性与缓存需显式处理</strong>: Observable 流默认是“热”的（一旦有源发出就可能触发计算和推送），你需要 <code>distinctUntilChanged</code> 来模拟 Signals 的缓存/记忆化行为。实现 Signals 那种精细化的、只有在被读取时才计算的<strong>完全惰性</strong>可能需要更复杂的 Observable 组合（如使用 <code>defer</code> 或自定义操作符）。</li><li><strong>核心差异凸显</strong>: 这再次印证了 Signals <strong>为管理状态依赖和派生计算而生</strong>。它的自动依赖追踪、内置的惰性求值和精细化缓存机制，使其在处理这类问题时更自然、更高效、更符合直觉。而 Observable 则需要更多的“手动挡”操作来达到类似效果。</li></ul><p><strong>结论：可以互扮，但气质不同，各有专长。</strong> 你可以用锤子拧螺丝，也可以用扳手敲钉子，但效果和效率显然不如用合适的工具。</p><h2>三、背压之辩：推拉之间的流量控制</h2><p>背压（Backpressure）是指在数据流系统中，当生产者产生数据的速率超过消费者处理数据的速率时，需要有一种机制来协调两者，防止数据丢失或资源耗尽（如内存溢出）。</p><p><strong>Observable 与背压</strong></p><ul><li><strong>RxJS 中的背压</strong>: 成熟的响应式库如 RxJS 提供了丰富的背压处理策略。操作符可以指定如何处理过载的数据，例如：<ul><li><code>buffer</code>: 缓存数据，等待消费者处理。</li><li><code>throttleTime</code> / <code>debounceTime</code>: 在时间维度上减少事件频率。</li><li><code>sample</code>: 定期采样最新值。</li><li><code>auditTime</code>: 在静默期后发出最新值。</li><li><code>window</code>: 将数据流分片成窗口。</li><li>...还有更高级的基于消费者请求量的协议。</li></ul></li><li><strong>Observable 提案的现状</strong>: <strong>目前（截至本文写作时），Observable 提案本身并没有明确包含背压处理机制或相关操作符。</strong> 这是一个重要的<strong>兼容性考量点</strong>，意味着原生 Observable 可能无法直接提供（准确来说应该是不愿意提供） RxJS 中强大的背压控制能力。</li><li><strong>Implications</strong>: 如果原生 Observable 不处理背压，当遇到高速事件源（比如快速的鼠标移动、高频的 WebSocket 消息）而消费者处理较慢时，可能会导致事件在内部（或由操作符）无限制地累积，增加内存压力，甚至丢失事件（取决于具体实现和操作符行为）。开发者可能需要自己通过组合 <code>takeUntil</code>、<code>filter</code> 等基础操作符，或者依赖<strong>尚未标准化的高级操作符</strong>（如果未来通过垫片实现），或在 <code>subscribe</code> 的 <code>next</code> 回调中实现节流/缓冲逻辑来手动管理。这无疑增加了复杂性，也是相比 RxJS 的一个潜在弱点。</li></ul><p><strong>Signals 与背压</strong></p><ul><li><strong>天然规避传统背压</strong>: Signals 的核心是<strong>状态快照</strong>和<strong>拉取式（Pull-based）惰性计算</strong>。当一个 <code>State</code> Signal 被高频 <code>set</code> 时，如果没有 <code>Computed</code> 或 <code>Watcher</code> 在中间读取它，这些中间状态实际上就被<strong>隐式地丢弃</strong>了。系统只关心在下一次被读取时，提供基于 <em>最新</em> 依赖状态的 <em>最终</em> 结果。</li><li><strong>单一策略：丢弃中间值</strong>: 这种机制可以看作是一种<strong>天然的、单一的背压策略——丢弃（Drop）/只取最新（Latest）</strong>。它不会累积历史值，因此不会有传统流处理中的内存爆炸问题。</li><li><strong>优势与局限</strong>: 这种简单性是 Signals 高效和易于理解的原因之一。但它也意味着 Signals <strong>本身不提供其他背压策略的选择</strong>。如果你需要缓冲所有事件、或保证每个事件都至少被处理一次，Signals 的核心模型并不直接支持，你可能需要结合其他机制（如队列、或在 effect 中实现缓冲逻辑）来完成。</li></ul><p><strong>总结</strong>:</p><ul><li>Observable（特指提案）在背压处理上目前留有空白，这是相比成熟库（如 RxJS）的显著差距，需要关注未来发展或依赖用户端策略。</li><li>Signals 通过其“状态快照”和“惰性拉取”模型，天然地以“丢弃中间值”的方式规避了传统背压问题，简单高效，但也失去了策略选择的灵活性。</li></ul><p>两者在处理生产者-消费者速率不匹配问题上，体现了其核心哲学的不同影响。</p><h2>四、殊途同归？总结与思考</h2><p>Observable 和 Signals，这对响应式编程领域的“双子星”，虽然都旨在解决状态与变化的难题，但它们的出发点、核心机制和最佳应用场景存在显著差异。</p><ol><li><p><strong>指令集类比：复杂(Observable) vs 精简(Signals)</strong></p><ul><li><strong>Observable</strong>: 更像是<strong>复杂指令集（CISC）</strong>。它提供了强大的、专门化的流处理操作符（尤其是在 RxJS 中），允许你对事件序列进行复杂的时间维度操作、转换和组合。但目前的提案相较于 RxJS 是“精简”的，许多高级操作符（如 <code>debounce</code>, <code>throttle</code>）并未包含。这些缺失的操作符能否通过现有基础操作符组合“垫片”实现？理论上部分可以，但可能会很复杂，且性能和行为可能与原生实现有差异。原生 Observable 的潜力很大程度上取决于未来操作符集的丰富程度。</li><li><strong>Signals</strong>: 更像是<strong>精简指令集（RISC）</strong>。它提供了极简的核心原语（<code>State</code>, <code>Computed</code>, <code>Watcher</code>)，专注于高效、自动化的状态依赖管理和计算缓存。它简单、正交、易于理解和组合。</li></ul></li><li><p><strong>生态与心智模型</strong></p><ul><li><strong>Observable</strong>: 天然契合<strong>异步流</strong>的心智模型。当你需要处理一系列随时间发生的、离散的、可能需要复杂时间逻辑（节流、防抖、窗口、合并等）的事件时，Observable 是非常自然的抽象。但它的学习曲线（尤其是 RxJS 的众多操作符）相对陡峭。</li><li><strong>Signals</strong>: 更倾向于<strong>函数式编程</strong>和<strong>声明式状态管理</strong>。它鼓励你将 UI 或系统状态看作是基础状态经过一系列纯函数计算派生出来的结果。这种模型易于推理，与许多现代 UI 框架（尤其受函数式影响的）的理念非常契合，可能更容易围绕其构建社区和工具库。</li></ul></li><li><p><strong>应对复杂异步流</strong></p><ul><li><strong>Observable</strong>: 处理复杂的异步序列（如拖拽操作、自动完成建议、多阶段动画）是其强项。操作符提供了强大的“武器库”来编排这些流程。</li><li><strong>Signals</strong>: 处理简单副作用（如 <code>effect(() =&gt; console.log(user.get()))</code>）非常优雅。但当涉及到需要管理<strong>异步过程本身的状态</strong>（如请求的加载/错误状态、节流/防抖的定时器状态）时，Signals 需要将这些过程状态也建模为 Signals，并通过 <code>Computed</code> 或 <code>effect</code> 来编排它们之间的依赖和转换。这可能会导致状态管理的负担增加，代码显得比用 Observable 操作符更繁琐。虽然社区可以通过库来封装这些模式（比如创建一个 <code>createThrottledSignal</code>），但 Signals 的核心机制并非为直接处理复杂异步时间逻辑而优化。比方说上文提到的 <code>debounce</code>需求，使用 <code>Signal.State&lt;Event|null&gt;</code> 的“消费”模式可以巧妙地处理某些场景（如按钮禁用），自洽且避免直接实现 <code>debounce</code> 的复杂性，但这体现了 Signals 处理问题的不同角度——<strong>状态驱动</strong>而非<strong>流处理</strong>。</li></ul></li><li><p><strong>互补而非替代</strong> 看到这里，你也应该有了自己的答案，Observable 和 Signals 它们可以协同工作。例如，一个 Observable 可以作为数据源，将其最新的值 <code>set</code> 到一个 <code>Signal.State</code> 中，然后利用 Signals 的派生计算和自动更新能力。反之，一个 Signal 的变化也可以触发一个 Observable 的启动或发出值。</p></li></ol><p><strong>最终结论</strong>:</p><p>Observable 和 Signals 是解决响应式问题的两种不同路径，各有侧重，各有优劣。</p><ul><li><strong>Observable 是处理异步事件流的大师</strong>，强于序列处理、时间控制和复杂的流转换，但目前提案内容有限，且背压处理不明。</li><li><strong>Signals 是精细化状态管理的专家</strong>，强于依赖追踪、惰性计算、自动缓存和确保一致性，模型简单直观，但处理复杂异步时序逻辑相对笨拙。</li></ul><p>理解它们的<strong>核心哲学差异</strong>——“动态数组” vs “动态函数”——是做出正确技术选型的关键。未来，我们或许会看到一个两者共存、甚至通过标准接口来进行互相转换！比如说:</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> state1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Signal</span><span class="token punctuation">.</span><span class="token function">State</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> state2 <span class="token operator">=</span> state1
  <span class="token punctuation">.</span><span class="token function">toObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> v <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">toState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 大胆点，进一步简化：</span>
<span class="token keyword">const</span> state1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Signal</span><span class="token punctuation">.</span><span class="token function">ObservableState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> state2 <span class="token operator">=</span> state1<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> v <span class="token operator">></span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>到时候也就没什么好纠结了，喜欢哪个就用哪个 😂😂</p></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>