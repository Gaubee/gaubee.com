<!DOCTYPE html><html lang="zh-CN"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="/icon-192x192.png"><meta name="generator" content="Astro v5.13.9"><title>CSS 锚定定位(Anchor Positioning)</title><meta name="description" content="Gaubee's personal blog"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.B3vRBseb.js"></script><style>astro-island:has(.md-renderer)~.fallback-content{display:none}
</style>
<link rel="stylesheet" href="/_astro/editor.DuBCv8QM.css">
<link rel="stylesheet" href="/_astro/MarkdownRenderer.COXD5gRV.css"></head> <body class="bg-white text-zinc-900 transition-colors duration-300 dark:bg-zinc-900 dark:text-zinc-50">  <div class="flex max-w-7xl mx-auto"> <aside class="hidden lg:block sticky top-0 h-screen w-64 flex-shrink-0 py-8 pr-8"> <aside class="w-64 p-4 pr-8"><nav class="flex flex-col space-y-2"><a href="/" class="flex items-center gap-4 py-3 px-6 text-lg font-semibold no-underline text-zinc-900 dark:text-zinc-100 rounded-full transition-colors duration-200 ease-in-out hover:bg-gray-200 dark:hover:bg-zinc-800"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-house" aria-hidden="true"><path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"></path><path d="M3 10a2 2 0 0 1 .709-1.528l7-6a2 2 0 0 1 2.582 0l7 6A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path></svg><span>主页</span></a><a href="/events" class="flex items-center gap-4 py-3 px-6 text-lg font-semibold no-underline text-zinc-900 dark:text-zinc-100 rounded-full transition-colors duration-200 ease-in-out hover:bg-gray-200 dark:hover:bg-zinc-800"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss" aria-hidden="true"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg><span>时事快讯</span></a></nav></aside> </aside> <main class="flex-1 min-w-0"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z8I5Ct" prefix="r15" component-url="/_astro/MobileNav.IYPvWUAA.js" component-export="default" renderer-url="/_astro/client.D0HLj-jK.js" props="{&quot;title&quot;:[0,&quot;CSS 锚定定位(Anchor Positioning)&quot;]}" ssr client="load" opts="{&quot;name&quot;:&quot;MobileNav&quot;,&quot;value&quot;:true}" await-children><div id="mobile-topbar" class="sticky top-0 z-50 flex h-14 items-center justify-between border-b border-zinc-200 bg-white/80 px-4 backdrop-blur-sm dark:border-zinc-800 dark:bg-zinc-900/80 lg:hidden"><div class="w-6"></div><div class="absolute left-1/2 -translate-x-1/2 text-sm font-semibold text-zinc-700 dark:text-zinc-300">CSS 锚定定位(Anchor Positioning)</div><button type="button" aria-label="Open menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu" aria-hidden="true"><path d="M4 5h16"></path><path d="M4 12h16"></path><path d="M4 19h16"></path></svg></button></div><template data-astro-template> <div class="space-y-4"> <astro-island uid="ZGJkSI" prefix="r8" component-url="/_astro/TableOfContentsCard.BBvTc4w5.js" component-export="default" renderer-url="/_astro/client.D0HLj-jK.js" props="{&quot;headings&quot;:[1,[[0,{&quot;depth&quot;:[0,3],&quot;slug&quot;:[0,&quot;入门抛出第一个锚&quot;],&quot;text&quot;:[0,&quot;入门：抛出第一个锚&quot;]}],[0,{&quot;depth&quot;:[0,3],&quot;slug&quot;:[0,&quot;进阶让定位更得心应手&quot;],&quot;text&quot;:[0,&quot;进阶：让定位更得心应手&quot;]}],[0,{&quot;depth&quot;:[0,3],&quot;slug&quot;:[0,&quot;实战处理真实世界的复杂性&quot;],&quot;text&quot;:[0,&quot;实战：处理真实世界的复杂性&quot;]}],[0,{&quot;depth&quot;:[0,3],&quot;slug&quot;:[0,&quot;高级话题作用域隐式锚点&quot;],&quot;text&quot;:[0,&quot;高级话题：作用域、隐式锚点&quot;]}],[0,{&quot;depth&quot;:[0,3],&quot;slug&quot;:[0,&quot;别忘了可访问性-accessibility&quot;],&quot;text&quot;:[0,&quot;别忘了可访问性 (Accessibility)&quot;]}],[0,{&quot;depth&quot;:[0,3],&quot;slug&quot;:[0,&quot;总结未来已来&quot;],&quot;text&quot;:[0,&quot;总结：未来已来？&quot;]}]]]}" ssr client="load" opts="{&quot;name&quot;:&quot;TableOfContentsCard&quot;,&quot;value&quot;:true}" await-children><div class="rounded-xl border bg-card text-card-foreground shadow"><div class="p-6 pt-0"><ul><li><a href="#入门抛出第一个锚">入门：抛出第一个锚</a></li><li><a href="#进阶让定位更得心应手">进阶：让定位更得心应手</a></li><li><a href="#实战处理真实世界的复杂性">实战：处理真实世界的复杂性</a></li><li><a href="#高级话题作用域隐式锚点">高级话题：作用域、隐式锚点</a></li><li><a href="#别忘了可访问性-accessibility">别忘了可访问性 (Accessibility)</a></li><li><a href="#总结未来已来">总结：未来已来？</a></li></ul></div></div><!--astro:end--></astro-island> <!-- <TagsCard client:load tags={allTags} />
          <ArchiveCard client:load postsByMonth={postsByMonth} /> --> </div> </template><!--astro:end--></astro-island> <div class="p-6">  <article class="prose dark:prose-invert max-w-none" data-astro-cid-eomsrdgo> <!-- 1. 只在客户端渲染 --> <script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><astro-island uid="1wU2Ho" component-url="/_astro/MarkdownRenderer.kxY-DVdT.js" component-export="default" renderer-url="/_astro/client.D0HLj-jK.js" props="{&quot;className&quot;:[0,&quot;md-renderer&quot;],&quot;markdown&quot;:[0,&quot;今天我们要聊一个 CSS 世界里正在悄然兴起，但可能彻底改变我们布局方式的“大杀器”——**CSS Anchor Positioning**（锚定定位）。\n\n你有没有遇到过这样的场景？鼠标悬浮在一个按钮上，想弹出一个 tooltip；点击一个输入框，希望下方出现一个建议列表；或者实现一个下拉菜单，它得不偏不倚地对齐触发按钮。\n\n![想象一个按钮和旁边恼人的 tooltip 定位问题](../../../assets/article-0053/bad-tooltip-posiction.webp)\n\n在过去，我们是怎么解决的？\n\n1.  **DOM 结构依赖：** 把 tooltip/下拉菜单硬塞到按钮的父元素里，然后用 `position: relative/absolute` 各种计算。但这要求 DOM 结构必须“配合”，不够灵活。\n2.  **JavaScript 大法：** 获取按钮的位置和尺寸 (`getBoundingClientRect`)，计算 tooltip 应该放哪，监听滚动、窗口大小变化，重新计算... 心智负担重，性能还可能有问题。这感觉就像是为了拧个螺丝，结果造了台挖掘机。\n\n这些方法都透露着一种“不得已而为之”的无奈。我们只是想让一个元素 _相对_ 于 _另一个_ 元素定位，为什么就这么难？CSS 的 `position: absolute` 不是相对于包含块吗？如果我的触发元素和定位元素不在一个合适的包含块里，或者我压根不想关心它们的 DOM 结构关系呢？\n\n**Anchor Positioning 的核心哲学：解放定位，打破束缚**\n\nCSS Anchor Positioning 就像给 CSS 定位系统加了个“外挂”。它的核心思想简单粗暴但极其有效：\n\n&gt; **让一个元素（通常是绝对定位或固定定位的）可以显式地声明它想“锚定”到页面上的一个或多个其他元素，并基于这些“锚点”元素的位置和尺寸来定位或调整自身尺寸，而无需关心它们在 DOM 树中的关系或共同的包含块。**\n\n这就像在大海里航行，以前你只能靠附近的灯塔（包含块）定位，现在你可以直接抛锚（anchor）到任何你想停靠的岛屿（任意元素）旁边。这种**解耦**是革命性的：\n\n- **DOM 结构自由：** 你的 tooltip、popover 可以放在 `&lt;body&gt;` 下，或者任何你想放的地方，不再受父子关系的限制。\n- **CSS 驱动：** 定位逻辑回归 CSS，减少甚至消除对 JS 的依赖，更符合关注点分离原则，性能也可能更好。\n- **智能避让：** 内建了处理边缘碰撞、自动调整位置（fallback）的机制，让“气泡总在元素旁边，但又不会跑出屏幕”这种需求变得简单。\n\n听起来是不是很激动人心？别急，我们一步步来看它是怎么施展魔法的。\n\n### 入门：抛出第一个锚\n\n想象我们要给一个按钮 `.anchor-btn` 加一个 tooltip `.tooltip`。\n\n**第一步：指定谁是锚点 (`anchor-name`)**\n\n首先，得告诉 CSS，哪个元素是我们的“锚”。这通过 `anchor-name` 属性完成。它的值需要是 CSS 变量那种 `--` 开头的“虚线标识符”（dashed-ident）。\n\n```css\n.anchor-btn {\n  /* --my-anchor 就是这个锚点的名字 */\n  anchor-name: --my-anchor;\n\n  /* 其他样式... */\n  padding: 10px 20px;\n  border: 1px solid #ccc;\n}\n```\n\n**第二步：设置需要定位的元素**\n\nTooltip 通常需要脱离文档流，所以我们给它 `position: fixed` 或 `absolute`。`fixed` 更省心，不用担心嵌套层级和 `transform` 干扰定位基准（虽然 Anchor Positioning 自身对 transform 和 scroll 有特殊处理，后面会提）。\n\n```css\n.tooltip {\n  position: fixed; /* 或者 absolute */\n  background-color: #333;\n  color: white;\n  padding: 5px 10px;\n  border-radius: 4px;\n  /* 先隐藏，可能通过 JS 或 :hover/:focus 等显示 */\n  display: none;\n}\n```\n\n**第三步：连接锚点和定位元素 (默认锚点 `position-anchor`)**\n\n现在，告诉 `.tooltip`，它默认应该参考哪个锚点。使用 `position-anchor` 属性。\n\n```css\n.tooltip {\n  position: fixed;\n  /* ... 其他样式 ... */\n\n  /* 默认情况下，我的位置参考 --my-anchor 这个锚点 */\n  position-anchor: --my-anchor;\n}\n```\n\n**第四步：使用 `anchor()` 函数定位**\n\n最关键的一步来了！怎么具体定位呢？用 `anchor()` 函数！这个函数可以用在 `top`, `left`, `right`, `bottom` 这些 inset 属性里。\n\n`anchor()` 函数的基本用法是 `anchor(&lt;anchor-side&gt;)`。当 `position-anchor` 设置了默认锚点时，可以省略锚点名字。`&lt;anchor-side&gt;` 指的是你希望定位元素的哪条边对齐锚点元素的哪条边。\n\n例如，我们想让 tooltip 的底部（`bottom`）对齐按钮的顶部（`top`）：\n\n```css\n.tooltip {\n  position: fixed;\n  /* 消除默认 margin 行为，这个很重要，否则会有很多不符合预期的行为 */\n  margin: 0;\n  /* 设置锚定点 */\n  position-anchor: --my-anchor;\n  /* ... 其他样式 ... */\n\n  /* 让我的 bottom 对齐 默认锚点 的 top */\n  bottom: anchor(top);\n  /* 水平方向，让我的左边 对齐 默认锚点 的左边 */\n  left: anchor(left);\n\n  /* 加一点偏移，让 tooltip 在按钮上方一点 */\n  margin-bottom: 8px;\n}\n```\n\n`anchor()` 函数里的 `top`, `left`, `right`, `bottom` 指的是锚点元素的**边界**。\n\n还有两个特殊的关键字：`inside` 和 `outside`。\n`inside` 指的是与 inset 属性**相同**的边，`outside` 指的是**相对**的边。\n\n例如，`bottom: anchor(top)` 可以理解为：\n我要设置 `bottom` 属性，它的值依赖于锚点的 `top` 边。\n\n而 `bottom: anchor(outside)` 就有点意思了，用在 `bottom` 属性上时，`outside` 指的是锚点的 `top` 边。用在 `top` 属性上时，`outside` 指的是锚点的 `bottom` 边。它表示“贴着锚点的外面”。\n\n所以，上面的 `bottom: anchor(top)` 其实更自然的写法是：\n\n```css\n.tooltip {\n  /* ... */\n  /* 把我的 top 定位在 锚点 的 bottom (即按钮下方) */\n  /* top: anchor(bottom); */\n\n  /* 或者，让我的 bottom 定位在 锚点 的 top (即按钮上方) */\n  bottom: anchor(top);\n\n  /* 水平居中？可以让 tooltip 的中线对齐锚点的中线 */\n  left: anchor(center);\n  transform: translateX(-50%); /* CSS经典居中 */\n\n  margin-bottom: 8px; /* 向上偏移 */\n}\n```\n\n`anchor()` 还可以接受百分比，`anchor(50%)` 或 `anchor(center)` 都代表锚点对应轴向的中心线。\n\n```html\n&lt;button class=\&quot;anchor-btn\&quot;&gt;Hover Me&lt;/button&gt;\n&lt;div class=\&quot;tooltip\&quot; style=\&quot;display: block;\&quot;&gt;I&#39;m a tooltip!&lt;/div&gt;\n```\n\n![基础锚定定位效果](../../../assets/article-0053/tooltip-above-center.webp)\n\n是不是很简单？没有 JS，没有复杂的 DOM 嵌套，CSS 自己搞定了！\n\n### 进阶：让定位更得心应手\n\n`anchor()` 函数很强大，但每次都要写 `top`/`left` 有点繁琐。Anchor Positioning 提供了一些“语法糖”和增强功能。\n\n**1. `position-area`：九宫格布局**\n\n这是个超级方便的属性。它把锚点元素和它的“可用空间”（通常是视口或其包含块）想象成一个 3x3 的网格。你可以直接指定 tooltip 应该占据哪个格子。\n\n![position-area 的 3x3 网格示意图](../../../assets/article-0053/position-area-grid.webp) (来自规范草案的图)\n\n它的值可以是类似 `block-start`（块轴起点，通常是顶部）, `inline-end`（行轴终点，通常是右侧）, `center` 这样的关键字组合。\n\n例如，把 tooltip 放在按钮上方居中，可以这样写：\n\n```css\n.tooltip {\n  position: fixed;\n  position-anchor: --my-anchor;\n  /* ... 其他样式 ... */\n\n  /* 区域：块轴起点(top)，行轴中间(center) */\n  position-area: block-start center;\n  /* 默认对齐方式通常就不错，也可以用 align-self/justify-self 微调 */\n}\n```\n\n想放右边中间？`position-area: center inline-end;`\n想放左下角？`position-area: block-end inline-start;`\n\n它甚至支持跨越多行/列，如 `span-block-start` (从中间跨越到顶部)。\n\n**2. `anchor-center`：居中对齐的新选择**\n\n对于 `align-self` 和 `justify-self`，增加了一个新值 `anchor-center`。当使用 `position-area` 或希望在某个轴向上精确地对齐锚点的中心时，这个值非常有用。\n\n```css\n.tooltip {\n  /* ... */\n  position-area: block-start; /* 放在上方区域 */\n  justify-self: anchor-center; /* 水平方向对齐锚点中心 */\n}\n```\n\n**3. `anchor-size()`：尺寸向锚点看齐**\n\n有时候，我们希望定位元素的尺寸能跟随锚点变化。比如，下拉菜单的宽度应该和触发按钮一样宽。`anchor-size()` 函数应运而生！\n\n```css\n.dropdown-menu {\n  position: fixed;\n  position-anchor: --my-trigger;\n  /* ... */\n  top: anchor(bottom);\n  left: anchor(left);\n\n  /* 让我的宽度等于 --my-trigger 锚点的宽度 */\n  width: anchor-size(width);\n  /* 或者用逻辑轴 */\n  /* width: anchor-size(inline); */\n\n  /* 高度也可以 */\n  /* max-height: anchor-size(height) * 3; */\n}\n```\n\n`anchor-size()` 可以用在 `width`, `height`, `min-*`, `max-*` 等属性中，可以引用 `width`, `height`, `block`, `inline` (逻辑轴) 等。\n\n### 实战：处理真实世界的复杂性\n\n理想很丰满，现实很骨感。如果 tooltip 放在按钮上方会超出屏幕怎么办？如果滚动页面，锚点跑了，tooltip 会不会留在原地发呆？\n\n**1. 边缘碰撞与回退 (`position-try-fallbacks`, `@position-try`)**\n\n这是 Anchor Positioning 的精髓之一！当默认的定位方式导致元素溢出其容器（通常是视口）时，它可以自动尝试备选方案。\n\n- **内置回退策略 (`flip-block`, `flip-inline`, `flip-start`)**:\n  `position-try-fallbacks` 属性可以接受一些关键字，比如 `flip-block` 会尝试在块轴方向翻转（比如从上翻到下），`flip-inline` 则在行轴方向翻转（从左到右）。\n\n  ```css\n  .tooltip {\n    /* ... */\n    position-area: block-start; /* 默认放上面 */\n    /* 如果上面放不下，尝试块级翻转（放到下面） */\n    position-try-fallbacks: flip-block;\n  }\n  ```\n\n- **自定义回退规则 (`@position-try`)**:\n  你可以定义具名的回退样式集。\n\n  ```css\n  @position-try --fallback-bottom {\n    position-area: block-end; /* 尝试放下面 */\n    /* 可以定义更多样式调整 */\n    background-color: lightcoral; /* 比如换个背景色提示 */\n  }\n\n  @position-try --fallback-right {\n    position-area: inline-end;\n  }\n\n  .tooltip {\n    /* ... */\n    position-area: block-start; /* 默认放上面 */\n    /* 尝试顺序：先用 --fallback-bottom 规则，再尝试行内翻转，再用 --fallback-right 规则 */\n    position-try-fallbacks: --fallback-bottom, flip-inline, --fallback-right;\n  }\n  ```\n\n- **回退顺序 (`position-try-order`)**:\n  默认按 `position-try-fallbacks` 列表顺序尝试。但有时你希望优先选择**空间更大**的回退位置，可以用 `most-width`, `most-height`, `most-block-size`, `most-inline-size`。\n\n  ```css\n  .tooltip {\n    /* ... */\n    position-try-fallbacks: --try-top, --try-bottom, --try-left, --try-right;\n    /* 优先选择高度最大的位置 */\n    position-try-order: most-height;\n  }\n  ```\n\n**2. 滚动与变换：性能与行为的权衡**\n\n这是一个复杂但重要的话题。如果锚点在可滚动区域内，或者被 `transform` 了，定位元素怎么办？\n\n- **基本原则：** 为了性能，浏览器通常**不会**在滚动或 `transform` 改变时频繁重新计算锚点元素的精确布局。\n- **记住滚动偏移 (`remembered scroll offset`)：** 浏览器会在某个时间点（比如元素首次显示或回退策略改变时）“记住”锚点相对于定位元素的滚动容器的滚动偏移量。后续定位会基于这个记住的值。\n- **默认锚点的特权：** 如果定位元素只依赖**默认锚点** (`position-anchor` 指定的那个)，并且满足特定条件（比如用了 `anchor-center` 或 `position-area`），浏览器**可以**在滚动时**平移**定位元素，让它跟随默认锚点移动。这是一种性能友好的“补偿”(`compensate for scroll`)。\n- **多锚点或非默认锚点：** 如果你用了多个 `anchor()` 指向不同滚动容器的锚点，或者依赖非默认锚点，滚动时它们的位置可能就不再精确跟随了（只跟随非滚动部分的移动）。\n- **`transform` 的影响：** 规范草案目前提到，默认情况下，锚点上的 `transform` **不影响** `anchor()` 函数的计算结果（Issue 1）。这可能会在未来改变。\n\n简单说：尽量让你的主要定位逻辑依赖默认锚点，可以获得更好的滚动跟随效果。对于复杂的多锚点场景，滚动时的行为可能没那么“实时”。\n\n**3. 条件隐藏 (`position-visibility`)**\n\n有时候，如果锚点无效、不可见，或者即使尝试了所有回退方案，定位元素仍然溢出，我们可能希望直接隐藏它。`position-visibility` 属性就是干这个的。\n\n```css\n.tooltip {\n  /* ... */\n  /* 默认值是 anchors-visible，如果锚点不可见（比如被滚动隐藏了）就自动隐藏 */\n  /* position-visibility: anchors-visible; */\n\n  /* 如果所有回退都试过后还溢出，就隐藏 */\n  position-visibility: no-overflow;\n\n  /* 如果有必须的锚点（比如 anchor() 没提供 fallback 值）无效，就隐藏 */\n  /* position-visibility: anchors-valid; */\n\n  /* 组合使用 */\n  position-visibility: anchors-valid no-overflow;\n}\n```\n\n### 高级话题：作用域、隐式锚点\n\n- **`anchor-scope`：避免命名冲突**\n  在组件化开发中，如果你在列表的每个 `&lt;li&gt;` 里都用了 `anchor-name: --item-anchor`，那所有 `&lt;li&gt;` 里的定位元素都会锚定到**最后一个** `&lt;li&gt;` 上！`anchor-scope` 可以限制锚点名称的查找范围。\n\n  ```css\n  li {\n    /* 这个锚点名字只在 li 内部及其后代中有效 */\n    anchor-name: --item-anchor;\n    anchor-scope: --item-anchor;\n    position: relative; /* 创建层叠上下文可能也有帮助 */\n  }\n  li .popup {\n    position: absolute;\n    position-anchor: --item-anchor;\n    top: anchor(bottom);\n    /* ... */\n  }\n  ```\n\n- **隐式锚点 (`auto`)**\n  某些 HTML API（比如未来的 Popover API）可能会自动建立锚定关系。比如，触发 popover 的按钮自动成为该 popover 的“隐式锚点”。这时，你可以用 `position-anchor: auto;` 或者在 `anchor()`/`anchor-size()` 中省略锚点名来引用它。\n\n### 别忘了可访问性 (Accessibility)\n\n重要的事情说三遍：Anchor Positioning 是**纯视觉**的！它在视觉上把两个元素关联起来，但**不会**自动建立它们之间的语义联系。\n\n屏幕阅读器等辅助技术无法理解这种视觉关联。所以，你必须：\n\n- 使用 `aria-describedby`, `aria-details` 等 ARIA 属性，在 HTML 中明确两者关系。\n- 确保合理的焦点管理和键盘导航。\n\n好消息是，像 Popover API 这样的原生 HTML 功能，在提供隐式锚点的同时，通常也会处理好相关的可访问性问题。\n\n### 总结：未来已来？\n\nCSS Anchor Positioning 无疑是近年来 CSS 布局领域最激动人心的提案之一。它直击了 Web 开发中长期存在的定位痛点，提供了一种更声明式、更灵活、更强大的解决方案。\n\n**优点：**\n\n- **DOM 解耦：** 布局不再受限于 HTML 结构。\n- **CSS 驱动：** 减少 JS 依赖，代码更清晰。\n- **智能回退：** 内建边缘检测和位置调整。\n- **强大灵活：** `anchor()`, `anchor-size()`, `position-area` 提供了丰富的控制。\n\n**注意事项/挑战：**\n\n- **新规范：** 目前仍是 Editor&#39;s Draft（编辑草案），API 可能会变化，浏览器支持需要关注（通常需要开启实验性标志）。(写作时基于 2024 年 10 月草案)\n- **滚动/变换行为：** 涉及性能权衡，行为需要理解清楚。\n- **可访问性：** 需要开发者额外关注。\n- **学习曲线：** 虽然入门简单，但回退、滚动等机制需要深入理解。\n\n总的来说，Anchor Positioning 描绘了一个美好的未来：开发者可以更专注于内容和语义，把复杂的定位逻辑交还给 CSS。虽然离全面普及还有距离，但了解它、尝试它，绝对能让你在未来的 Web 布局中占得先机。\n\n告别那些为了定位而写的 JS \&quot;屎山\&quot;吧，拥抱 CSS 的新可能！你觉得这个新特性怎么样？欢迎在评论区留下你的看法！\n\n---\n\n希望这篇模仿张鑫旭老师风格的文章能帮助你理解 CSS Anchor Positioning！记得，实际运用时一定要查阅最新的规范文档和浏览器兼容性信息。\n\n参考文献：\n\n1. [CSS Anchor Positioning - Editor’s Draft, 12 October 2024](https://drafts.csswg.org/css-anchor-position-1/)&quot;],&quot;data-astro-cid-eomsrdgo&quot;:[0,true]}" ssr client="only" opts="{&quot;name&quot;:&quot;MarkdownRenderer&quot;,&quot;value&quot;:true}"></astro-island> <!-- 2. 无 JS 时的回退 --> <div class="fallback-content" data-astro-cid-eomsrdgo> <p>今天我们要聊一个 CSS 世界里正在悄然兴起，但可能彻底改变我们布局方式的“大杀器”——<strong>CSS Anchor Positioning</strong>（锚定定位）。</p>
<p>你有没有遇到过这样的场景？鼠标悬浮在一个按钮上，想弹出一个 tooltip；点击一个输入框，希望下方出现一个建议列表；或者实现一个下拉菜单，它得不偏不倚地对齐触发按钮。</p>
<p><img alt="想象一个按钮和旁边恼人的 tooltip 定位问题" loading="lazy" decoding="async" fetchpriority="auto" width="624" height="324" src="/_astro/bad-tooltip-posiction.COcvBOxH_fHWGW.webp" ></p>
<p>在过去，我们是怎么解决的？</p>
<ol>
<li><strong>DOM 结构依赖：</strong> 把 tooltip/下拉菜单硬塞到按钮的父元素里，然后用 <code>position: relative/absolute</code> 各种计算。但这要求 DOM 结构必须“配合”，不够灵活。</li>
<li><strong>JavaScript 大法：</strong> 获取按钮的位置和尺寸 (<code>getBoundingClientRect</code>)，计算 tooltip 应该放哪，监听滚动、窗口大小变化，重新计算… 心智负担重，性能还可能有问题。这感觉就像是为了拧个螺丝，结果造了台挖掘机。</li>
</ol>
<p>这些方法都透露着一种“不得已而为之”的无奈。我们只是想让一个元素 <em>相对</em> 于 <em>另一个</em> 元素定位，为什么就这么难？CSS 的 <code>position: absolute</code> 不是相对于包含块吗？如果我的触发元素和定位元素不在一个合适的包含块里，或者我压根不想关心它们的 DOM 结构关系呢？</p>
<p><strong>Anchor Positioning 的核心哲学：解放定位，打破束缚</strong></p>
<p>CSS Anchor Positioning 就像给 CSS 定位系统加了个“外挂”。它的核心思想简单粗暴但极其有效：</p>
<blockquote>
<p><strong>让一个元素（通常是绝对定位或固定定位的）可以显式地声明它想“锚定”到页面上的一个或多个其他元素，并基于这些“锚点”元素的位置和尺寸来定位或调整自身尺寸，而无需关心它们在 DOM 树中的关系或共同的包含块。</strong></p>
</blockquote>
<p>这就像在大海里航行，以前你只能靠附近的灯塔（包含块）定位，现在你可以直接抛锚（anchor）到任何你想停靠的岛屿（任意元素）旁边。这种<strong>解耦</strong>是革命性的：</p>
<ul>
<li><strong>DOM 结构自由：</strong> 你的 tooltip、popover 可以放在 <code>&#x3C;body></code> 下，或者任何你想放的地方，不再受父子关系的限制。</li>
<li><strong>CSS 驱动：</strong> 定位逻辑回归 CSS，减少甚至消除对 JS 的依赖，更符合关注点分离原则，性能也可能更好。</li>
<li><strong>智能避让：</strong> 内建了处理边缘碰撞、自动调整位置（fallback）的机制，让“气泡总在元素旁边，但又不会跑出屏幕”这种需求变得简单。</li>
</ul>
<p>听起来是不是很激动人心？别急，我们一步步来看它是怎么施展魔法的。</p>
<h3 id="入门抛出第一个锚">入门：抛出第一个锚</h3>
<p>想象我们要给一个按钮 <code>.anchor-btn</code> 加一个 tooltip <code>.tooltip</code>。</p>
<p><strong>第一步：指定谁是锚点 (<code>anchor-name</code>)</strong></p>
<p>首先，得告诉 CSS，哪个元素是我们的“锚”。这通过 <code>anchor-name</code> 属性完成。它的值需要是 CSS 变量那种 <code>--</code> 开头的“虚线标识符”（dashed-ident）。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.anchor-btn</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /* --my-anchor 就是这个锚点的名字 */</span></span>
<span class="line"><span style="color:#79B8FF">  anchor-name</span><span style="color:#E1E4E8">: --my-anchor;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 其他样式... */</span></span>
<span class="line"><span style="color:#79B8FF">  padding</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">10</span><span style="color:#F97583">px</span><span style="color:#79B8FF"> 20</span><span style="color:#F97583">px</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  border</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">1</span><span style="color:#F97583">px</span><span style="color:#79B8FF"> solid</span><span style="color:#79B8FF"> #ccc</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>第二步：设置需要定位的元素</strong></p>
<p>Tooltip 通常需要脱离文档流，所以我们给它 <code>position: fixed</code> 或 <code>absolute</code>。<code>fixed</code> 更省心，不用担心嵌套层级和 <code>transform</code> 干扰定位基准（虽然 Anchor Positioning 自身对 transform 和 scroll 有特殊处理，后面会提）。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">  position</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">fixed</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">/* 或者 absolute */</span></span>
<span class="line"><span style="color:#79B8FF">  background-color</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">#333</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  color</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">white</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  padding</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">5</span><span style="color:#F97583">px</span><span style="color:#79B8FF"> 10</span><span style="color:#F97583">px</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  border-radius</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">4</span><span style="color:#F97583">px</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">  /* 先隐藏，可能通过 JS 或 :hover/:focus 等显示 */</span></span>
<span class="line"><span style="color:#79B8FF">  display</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">none</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>第三步：连接锚点和定位元素 (默认锚点 <code>position-anchor</code>)</strong></p>
<p>现在，告诉 <code>.tooltip</code>，它默认应该参考哪个锚点。使用 <code>position-anchor</code> 属性。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">  position</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">fixed</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">  /* ... 其他样式 ... */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 默认情况下，我的位置参考 --my-anchor 这个锚点 */</span></span>
<span class="line"><span style="color:#79B8FF">  position-anchor</span><span style="color:#E1E4E8">: --my-anchor;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>第四步：使用 <code>anchor()</code> 函数定位</strong></p>
<p>最关键的一步来了！怎么具体定位呢？用 <code>anchor()</code> 函数！这个函数可以用在 <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code> 这些 inset 属性里。</p>
<p><code>anchor()</code> 函数的基本用法是 <code>anchor(&#x3C;anchor-side>)</code>。当 <code>position-anchor</code> 设置了默认锚点时，可以省略锚点名字。<code>&#x3C;anchor-side></code> 指的是你希望定位元素的哪条边对齐锚点元素的哪条边。</p>
<p>例如，我们想让 tooltip 的底部（<code>bottom</code>）对齐按钮的顶部（<code>top</code>）：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">  position</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">fixed</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">  /* 消除默认 margin 行为，这个很重要，否则会有很多不符合预期的行为 */</span></span>
<span class="line"><span style="color:#79B8FF">  margin</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">  /* 设置锚定点 */</span></span>
<span class="line"><span style="color:#79B8FF">  position-anchor</span><span style="color:#E1E4E8">: --my-anchor;</span></span>
<span class="line"><span style="color:#6A737D">  /* ... 其他样式 ... */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 让我的 bottom 对齐 默认锚点 的 top */</span></span>
<span class="line"><span style="color:#79B8FF">  bottom</span><span style="color:#E1E4E8">: anchor(</span><span style="color:#79B8FF">top</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">  /* 水平方向，让我的左边 对齐 默认锚点 的左边 */</span></span>
<span class="line"><span style="color:#79B8FF">  left</span><span style="color:#E1E4E8">: anchor(</span><span style="color:#79B8FF">left</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 加一点偏移，让 tooltip 在按钮上方一点 */</span></span>
<span class="line"><span style="color:#79B8FF">  margin-bottom</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">8</span><span style="color:#F97583">px</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><code>anchor()</code> 函数里的 <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code> 指的是锚点元素的<strong>边界</strong>。</p>
<p>还有两个特殊的关键字：<code>inside</code> 和 <code>outside</code>。
<code>inside</code> 指的是与 inset 属性<strong>相同</strong>的边，<code>outside</code> 指的是<strong>相对</strong>的边。</p>
<p>例如，<code>bottom: anchor(top)</code> 可以理解为：
我要设置 <code>bottom</code> 属性，它的值依赖于锚点的 <code>top</code> 边。</p>
<p>而 <code>bottom: anchor(outside)</code> 就有点意思了，用在 <code>bottom</code> 属性上时，<code>outside</code> 指的是锚点的 <code>top</code> 边。用在 <code>top</code> 属性上时，<code>outside</code> 指的是锚点的 <code>bottom</code> 边。它表示“贴着锚点的外面”。</p>
<p>所以，上面的 <code>bottom: anchor(top)</code> 其实更自然的写法是：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /* ... */</span></span>
<span class="line"><span style="color:#6A737D">  /* 把我的 top 定位在 锚点 的 bottom (即按钮下方) */</span></span>
<span class="line"><span style="color:#6A737D">  /* top: anchor(bottom); */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 或者，让我的 bottom 定位在 锚点 的 top (即按钮上方) */</span></span>
<span class="line"><span style="color:#79B8FF">  bottom</span><span style="color:#E1E4E8">: anchor(</span><span style="color:#79B8FF">top</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 水平居中？可以让 tooltip 的中线对齐锚点的中线 */</span></span>
<span class="line"><span style="color:#79B8FF">  left</span><span style="color:#E1E4E8">: anchor(</span><span style="color:#79B8FF">center</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">  transform</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">translateX</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">-50</span><span style="color:#F97583">%</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">/* CSS经典居中 */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">  margin-bottom</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">8</span><span style="color:#F97583">px</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">/* 向上偏移 */</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><code>anchor()</code> 还可以接受百分比，<code>anchor(50%)</code> 或 <code>anchor(center)</code> 都代表锚点对应轴向的中心线。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="html"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> class</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"anchor-btn"</span><span style="color:#E1E4E8">>Hover Me&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">div</span><span style="color:#B392F0"> class</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"tooltip"</span><span style="color:#B392F0"> style</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"display: block;"</span><span style="color:#E1E4E8">>I'm a tooltip!&#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span></code></pre>
<p><img alt="基础锚定定位效果" loading="lazy" decoding="async" fetchpriority="auto" width="1643" height="984" src="/_astro/tooltip-above-center.DtgGYqxz_ZWPtDk.webp" ></p>
<p>是不是很简单？没有 JS，没有复杂的 DOM 嵌套，CSS 自己搞定了！</p>
<h3 id="进阶让定位更得心应手">进阶：让定位更得心应手</h3>
<p><code>anchor()</code> 函数很强大，但每次都要写 <code>top</code>/<code>left</code> 有点繁琐。Anchor Positioning 提供了一些“语法糖”和增强功能。</p>
<p><strong>1. <code>position-area</code>：九宫格布局</strong></p>
<p>这是个超级方便的属性。它把锚点元素和它的“可用空间”（通常是视口或其包含块）想象成一个 3x3 的网格。你可以直接指定 tooltip 应该占据哪个格子。</p>
<p><img alt="position-area 的 3x3 网格示意图" loading="lazy" decoding="async" fetchpriority="auto" width="1102" height="826" src="/_astro/position-area-grid.CMk6YsfI_2i8eR5.webp" > (来自规范草案的图)</p>
<p>它的值可以是类似 <code>block-start</code>（块轴起点，通常是顶部）, <code>inline-end</code>（行轴终点，通常是右侧）, <code>center</code> 这样的关键字组合。</p>
<p>例如，把 tooltip 放在按钮上方居中，可以这样写：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">  position</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">fixed</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  position-anchor</span><span style="color:#E1E4E8">: --my-anchor;</span></span>
<span class="line"><span style="color:#6A737D">  /* ... 其他样式 ... */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 区域：块轴起点(top)，行轴中间(center) */</span></span>
<span class="line"><span style="color:#79B8FF">  position-area</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">block-start</span><span style="color:#79B8FF"> center</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">  /* 默认对齐方式通常就不错，也可以用 align-self/justify-self 微调 */</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>想放右边中间？<code>position-area: center inline-end;</code>
想放左下角？<code>position-area: block-end inline-start;</code></p>
<p>它甚至支持跨越多行/列，如 <code>span-block-start</code> (从中间跨越到顶部)。</p>
<p><strong>2. <code>anchor-center</code>：居中对齐的新选择</strong></p>
<p>对于 <code>align-self</code> 和 <code>justify-self</code>，增加了一个新值 <code>anchor-center</code>。当使用 <code>position-area</code> 或希望在某个轴向上精确地对齐锚点的中心时，这个值非常有用。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /* ... */</span></span>
<span class="line"><span style="color:#79B8FF">  position-area</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">block-start</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">/* 放在上方区域 */</span></span>
<span class="line"><span style="color:#79B8FF">  justify-self</span><span style="color:#E1E4E8">: anchor-center; </span><span style="color:#6A737D">/* 水平方向对齐锚点中心 */</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><strong>3. <code>anchor-size()</code>：尺寸向锚点看齐</strong></p>
<p>有时候，我们希望定位元素的尺寸能跟随锚点变化。比如，下拉菜单的宽度应该和触发按钮一样宽。<code>anchor-size()</code> 函数应运而生！</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.dropdown-menu</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">  position</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">fixed</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  position-anchor</span><span style="color:#E1E4E8">: --my-trigger;</span></span>
<span class="line"><span style="color:#6A737D">  /* ... */</span></span>
<span class="line"><span style="color:#79B8FF">  top</span><span style="color:#E1E4E8">: anchor(</span><span style="color:#79B8FF">bottom</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">  left</span><span style="color:#E1E4E8">: anchor(</span><span style="color:#79B8FF">left</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 让我的宽度等于 --my-trigger 锚点的宽度 */</span></span>
<span class="line"><span style="color:#79B8FF">  width</span><span style="color:#E1E4E8">: anchor-size(width);</span></span>
<span class="line"><span style="color:#6A737D">  /* 或者用逻辑轴 */</span></span>
<span class="line"><span style="color:#6A737D">  /* width: anchor-size(inline); */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 高度也可以 */</span></span>
<span class="line"><span style="color:#6A737D">  /* max-height: anchor-size(height) * 3; */</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><code>anchor-size()</code> 可以用在 <code>width</code>, <code>height</code>, <code>min-*</code>, <code>max-*</code> 等属性中，可以引用 <code>width</code>, <code>height</code>, <code>block</code>, <code>inline</code> (逻辑轴) 等。</p>
<h3 id="实战处理真实世界的复杂性">实战：处理真实世界的复杂性</h3>
<p>理想很丰满，现实很骨感。如果 tooltip 放在按钮上方会超出屏幕怎么办？如果滚动页面，锚点跑了，tooltip 会不会留在原地发呆？</p>
<p><strong>1. 边缘碰撞与回退 (<code>position-try-fallbacks</code>, <code>@position-try</code>)</strong></p>
<p>这是 Anchor Positioning 的精髓之一！当默认的定位方式导致元素溢出其容器（通常是视口）时，它可以自动尝试备选方案。</p>
<ul>
<li>
<p><strong>内置回退策略 (<code>flip-block</code>, <code>flip-inline</code>, <code>flip-start</code>)</strong>:
<code>position-try-fallbacks</code> 属性可以接受一些关键字，比如 <code>flip-block</code> 会尝试在块轴方向翻转（比如从上翻到下），<code>flip-inline</code> 则在行轴方向翻转（从左到右）。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /* ... */</span></span>
<span class="line"><span style="color:#79B8FF">  position-area</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">block-start</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">/* 默认放上面 */</span></span>
<span class="line"><span style="color:#6A737D">  /* 如果上面放不下，尝试块级翻转（放到下面） */</span></span>
<span class="line"><span style="color:#79B8FF">  position-try-fallbacks</span><span style="color:#E1E4E8">: flip-block;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
</li>
<li>
<p><strong>自定义回退规则 (<code>@position-try</code>)</strong>:
你可以定义具名的回退样式集。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#F97583">@position-try</span><span style="color:#E1E4E8"> --fallback-bottom {</span></span>
<span class="line"><span style="color:#85E89D">  position-area</span><span style="color:#E1E4E8">: </span><span style="color:#85E89D">block-end</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">/* 尝试放下面 */</span></span>
<span class="line"><span style="color:#6A737D">  /* 可以定义更多样式调整 */</span></span>
<span class="line"><span style="color:#85E89D">  background-color</span><span style="color:#E1E4E8">: lightcoral; </span><span style="color:#6A737D">/* 比如换个背景色提示 */</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">@position-try</span><span style="color:#E1E4E8"> --fallback-right {</span></span>
<span class="line"><span style="color:#85E89D">  position-area</span><span style="color:#E1E4E8">: </span><span style="color:#85E89D">inline-end</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /* ... */</span></span>
<span class="line"><span style="color:#79B8FF">  position-area</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">block-start</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">/* 默认放上面 */</span></span>
<span class="line"><span style="color:#6A737D">  /* 尝试顺序：先用 --fallback-bottom 规则，再尝试行内翻转，再用 --fallback-right 规则 */</span></span>
<span class="line"><span style="color:#79B8FF">  position-try-fallbacks</span><span style="color:#E1E4E8">: --fallback-bottom, flip-inline, --fallback-right;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
</li>
<li>
<p><strong>回退顺序 (<code>position-try-order</code>)</strong>:
默认按 <code>position-try-fallbacks</code> 列表顺序尝试。但有时你希望优先选择<strong>空间更大</strong>的回退位置，可以用 <code>most-width</code>, <code>most-height</code>, <code>most-block-size</code>, <code>most-inline-size</code>。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /* ... */</span></span>
<span class="line"><span style="color:#79B8FF">  position-try-fallbacks</span><span style="color:#E1E4E8">: --try-top, --try-bottom, --try-left, --try-right;</span></span>
<span class="line"><span style="color:#6A737D">  /* 优先选择高度最大的位置 */</span></span>
<span class="line"><span style="color:#79B8FF">  position-try-order</span><span style="color:#E1E4E8">: most-height;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
</li>
</ul>
<p><strong>2. 滚动与变换：性能与行为的权衡</strong></p>
<p>这是一个复杂但重要的话题。如果锚点在可滚动区域内，或者被 <code>transform</code> 了，定位元素怎么办？</p>
<ul>
<li><strong>基本原则：</strong> 为了性能，浏览器通常<strong>不会</strong>在滚动或 <code>transform</code> 改变时频繁重新计算锚点元素的精确布局。</li>
<li><strong>记住滚动偏移 (<code>remembered scroll offset</code>)：</strong> 浏览器会在某个时间点（比如元素首次显示或回退策略改变时）“记住”锚点相对于定位元素的滚动容器的滚动偏移量。后续定位会基于这个记住的值。</li>
<li><strong>默认锚点的特权：</strong> 如果定位元素只依赖<strong>默认锚点</strong> (<code>position-anchor</code> 指定的那个)，并且满足特定条件（比如用了 <code>anchor-center</code> 或 <code>position-area</code>），浏览器<strong>可以</strong>在滚动时<strong>平移</strong>定位元素，让它跟随默认锚点移动。这是一种性能友好的“补偿”(<code>compensate for scroll</code>)。</li>
<li><strong>多锚点或非默认锚点：</strong> 如果你用了多个 <code>anchor()</code> 指向不同滚动容器的锚点，或者依赖非默认锚点，滚动时它们的位置可能就不再精确跟随了（只跟随非滚动部分的移动）。</li>
<li><strong><code>transform</code> 的影响：</strong> 规范草案目前提到，默认情况下，锚点上的 <code>transform</code> <strong>不影响</strong> <code>anchor()</code> 函数的计算结果（Issue 1）。这可能会在未来改变。</li>
</ul>
<p>简单说：尽量让你的主要定位逻辑依赖默认锚点，可以获得更好的滚动跟随效果。对于复杂的多锚点场景，滚动时的行为可能没那么“实时”。</p>
<p><strong>3. 条件隐藏 (<code>position-visibility</code>)</strong></p>
<p>有时候，如果锚点无效、不可见，或者即使尝试了所有回退方案，定位元素仍然溢出，我们可能希望直接隐藏它。<code>position-visibility</code> 属性就是干这个的。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#B392F0">.tooltip</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /* ... */</span></span>
<span class="line"><span style="color:#6A737D">  /* 默认值是 anchors-visible，如果锚点不可见（比如被滚动隐藏了）就自动隐藏 */</span></span>
<span class="line"><span style="color:#6A737D">  /* position-visibility: anchors-visible; */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 如果所有回退都试过后还溢出，就隐藏 */</span></span>
<span class="line"><span style="color:#79B8FF">  position-visibility</span><span style="color:#E1E4E8">: no-overflow;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 如果有必须的锚点（比如 anchor() 没提供 fallback 值）无效，就隐藏 */</span></span>
<span class="line"><span style="color:#6A737D">  /* position-visibility: anchors-valid; */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  /* 组合使用 */</span></span>
<span class="line"><span style="color:#79B8FF">  position-visibility</span><span style="color:#E1E4E8">: anchors-valid no-overflow;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="高级话题作用域隐式锚点">高级话题：作用域、隐式锚点</h3>
<ul>
<li>
<p><strong><code>anchor-scope</code>：避免命名冲突</strong>
在组件化开发中，如果你在列表的每个 <code>&#x3C;li></code> 里都用了 <code>anchor-name: --item-anchor</code>，那所有 <code>&#x3C;li></code> 里的定位元素都会锚定到<strong>最后一个</strong> <code>&#x3C;li></code> 上！<code>anchor-scope</code> 可以限制锚点名称的查找范围。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="css"><code><span class="line"><span style="color:#85E89D">li</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  /* 这个锚点名字只在 li 内部及其后代中有效 */</span></span>
<span class="line"><span style="color:#79B8FF">  anchor-name</span><span style="color:#E1E4E8">: --item-anchor;</span></span>
<span class="line"><span style="color:#79B8FF">  anchor-scope</span><span style="color:#E1E4E8">: --item-anchor;</span></span>
<span class="line"><span style="color:#79B8FF">  position</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">relative</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">/* 创建层叠上下文可能也有帮助 */</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#85E89D">li</span><span style="color:#B392F0"> .popup</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">  position</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">absolute</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  position-anchor</span><span style="color:#E1E4E8">: --item-anchor;</span></span>
<span class="line"><span style="color:#79B8FF">  top</span><span style="color:#E1E4E8">: anchor(</span><span style="color:#79B8FF">bottom</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">  /* ... */</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
</li>
<li>
<p><strong>隐式锚点 (<code>auto</code>)</strong>
某些 HTML API（比如未来的 Popover API）可能会自动建立锚定关系。比如，触发 popover 的按钮自动成为该 popover 的“隐式锚点”。这时，你可以用 <code>position-anchor: auto;</code> 或者在 <code>anchor()</code>/<code>anchor-size()</code> 中省略锚点名来引用它。</p>
</li>
</ul>
<h3 id="别忘了可访问性-accessibility">别忘了可访问性 (Accessibility)</h3>
<p>重要的事情说三遍：Anchor Positioning 是<strong>纯视觉</strong>的！它在视觉上把两个元素关联起来，但<strong>不会</strong>自动建立它们之间的语义联系。</p>
<p>屏幕阅读器等辅助技术无法理解这种视觉关联。所以，你必须：</p>
<ul>
<li>使用 <code>aria-describedby</code>, <code>aria-details</code> 等 ARIA 属性，在 HTML 中明确两者关系。</li>
<li>确保合理的焦点管理和键盘导航。</li>
</ul>
<p>好消息是，像 Popover API 这样的原生 HTML 功能，在提供隐式锚点的同时，通常也会处理好相关的可访问性问题。</p>
<h3 id="总结未来已来">总结：未来已来？</h3>
<p>CSS Anchor Positioning 无疑是近年来 CSS 布局领域最激动人心的提案之一。它直击了 Web 开发中长期存在的定位痛点，提供了一种更声明式、更灵活、更强大的解决方案。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>DOM 解耦：</strong> 布局不再受限于 HTML 结构。</li>
<li><strong>CSS 驱动：</strong> 减少 JS 依赖，代码更清晰。</li>
<li><strong>智能回退：</strong> 内建边缘检测和位置调整。</li>
<li><strong>强大灵活：</strong> <code>anchor()</code>, <code>anchor-size()</code>, <code>position-area</code> 提供了丰富的控制。</li>
</ul>
<p><strong>注意事项/挑战：</strong></p>
<ul>
<li><strong>新规范：</strong> 目前仍是 Editor’s Draft（编辑草案），API 可能会变化，浏览器支持需要关注（通常需要开启实验性标志）。(写作时基于 2024 年 10 月草案)</li>
<li><strong>滚动/变换行为：</strong> 涉及性能权衡，行为需要理解清楚。</li>
<li><strong>可访问性：</strong> 需要开发者额外关注。</li>
<li><strong>学习曲线：</strong> 虽然入门简单，但回退、滚动等机制需要深入理解。</li>
</ul>
<p>总的来说，Anchor Positioning 描绘了一个美好的未来：开发者可以更专注于内容和语义，把复杂的定位逻辑交还给 CSS。虽然离全面普及还有距离，但了解它、尝试它，绝对能让你在未来的 Web 布局中占得先机。</p>
<p>告别那些为了定位而写的 JS “屎山”吧，拥抱 CSS 的新可能！你觉得这个新特性怎么样？欢迎在评论区留下你的看法！</p>
<hr>
<p>希望这篇模仿张鑫旭老师风格的文章能帮助你理解 CSS Anchor Positioning！记得，实际运用时一定要查阅最新的规范文档和浏览器兼容性信息。</p>
<p>参考文献：</p>
<ol>
<li><a href="https://drafts.csswg.org/css-anchor-position-1/">CSS Anchor Positioning - Editor’s Draft, 12 October 2024</a></li>
</ol> </div> </article>  </div> </main> <aside class="hidden lg:block sticky top-0 h-screen w-64 flex-shrink-0 py-8 pl-8"> <div class="space-y-4"> <div class="rounded-xl border bg-card text-card-foreground shadow"><div class="p-6 pt-0"><ul><li><a href="#入门抛出第一个锚">入门：抛出第一个锚</a></li><li><a href="#进阶让定位更得心应手">进阶：让定位更得心应手</a></li><li><a href="#实战处理真实世界的复杂性">实战：处理真实世界的复杂性</a></li><li><a href="#高级话题作用域隐式锚点">高级话题：作用域、隐式锚点</a></li><li><a href="#别忘了可访问性-accessibility">别忘了可访问性 (Accessibility)</a></li><li><a href="#总结未来已来">总结：未来已来？</a></li></ul></div></div> <div class="rounded-xl border bg-card text-card-foreground shadow"><div class="flex flex-col space-y-1.5 p-6"><div class="font-semibold leading-none tracking-tight">Tags</div></div><div class="p-6 pt-0"><div class="flex flex-wrap gap-2"><a href="/tags/article" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">article</a><a href="/tags/event" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">event</a><a href="/tags/rust" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">rust</a><a href="/tags/iced" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">iced</a><a href="/tags/gui" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">gui</a><a href="/tags/multiplatform" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">multiplatform</a><a href="/tags/mobile" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">mobile</a><a href="/tags/web" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">web</a><a href="/tags/Kotlin" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">Kotlin</a><a href="/tags/linux" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">linux</a><a href="/tags/dns" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">dns</a><a href="/tags/javascript" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">javascript</a><a href="/tags/async" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">async</a><a href="/tags/reactive" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">reactive</a><a href="/tags/html&amp;css" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">html&amp;css</a><a href="/tags/cogitation" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">cogitation</a><a href="/tags/tools" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">tools</a><a href="/tags/efficiency" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">efficiency</a><a href="/tags/trivial" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">trivial</a><a href="/tags/lift" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">lift</a><a href="/tags/C++" class="bg-gray-200 dark:bg-gray-700 rounded-full px-3 py-1 text-sm font-semibold">C++</a></div></div></div> <div class="rounded-xl border bg-card text-card-foreground shadow"><div class="flex flex-col space-y-1.5 p-6"><div class="font-semibold leading-none tracking-tight">Archive</div></div><div class="p-6 pt-0"><ul><li><a href="/archive/2025/09">2025-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2025/06">2025-06<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2025/05">2025-05<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2025/04">2025-04<!-- --> (<!-- -->12<!-- -->)</a></li><li><a href="/archive/2025/03">2025-03<!-- --> (<!-- -->9<!-- -->)</a></li><li><a href="/archive/2024/05">2024-05<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2024/04">2024-04<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/archive/2023/05">2023-05<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2023/04">2023-04<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2023/03">2023-03<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2022/10">2022-10<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2022/04">2022-04<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2021/12">2021-12<!-- --> (<!-- -->3<!-- -->)</a></li><li><a href="/archive/2021/07">2021-07<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2021/04">2021-04<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2020/10">2020-10<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2020/09">2020-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2020/05">2020-05<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2020/04">2020-04<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2020/03">2020-03<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2018/07">2018-07<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2017/10">2017-10<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2017/03">2017-03<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/10">2016-10<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2016/09">2016-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/08">2016-08<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/07">2016-07<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/05">2016-05<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/03">2016-03<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2016/02">2016-02<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2015/02">2015-02<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2014/09">2014-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2014/04">2014-04<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2014/03">2014-03<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2014/02">2014-02<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2014/01">2014-01<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2013/12">2013-12<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2013/10">2013-10<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2013/09">2013-09<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2013/08">2013-08<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2013/07">2013-07<!-- --> (<!-- -->2<!-- -->)</a></li><li><a href="/archive/2013/06">2013-06<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/archive/2013/05">2013-05<!-- --> (<!-- -->4<!-- -->)</a></li></ul></div></div> </div> </aside> </div> <astro-island uid="twXPy" prefix="r12" component-url="/_astro/Footer.DbUwA-sc.js" component-export="default" renderer-url="/_astro/client.D0HLj-jK.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;Footer&quot;,&quot;value&quot;:true}" await-children><footer class="border-t border-zinc-200 dark:border-zinc-700 mt-12 pt-8 pb-12"><div class="flex items-center justify-center space-x-6 text-sm text-zinc-600 dark:text-zinc-400"><a href="https://github.com/gaubee/gaubee.com" target="_blank" rel="noopener noreferrer" class="flex items-center space-x-2 transition-colors hover:text-zinc-900 dark:hover:text-zinc-100"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github" aria-hidden="true"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg><span>Source Code</span></a><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery" target="_blank" rel="noopener noreferrer" class="transition-colors hover:text-zinc-900 dark:hover:text-zinc-100">闽ICP备17026139号-1</a></div></footer><!--astro:end--></astro-island> <astro-island uid="Tziuc" prefix="r13" component-url="/_astro/BackToTop.CO3miaR6.js" component-export="default" renderer-url="/_astro/client.D0HLj-jK.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;BackToTop&quot;,&quot;value&quot;:true}" await-children><button type="button" aria-label="Back to top" class="fixed right-8 bottom-8 z-50 flex h-12 w-12 items-center justify-center rounded-full bg-zinc-900/20 text-white shadow-lg backdrop-blur-sm backdrop-saturate-200 transition-opacity duration-300 hover:bg-zinc-700 dark:bg-zinc-100/20 dark:text-zinc-900 dark:hover:bg-zinc-300 opacity-0"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-up" aria-hidden="true"><path d="m5 12 7-7 7 7"></path><path d="M12 19V5"></path></svg></button><!--astro:end--></astro-island>  </body></html> 