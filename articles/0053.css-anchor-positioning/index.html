<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, article"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>CSS 锚定定位(Anchor Positioning)</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
<link rel="manifest" href="/manifest.webmanifest"><script id="vite-plugin-pwa:register-sw" src="/registerSW.js"></script></head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="target" href="/articles/">Articles</a> <a class="" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="article-wrapper"><main><h1>CSS 锚定定位(Anchor Positioning)</h1><p>今天我们要聊一个 CSS 世界里正在悄然兴起，但可能彻底改变我们布局方式的“大杀器”——<strong>CSS Anchor Positioning</strong>（锚定定位）。</p><p>你有没有遇到过这样的场景？鼠标悬浮在一个按钮上，想弹出一个 tooltip；点击一个输入框，希望下方出现一个建议列表；或者实现一个下拉菜单，它得不偏不倚地对齐触发按钮。</p><p><img src="data:image/webp;base64,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" alt="想象一个按钮和旁边恼人的 tooltip 定位问题"></p><p>在过去，我们是怎么解决的？</p><ol><li><strong>DOM 结构依赖：</strong> 把 tooltip/下拉菜单硬塞到按钮的父元素里，然后用 <code>position: relative/absolute</code> 各种计算。但这要求 DOM 结构必须“配合”，不够灵活。</li><li><strong>JavaScript 大法：</strong> 获取按钮的位置和尺寸 (<code>getBoundingClientRect</code>)，计算 tooltip 应该放哪，监听滚动、窗口大小变化，重新计算... 心智负担重，性能还可能有问题。这感觉就像是为了拧个螺丝，结果造了台挖掘机。</li></ol><p>这些方法都透露着一种“不得已而为之”的无奈。我们只是想让一个元素 <em>相对</em> 于 <em>另一个</em> 元素定位，为什么就这么难？CSS 的 <code>position: absolute</code> 不是相对于包含块吗？如果我的触发元素和定位元素不在一个合适的包含块里，或者我压根不想关心它们的 DOM 结构关系呢？</p><p><strong>Anchor Positioning 的核心哲学：解放定位，打破束缚</strong></p><p>CSS Anchor Positioning 就像给 CSS 定位系统加了个“外挂”。它的核心思想简单粗暴但极其有效：</p><blockquote><p><strong>让一个元素（通常是绝对定位或固定定位的）可以显式地声明它想“锚定”到页面上的一个或多个其他元素，并基于这些“锚点”元素的位置和尺寸来定位或调整自身尺寸，而无需关心它们在 DOM 树中的关系或共同的包含块。</strong></p></blockquote><p>这就像在大海里航行，以前你只能靠附近的灯塔（包含块）定位，现在你可以直接抛锚（anchor）到任何你想停靠的岛屿（任意元素）旁边。这种<strong>解耦</strong>是革命性的：</p><ul><li><strong>DOM 结构自由：</strong> 你的 tooltip、popover 可以放在 <code>&lt;body&gt;</code> 下，或者任何你想放的地方，不再受父子关系的限制。</li><li><strong>CSS 驱动：</strong> 定位逻辑回归 CSS，减少甚至消除对 JS 的依赖，更符合关注点分离原则，性能也可能更好。</li><li><strong>智能避让：</strong> 内建了处理边缘碰撞、自动调整位置（fallback）的机制，让“气泡总在元素旁边，但又不会跑出屏幕”这种需求变得简单。</li></ul><p>听起来是不是很激动人心？别急，我们一步步来看它是怎么施展魔法的。</p><h3>入门：抛出第一个锚</h3><p>想象我们要给一个按钮 <code>.anchor-btn</code> 加一个 tooltip <code>.tooltip</code>。</p><p><strong>第一步：指定谁是锚点 (<code>anchor-name</code>)</strong></p><p>首先，得告诉 CSS，哪个元素是我们的“锚”。这通过 <code>anchor-name</code> 属性完成。它的值需要是 CSS 变量那种 <code>--</code> 开头的“虚线标识符”（dashed-ident）。</p><pre class="language-css"><code class="language-css"><span class="token selector">.anchor-btn</span> <span class="token punctuation">{</span>
  <span class="token comment">/* --my-anchor 就是这个锚点的名字 */</span>
  <span class="token property">anchor-name</span><span class="token punctuation">:</span> --my-anchor<span class="token punctuation">;</span>

  <span class="token comment">/* 其他样式... */</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 10px 20px<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #ccc<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><strong>第二步：设置需要定位的元素</strong></p><p>Tooltip 通常需要脱离文档流，所以我们给它 <code>position: fixed</code> 或 <code>absolute</code>。<code>fixed</code> 更省心，不用担心嵌套层级和 <code>transform</code> 干扰定位基准（虽然 Anchor Positioning 自身对 transform 和 scroll 有特殊处理，后面会提）。</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span> <span class="token comment">/* 或者 absolute */</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #333<span class="token punctuation">;</span>
  <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 5px 10px<span class="token punctuation">;</span>
  <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>
  <span class="token comment">/* 先隐藏，可能通过 JS 或 :hover/:focus 等显示 */</span>
  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><strong>第三步：连接锚点和定位元素 (默认锚点 <code>position-anchor</code>)</strong></p><p>现在，告诉 <code>.tooltip</code>，它默认应该参考哪个锚点。使用 <code>position-anchor</code> 属性。</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>
  <span class="token comment">/* ... 其他样式 ... */</span>

  <span class="token comment">/* 默认情况下，我的位置参考 --my-anchor 这个锚点 */</span>
  <span class="token property">position-anchor</span><span class="token punctuation">:</span> --my-anchor<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><strong>第四步：使用 <code>anchor()</code> 函数定位</strong></p><p>最关键的一步来了！怎么具体定位呢？用 <code>anchor()</code> 函数！这个函数可以用在 <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code> 这些 inset 属性里。</p><p><code>anchor()</code> 函数的基本用法是 <code>anchor(&lt;anchor-side&gt;)</code>。当 <code>position-anchor</code> 设置了默认锚点时，可以省略锚点名字。<code>&lt;anchor-side&gt;</code> 指的是你希望定位元素的哪条边对齐锚点元素的哪条边。</p><p>例如，我们想让 tooltip 的底部（<code>bottom</code>）对齐按钮的顶部（<code>top</code>）：</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>
  <span class="token comment">/* 消除默认 margin 行为，这个很重要，否则会有很多不符合预期的行为 */</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token comment">/* 设置锚定点 */</span>
  <span class="token property">position-anchor</span><span class="token punctuation">:</span> --my-anchor<span class="token punctuation">;</span>
  <span class="token comment">/* ... 其他样式 ... */</span>

  <span class="token comment">/* 让我的 bottom 对齐 默认锚点 的 top */</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token function">anchor</span><span class="token punctuation">(</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 水平方向，让我的左边 对齐 默认锚点 的左边 */</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">anchor</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* 加一点偏移，让 tooltip 在按钮上方一点 */</span>
  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>anchor()</code> 函数里的 <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code> 指的是锚点元素的<strong>边界</strong>。</p><p>还有两个特殊的关键字：<code>inside</code> 和 <code>outside</code>。 <code>inside</code> 指的是与 inset 属性<strong>相同</strong>的边，<code>outside</code> 指的是<strong>相对</strong>的边。</p><p>例如，<code>bottom: anchor(top)</code> 可以理解为： 我要设置 <code>bottom</code> 属性，它的值依赖于锚点的 <code>top</code> 边。</p><p>而 <code>bottom: anchor(outside)</code> 就有点意思了，用在 <code>bottom</code> 属性上时，<code>outside</code> 指的是锚点的 <code>top</code> 边。用在 <code>top</code> 属性上时，<code>outside</code> 指的是锚点的 <code>bottom</code> 边。它表示“贴着锚点的外面”。</p><p>所以，上面的 <code>bottom: anchor(top)</code> 其实更自然的写法是：</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token comment">/* 把我的 top 定位在 锚点 的 bottom (即按钮下方) */</span>
  <span class="token comment">/* top: anchor(bottom); */</span>

  <span class="token comment">/* 或者，让我的 bottom 定位在 锚点 的 top (即按钮上方) */</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token function">anchor</span><span class="token punctuation">(</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* 水平居中？可以让 tooltip 的中线对齐锚点的中线 */</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">anchor</span><span class="token punctuation">(</span>center<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateX</span><span class="token punctuation">(</span>-50%<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* CSS经典居中 */</span>

  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token comment">/* 向上偏移 */</span>
<span class="token punctuation">}</span></code></pre><p><code>anchor()</code> 还可以接受百分比，<code>anchor(50%)</code> 或 <code>anchor(center)</code> 都代表锚点对应轴向的中心线。</p><pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anchor-btn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hover Me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltip<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>I'm a tooltip!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p><img src="/assets/tooltip-above-center-DtgGYqxz.webp" alt="基础锚定定位效果"></p><p>是不是很简单？没有 JS，没有复杂的 DOM 嵌套，CSS 自己搞定了！</p><h3>进阶：让定位更得心应手</h3><p><code>anchor()</code> 函数很强大，但每次都要写 <code>top</code>/<code>left</code> 有点繁琐。Anchor Positioning 提供了一些“语法糖”和增强功能。</p><p><strong>1. <code>position-area</code>：九宫格布局</strong></p><p>这是个超级方便的属性。它把锚点元素和它的“可用空间”（通常是视口或其包含块）想象成一个 3x3 的网格。你可以直接指定 tooltip 应该占据哪个格子。</p><p><img src="/assets/position-area-grid-CMk6YsfI.webp" alt="position-area 的 3x3 网格示意图"> (来自规范草案的图)</p><p>它的值可以是类似 <code>block-start</code>（块轴起点，通常是顶部）, <code>inline-end</code>（行轴终点，通常是右侧）, <code>center</code> 这样的关键字组合。</p><p>例如，把 tooltip 放在按钮上方居中，可以这样写：</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>
  <span class="token property">position-anchor</span><span class="token punctuation">:</span> --my-anchor<span class="token punctuation">;</span>
  <span class="token comment">/* ... 其他样式 ... */</span>

  <span class="token comment">/* 区域：块轴起点(top)，行轴中间(center) */</span>
  <span class="token property">position-area</span><span class="token punctuation">:</span> block-start center<span class="token punctuation">;</span>
  <span class="token comment">/* 默认对齐方式通常就不错，也可以用 align-self/justify-self 微调 */</span>
<span class="token punctuation">}</span></code></pre><p>想放右边中间？<code>position-area: center inline-end;</code> 想放左下角？<code>position-area: block-end inline-start;</code></p><p>它甚至支持跨越多行/列，如 <code>span-block-start</code> (从中间跨越到顶部)。</p><p><strong>2. <code>anchor-center</code>：居中对齐的新选择</strong></p><p>对于 <code>align-self</code> 和 <code>justify-self</code>，增加了一个新值 <code>anchor-center</code>。当使用 <code>position-area</code> 或希望在某个轴向上精确地对齐锚点的中心时，这个值非常有用。</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token property">position-area</span><span class="token punctuation">:</span> block-start<span class="token punctuation">;</span> <span class="token comment">/* 放在上方区域 */</span>
  <span class="token property">justify-self</span><span class="token punctuation">:</span> anchor-center<span class="token punctuation">;</span> <span class="token comment">/* 水平方向对齐锚点中心 */</span>
<span class="token punctuation">}</span></code></pre><p><strong>3. <code>anchor-size()</code>：尺寸向锚点看齐</strong></p><p>有时候，我们希望定位元素的尺寸能跟随锚点变化。比如，下拉菜单的宽度应该和触发按钮一样宽。<code>anchor-size()</code> 函数应运而生！</p><pre class="language-css"><code class="language-css"><span class="token selector">.dropdown-menu</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>
  <span class="token property">position-anchor</span><span class="token punctuation">:</span> --my-trigger<span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token function">anchor</span><span class="token punctuation">(</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token function">anchor</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* 让我的宽度等于 --my-trigger 锚点的宽度 */</span>
  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">anchor-size</span><span class="token punctuation">(</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 或者用逻辑轴 */</span>
  <span class="token comment">/* width: anchor-size(inline); */</span>

  <span class="token comment">/* 高度也可以 */</span>
  <span class="token comment">/* max-height: anchor-size(height) * 3; */</span>
<span class="token punctuation">}</span></code></pre><p><code>anchor-size()</code> 可以用在 <code>width</code>, <code>height</code>, <code>min-*</code>, <code>max-*</code> 等属性中，可以引用 <code>width</code>, <code>height</code>, <code>block</code>, <code>inline</code> (逻辑轴) 等。</p><h3>实战：处理真实世界的复杂性</h3><p>理想很丰满，现实很骨感。如果 tooltip 放在按钮上方会超出屏幕怎么办？如果滚动页面，锚点跑了，tooltip 会不会留在原地发呆？</p><p><strong>1. 边缘碰撞与回退 (<code>position-try-fallbacks</code>, <code>@position-try</code>)</strong></p><p>这是 Anchor Positioning 的精髓之一！当默认的定位方式导致元素溢出其容器（通常是视口）时，它可以自动尝试备选方案。</p><ul><li><p><strong>内置回退策略 (<code>flip-block</code>, <code>flip-inline</code>, <code>flip-start</code>)</strong>: <code>position-try-fallbacks</code> 属性可以接受一些关键字，比如 <code>flip-block</code> 会尝试在块轴方向翻转（比如从上翻到下），<code>flip-inline</code> 则在行轴方向翻转（从左到右）。</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token property">position-area</span><span class="token punctuation">:</span> block-start<span class="token punctuation">;</span> <span class="token comment">/* 默认放上面 */</span>
  <span class="token comment">/* 如果上面放不下，尝试块级翻转（放到下面） */</span>
  <span class="token property">position-try-fallbacks</span><span class="token punctuation">:</span> flip-block<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></li><li><p><strong>自定义回退规则 (<code>@position-try</code>)</strong>: 你可以定义具名的回退样式集。</p><pre class="language-css"><code class="language-css"><span class="token atrule"><span class="token rule">@position-try</span> --fallback-bottom</span> <span class="token punctuation">{</span>
  <span class="token property">position-area</span><span class="token punctuation">:</span> block-end<span class="token punctuation">;</span> <span class="token comment">/* 尝试放下面 */</span>
  <span class="token comment">/* 可以定义更多样式调整 */</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> lightcoral<span class="token punctuation">;</span> <span class="token comment">/* 比如换个背景色提示 */</span>
<span class="token punctuation">}</span>

<span class="token atrule"><span class="token rule">@position-try</span> --fallback-right</span> <span class="token punctuation">{</span>
  <span class="token property">position-area</span><span class="token punctuation">:</span> inline-end<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token property">position-area</span><span class="token punctuation">:</span> block-start<span class="token punctuation">;</span> <span class="token comment">/* 默认放上面 */</span>
  <span class="token comment">/* 尝试顺序：先用 --fallback-bottom 规则，再尝试行内翻转，再用 --fallback-right 规则 */</span>
  <span class="token property">position-try-fallbacks</span><span class="token punctuation">:</span> --fallback-bottom<span class="token punctuation">,</span> flip-inline<span class="token punctuation">,</span> --fallback-right<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></li><li><p><strong>回退顺序 (<code>position-try-order</code>)</strong>: 默认按 <code>position-try-fallbacks</code> 列表顺序尝试。但有时你希望优先选择<strong>空间更大</strong>的回退位置，可以用 <code>most-width</code>, <code>most-height</code>, <code>most-block-size</code>, <code>most-inline-size</code>。</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token property">position-try-fallbacks</span><span class="token punctuation">:</span> --try-top<span class="token punctuation">,</span> --try-bottom<span class="token punctuation">,</span> --try-left<span class="token punctuation">,</span> --try-right<span class="token punctuation">;</span>
  <span class="token comment">/* 优先选择高度最大的位置 */</span>
  <span class="token property">position-try-order</span><span class="token punctuation">:</span> most-height<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></li></ul><p><strong>2. 滚动与变换：性能与行为的权衡</strong></p><p>这是一个复杂但重要的话题。如果锚点在可滚动区域内，或者被 <code>transform</code> 了，定位元素怎么办？</p><ul><li><strong>基本原则：</strong> 为了性能，浏览器通常<strong>不会</strong>在滚动或 <code>transform</code> 改变时频繁重新计算锚点元素的精确布局。</li><li><strong>记住滚动偏移 (<code>remembered scroll offset</code>)：</strong> 浏览器会在某个时间点（比如元素首次显示或回退策略改变时）“记住”锚点相对于定位元素的滚动容器的滚动偏移量。后续定位会基于这个记住的值。</li><li><strong>默认锚点的特权：</strong> 如果定位元素只依赖<strong>默认锚点</strong> (<code>position-anchor</code> 指定的那个)，并且满足特定条件（比如用了 <code>anchor-center</code> 或 <code>position-area</code>），浏览器<strong>可以</strong>在滚动时<strong>平移</strong>定位元素，让它跟随默认锚点移动。这是一种性能友好的“补偿”(<code>compensate for scroll</code>)。</li><li><strong>多锚点或非默认锚点：</strong> 如果你用了多个 <code>anchor()</code> 指向不同滚动容器的锚点，或者依赖非默认锚点，滚动时它们的位置可能就不再精确跟随了（只跟随非滚动部分的移动）。</li><li><strong><code>transform</code> 的影响：</strong> 规范草案目前提到，默认情况下，锚点上的 <code>transform</code> <strong>不影响</strong> <code>anchor()</code> 函数的计算结果（Issue 1）。这可能会在未来改变。</li></ul><p>简单说：尽量让你的主要定位逻辑依赖默认锚点，可以获得更好的滚动跟随效果。对于复杂的多锚点场景，滚动时的行为可能没那么“实时”。</p><p><strong>3. 条件隐藏 (<code>position-visibility</code>)</strong></p><p>有时候，如果锚点无效、不可见，或者即使尝试了所有回退方案，定位元素仍然溢出，我们可能希望直接隐藏它。<code>position-visibility</code> 属性就是干这个的。</p><pre class="language-css"><code class="language-css"><span class="token selector">.tooltip</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token comment">/* 默认值是 anchors-visible，如果锚点不可见（比如被滚动隐藏了）就自动隐藏 */</span>
  <span class="token comment">/* position-visibility: anchors-visible; */</span>

  <span class="token comment">/* 如果所有回退都试过后还溢出，就隐藏 */</span>
  <span class="token property">position-visibility</span><span class="token punctuation">:</span> no-overflow<span class="token punctuation">;</span>

  <span class="token comment">/* 如果有必须的锚点（比如 anchor() 没提供 fallback 值）无效，就隐藏 */</span>
  <span class="token comment">/* position-visibility: anchors-valid; */</span>

  <span class="token comment">/* 组合使用 */</span>
  <span class="token property">position-visibility</span><span class="token punctuation">:</span> anchors-valid no-overflow<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h3>高级话题：作用域、隐式锚点</h3><ul><li><p><strong><code>anchor-scope</code>：避免命名冲突</strong> 在组件化开发中，如果你在列表的每个 <code>&lt;li&gt;</code> 里都用了 <code>anchor-name: --item-anchor</code>，那所有 <code>&lt;li&gt;</code> 里的定位元素都会锚定到<strong>最后一个</strong> <code>&lt;li&gt;</code> 上！<code>anchor-scope</code> 可以限制锚点名称的查找范围。</p><pre class="language-css"><code class="language-css"><span class="token selector">li</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 这个锚点名字只在 li 内部及其后代中有效 */</span>
  <span class="token property">anchor-name</span><span class="token punctuation">:</span> --item-anchor<span class="token punctuation">;</span>
  <span class="token property">anchor-scope</span><span class="token punctuation">:</span> --item-anchor<span class="token punctuation">;</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span> <span class="token comment">/* 创建层叠上下文可能也有帮助 */</span>
<span class="token punctuation">}</span>
<span class="token selector">li .popup</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token property">position-anchor</span><span class="token punctuation">:</span> --item-anchor<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token function">anchor</span><span class="token punctuation">(</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span></code></pre></li><li><p><strong>隐式锚点 (<code>auto</code>)</strong> 某些 HTML API（比如未来的 Popover API）可能会自动建立锚定关系。比如，触发 popover 的按钮自动成为该 popover 的“隐式锚点”。这时，你可以用 <code>position-anchor: auto;</code> 或者在 <code>anchor()</code>/<code>anchor-size()</code> 中省略锚点名来引用它。</p></li></ul><h3>别忘了可访问性 (Accessibility)</h3><p>重要的事情说三遍：Anchor Positioning 是<strong>纯视觉</strong>的！它在视觉上把两个元素关联起来，但<strong>不会</strong>自动建立它们之间的语义联系。</p><p>屏幕阅读器等辅助技术无法理解这种视觉关联。所以，你必须：</p><ul><li>使用 <code>aria-describedby</code>, <code>aria-details</code> 等 ARIA 属性，在 HTML 中明确两者关系。</li><li>确保合理的焦点管理和键盘导航。</li></ul><p>好消息是，像 Popover API 这样的原生 HTML 功能，在提供隐式锚点的同时，通常也会处理好相关的可访问性问题。</p><h3>总结：未来已来？</h3><p>CSS Anchor Positioning 无疑是近年来 CSS 布局领域最激动人心的提案之一。它直击了 Web 开发中长期存在的定位痛点，提供了一种更声明式、更灵活、更强大的解决方案。</p><p><strong>优点：</strong></p><ul><li><strong>DOM 解耦：</strong> 布局不再受限于 HTML 结构。</li><li><strong>CSS 驱动：</strong> 减少 JS 依赖，代码更清晰。</li><li><strong>智能回退：</strong> 内建边缘检测和位置调整。</li><li><strong>强大灵活：</strong> <code>anchor()</code>, <code>anchor-size()</code>, <code>position-area</code> 提供了丰富的控制。</li></ul><p><strong>注意事项/挑战：</strong></p><ul><li><strong>新规范：</strong> 目前仍是 Editor's Draft（编辑草案），API 可能会变化，浏览器支持需要关注（通常需要开启实验性标志）。(写作时基于 2024 年 10 月草案)</li><li><strong>滚动/变换行为：</strong> 涉及性能权衡，行为需要理解清楚。</li><li><strong>可访问性：</strong> 需要开发者额外关注。</li><li><strong>学习曲线：</strong> 虽然入门简单，但回退、滚动等机制需要深入理解。</li></ul><p>总的来说，Anchor Positioning 描绘了一个美好的未来：开发者可以更专注于内容和语义，把复杂的定位逻辑交还给 CSS。虽然离全面普及还有距离，但了解它、尝试它，绝对能让你在未来的 Web 布局中占得先机。</p><p>告别那些为了定位而写的 JS &quot;屎山&quot;吧，拥抱 CSS 的新可能！你觉得这个新特性怎么样？欢迎在评论区留下你的看法！</p><hr><p>希望这篇模仿张鑫旭老师风格的文章能帮助你理解 CSS Anchor Positioning！记得，实际运用时一定要查阅最新的规范文档和浏览器兼容性信息。</p><p>参考文献：</p><ol><li><a href="https://drafts.csswg.org/css-anchor-position-1/">CSS Anchor Positioning - Editor’s Draft, 12 October 2024</a></li></ol></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>