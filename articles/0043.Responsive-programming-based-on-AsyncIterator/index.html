<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, article, javascript, async, reactive"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>基于AsyncIterator的响应式编程</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
<link rel="manifest" href="/manifest.webmanifest"><script id="vite-plugin-pwa:register-sw" src="/registerSW.js"></script></head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="target" href="/articles/">Articles</a> <a class="" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="article-wrapper"><main><h1>基于AsyncIterator的响应式编程</h1><p>最近在重新思考响应式编程的一些事情，其实我很少使用 RxJS，往往是直接手撸各种异步策略。 因为我自己是更加倾向于使用原生的 async-await/generaor 来实现。因为会有更好的调式支持，性能也会更好。但可维护性可能就不一定，如果没有好好封装，别人读代码的时候，就会比较晦涩。 虽然 RxJS 在开始的时候也是晦涩，但是至少他们的高级的概念能够很好的复用。 而像我这种直接手撸的就往往是按照需求来进行编程，阅读者如果对需求没有足够的理解，那这种代码的可维护性可以说是相对比较低的。</p><p>但最近有打算把 RxJS 的一些常见概念和我自己的经验结合起来，写一个基于异步迭代器的响应式编程的库。 这篇文章就简单的讲一下这个库里头涉及到的一些有趣的经验点。</p><p>首先就是我异步编程时最常使用的 PromiseOut，它是对 promise 的再封装</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">class</span> <span class="token class-name">PromiseOut<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span>
  resolve<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">;</span>
  reject<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">;</span>
  promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>reject <span class="token operator">=</span> reject<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><blockquote><p>这是一个缩略版的 PromiseOut 代码，完整版的代码过段时间会放出来。（我司开源的相关工作还是推进中，主要是在做一个 typescript 项目管理标准，替代 monorepo……）</p></blockquote><p>它的用法自然也很简单，就是把 Promise 的控制器对外暴露：</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> po <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromiseOut<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">await</span> po<span class="token punctuation">.</span>promise<span class="token punctuation">;</span></code></pre><p>接着我们正式来聊聊异步迭代器与响应式编程。 不知道大家记不记得，现在 nodejs/web，对于<code>socket.on(&quot;data&quot;)</code>这种有了一种新的写法： <code>for await(const chunk of socket)</code>。 这里我们就实现一个简易版的，来看这段代码：</p><pre class="language-ts"><code class="language-ts"><span class="token comment">/**
 * 订阅器
 * 提供一个流式的变更触发
 * 等价于 EventEmitter
 * 这里提供基于流式编程的书写方法
 */</span>
<span class="token keyword">interface</span> <span class="token class-name">Sub</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * 如果是 true，说明已经发生修改，只是这个改变还没有被拾取
   * 如果是 false，说明改变已经被拾取
   * 如果是 PromiseOut，说明有控制器在等待它
   */</span>
  changed<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> PromiseOut<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> _subs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set<span class="token operator">&lt;</span>Sub<span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*触发修改*/</span>
  <span class="token function">emitChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> sub <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果有等待中的控制器，那么唤醒它</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token keyword">instanceof</span> <span class="token class-name">PromiseOut</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sub<span class="token punctuation">.</span>changed<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 修改状态值：有改变</span>
      sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/**
   * 执行订阅
   */</span>
  async <span class="token operator">*</span><span class="token function">subscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> sub<span class="token operator">:</span> Sub <span class="token operator">=</span> <span class="token punctuation">{</span> changed<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      <span class="token comment">/// 如果是 true 那么就重置成 false</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span><span class="token punctuation">;</span> <span class="token comment">/// 异步迭代器暂停，将控制权转交给外部迭代者</span>
      <span class="token punctuation">}</span>
      <span class="token comment">/// 暂停期间可能会被修改成 true（调用了emitChanged）</span>
      <span class="token comment">/// 如果还是 false，说明期间没有发生任何修改</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个控制器并等待它被唤醒</span>
        <span class="token keyword">await</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromiseOut<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>promise<span class="token punctuation">;</span>
        sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>现在代码的核心逻辑就是以上这些了，但那段代码是不完整的，因为很明显，<code>Demo._subs: Set&lt;Sub&gt;</code>这个对象只有<code>add</code>，没有<code>delete</code>，所以需要再加上内存释放的逻辑才够完整。</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> sub <span class="token operator">=</span> <span class="token punctuation">{</span> changed<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 核心代码 */</span>
  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>不熟悉 AsyncGenerator 的人可能会觉得奇怪，那“核心代码”里头根本没有<code>break</code>、<code>return</code>等关键字，那<code>do-while(true)</code>能跑出来吗？ 答案是：能，你可以将<code>yield</code>的关键字理解成是注入外部的代码，类似于函数调用。同时，外部还能有两个特殊的控制函数：<code>asyncGenerator.return</code>和<code>asyncGenerator.throw</code>。所以只要外部调用了<code>asyncGenerator.return</code>，那么<code>finally</code>块的代码就能被执行。 比如这段代码：</p><pre class="language-ts"><code class="language-ts"><span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> changed <span class="token keyword">of</span> demo<span class="token punctuation">.</span><span class="token function">subscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在我们最常用的<code>for-await</code>循环中，只要退出了循环，不论是用<code>break</code>、<code>throw</code>、<code>return</code>，都会触发<code>asyncGenerator.return</code>；</p><p>好了，至此你觉得上面这段代码完事了吗？ 答案是：没有。 看这句代码：</p><pre class="language-ts"><code class="language-ts"><span class="token comment">// 创建一个控制器并等待它被唤醒</span>
<span class="token keyword">await</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromiseOut<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>promise<span class="token punctuation">;</span></code></pre><p>这个 promise 如果一直没有处于 pending 状态，那么<code>asyncGenerator.return</code>或者<code>asyncGenerator.throw</code>并不会无缘无故地将之释放掉。 也就是说<code>finally</code>的代码一定要等到下一次<code>emitChanged</code>触发的时候，<code>promiseOut</code>被<code>resolved</code>，之后还要再次进入循环，执行到<code>yield</code>字段这里跳出来。同时被<code>for-await</code>这时候才会真的跳出来 以下这段代码可以简单复现这个问题：</p><pre class="language-ts"><code class="language-ts"><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 一秒后执行 emitChanged</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  demo<span class="token punctuation">.</span><span class="token function">emitChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> _ <span class="token keyword">of</span> demo<span class="token punctuation">.</span><span class="token function">subscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 执行 asyncGenerator.return，但不会马上跳出循环</span>
<span class="token punctuation">}</span>
<span class="token comment">// 等待一秒后，这句日志才会被打印</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"demo._subs.size"</span><span class="token punctuation">,</span> demo<span class="token punctuation">.</span>_subs<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所以要怎么解决这个问题呢？很简单，我们需要重写<code>asyncGenerator.return</code>函数：</p><pre class="language-ts"><code class="language-ts"><span class="token comment">/**
 * 一个特殊的中断信号
 */</span>
<span class="token keyword">const</span> <span class="token constant">ABORT_SIGNAL</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"abort-signal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> async <span class="token operator">*</span><span class="token function">_subscription</span><span class="token punctuation">(</span>sub<span class="token operator">:</span> Sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 核心代码 */</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!==</span> <span class="token constant">ABORT_SIGNAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/*将原有的subscription方法改成私有，且sub对象由外部传入*/</span>
  <span class="token punctuation">}</span>
  <span class="token function">subscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> sub<span class="token operator">:</span> Sub <span class="token operator">=</span> <span class="token punctuation">{</span> changed<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> subject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_subscription</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/// 重写 return 函数，确保能够直接地释放掉这个订阅</span>
    <span class="token keyword">const</span> _return <span class="token operator">=</span> subject<span class="token punctuation">.</span>return<span class="token punctuation">;</span>
    subject<span class="token punctuation">.</span><span class="token function-variable function">return</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token keyword">instanceof</span> <span class="token class-name">PromiseOut</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sub<span class="token punctuation">.</span>changed<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">ABORT_SIGNAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token function">_return</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">/// 同样的，需要重写 throw 函数</span>
    <span class="token keyword">const</span> _throw <span class="token operator">=</span> subject<span class="token punctuation">.</span>throw<span class="token punctuation">;</span>
    subject<span class="token punctuation">.</span><span class="token function-variable function">throw</span> <span class="token operator">=</span> <span class="token punctuation">(</span>err<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token keyword">instanceof</span> <span class="token class-name">PromiseOut</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sub<span class="token punctuation">.</span>changed<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token function">_throw</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> subject<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>至此，基于<code>AsyncGenerator</code>的这个事件流就基本开发完成了。 如果你已经能理解以上的代码，那么接下来需要进阶的，其实就是<code>ReadableStream</code>，它同样提供了一个控制器，来用更加统一的方式易懂来实现以上代码中<code>PromiseOut</code>的作用。同时它还有背压的功能，这对于传统的基于事件驱动编程在程序的健壮性上是一个质变的存在，正如<code>try-catch</code>对于错误处理的重要性一样。这篇文章就不对此展开描述了。</p></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>