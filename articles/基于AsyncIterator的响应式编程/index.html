<!doctype html><html lang=zh-CN><meta charset=utf-8><title>基于AsyncIterator的响应式编程 · Gaubee</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/css/main.css rel=stylesheet><link href=/webmanifest.json rel=manifest><meta content=#ec407a name=theme-color><link href=/articles.atom rel=alternate title="Gaubee's Articles Atom feed" type=application/atom+xml><link href=/events.atom rel=alternate title="Gaubee's Events Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><header id=header><h1><a href=/ >Gaubee</a></h1><a href=#navigation-toggle id=nav-toggle>显示导航 Show navigation</a><nav><ul><li><a href=/ >主页 Home</a><li class=current><a href=/articles>文章 Articles</a><li><a href=/events>小事件 Events</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>基于AsyncIterator的响应式编程</h1><p class=meta>发布于 <time datetime=5/10/2013 itemprop=datePublished>5/10/2013</time> · 最后修改时间 <time datetime=5/10/2013 itemprop=dateModified>5/10/2013</time> · 标签： <a href=/blog/tags/javascript class=tag>javascript</a> <a href=/blog/tags/async class=tag>async</a> <a href=/blog/tags/reactive class=tag>reactive</a></header><div itemprop=articleBody><p>最近在重新思考响应式编程的一些事情，其实我很少使用 RxJS，往往是直接手撸各种异步策略。<br>因为我自己是更加倾向于使用原生的 async-await/generaor 来实现。因为会有更好的调式支持，性能也会更好。但可维护性可能就不一定，如果没有好好封装，别人读代码的时候，就会比较晦涩。<br>虽然 RxJS 在开始的时候也是晦涩，但是至少他们的高级的概念能够很好的复用。<br>而像我这种直接手撸的就往往是按照需求来进行编程，阅读者如果对需求没有足够的理解，那这种代码的可维护性可以说是相对比较低的。<p>但最近有打算把 RxJS 的一些常见概念和我自己的经验结合起来，写一个响应式编程的库。<br>这篇文章就简单的讲一下这个库里头涉及到的一些有趣的经验点。<p>首先就是我异步编程时最常使用的 PromiseOut，它是对 promise 的再封装<pre class=language-ts><code class=language-ts><span class="token keyword">class</span> <span class="token class-name">PromiseOut<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span> <span class="token punctuation">{</span><br>  resolve<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">;</span><br>  reject<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">;</span><br>  promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>reject <span class="token operator">=</span> reject<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><blockquote><p>这是一个缩略版的 PromiseOut 代码，完整版的代码过段时间会放出来。（我司开源的相关工作还是推进中，主要是在做一个 typescript 项目管理标准，替代 monorepo……）</blockquote><p>它的用法自然也很简单，就是把 Promise 的控制器对外暴露：<pre class=language-ts><code class=language-ts><span class="token keyword">const</span> po <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromiseOut<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">await</span> po<span class="token punctuation">.</span>promise<span class="token punctuation">;</span></code></pre><p>接着我们正式来聊聊异步迭代器与响应式编程。<br>不知道大家记不记得，现在 nodejs/web，对于<code>socket.on("data")</code>这种有了一种新的写法：<br><code>for await(const chunk of socket)</code>。<br>这里我们就实现一个简易版的，来看这段代码：<pre class=language-ts><code class=language-ts><span class="token comment">/**<br> * 订阅器<br> * 提供一个流式的变更触发<br> * 等价于 EventEmitter<br> * 这里提供基于流式编程的书写方法<br> */</span><br><span class="token keyword">interface</span> <span class="token class-name">Sub</span> <span class="token punctuation">{</span><br>  <span class="token comment">/**<br>   * 如果是 true，说明已经发生修改，只是这个改变还没有被拾取<br>   * 如果是 false，说明改变已经被拾取<br>   * 如果是 PromiseOut，说明有控制器在等待它<br>   */</span><br>  changed<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> PromiseOut<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span><br>  <span class="token keyword">private</span> _subs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set<span class="token operator">&lt;</span>Sub<span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">/*触发修改*/</span><br>  <span class="token function">emitChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> sub <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token comment">// 如果有等待中的控制器，那么唤醒它</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token keyword">instanceof</span> <span class="token class-name">PromiseOut</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        sub<span class="token punctuation">.</span>changed<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token comment">// 修改状态值：有改变</span><br>      sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token comment">/**<br>   * 执行订阅<br>   */</span><br>  async <span class="token operator">*</span><span class="token function">subscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> sub<span class="token operator">:</span> Sub <span class="token operator">=</span> <span class="token punctuation">{</span> changed<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">do</span> <span class="token punctuation">{</span><br>      <span class="token comment">/// 如果是 true 那么就重置成 false</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><br>        <span class="token keyword">yield</span><span class="token punctuation">;</span> <span class="token comment">/// 异步迭代器暂停，将控制权转交给外部迭代者</span><br>      <span class="token punctuation">}</span><br>      <span class="token comment">/// 暂停期间可能会被修改成 true（调用了emitChanged）</span><br>      <span class="token comment">/// 如果还是 false，说明期间没有发生任何修改</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">// 创建一个控制器并等待它被唤醒</span><br>        <span class="token keyword">await</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromiseOut<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>promise<span class="token punctuation">;</span><br>        sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>现在代码的核心逻辑就是以上这些了，但那段代码是不完整的，因为很明显，<code>Demo._subs:&lt;Set&lt;Sub>></code>这个对象只有<code>add</code>，没有<code>delete</code>，所以需要再加上内存释放的逻辑才够完整。<pre class=language-ts><code class=language-ts><span class="token keyword">const</span> sub <span class="token operator">=</span> <span class="token punctuation">{</span> changed<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">try</span> <span class="token punctuation">{</span><br>  <span class="token keyword">do</span> <span class="token punctuation">{</span><br>    <span class="token comment">/* 核心代码 */</span><br>  <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span><br>  <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>不熟悉 AsyncGenerator 的人可能会觉得奇怪，那“核心代码”里头根本没有<code>break</code>、<code>return</code>等关键字，那<code>do-while(true)</code>能跑出来吗？<br>答案是：能，你可以将<code>yield</code>的关键字理解成是注入外部的代码，类似于函数调用。同时，外部还能有两个特殊的控制函数：<code>asyncGenerator.return</code>和<code>asyncGenerator.throw</code>。所以只要外部调用了<code>asyncGenerator.return</code>，那么<code>finally</code>块的代码就能被执行。<br>比如这段代码：<pre class=language-ts><code class=language-ts><span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> changed <span class="token keyword">of</span> demo<span class="token punctuation">.</span><span class="token function">subscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">throw</span><span class="token punctuation">;</span><br>    <span class="token keyword">break</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>在我们最常用的<code>for-await</code>循环中，只要退出了循环，不论是用<code>break</code>、<code>throw</code>、<code>return</code>，都会触发<code>asyncGenerator.return</code>；<p>好了，至此你觉得上面这段代码完事了吗？<br>答案是：没有。<br>看这句代码：<pre class=language-ts><code class=language-ts><span class="token comment">// 创建一个控制器并等待它被唤醒</span><br><span class="token keyword">await</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PromiseOut<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>promise<span class="token punctuation">;</span></code></pre><p>这个 promise 如果一直没有处于 pending 状态，那么<code>asyncGenerator.return</code>或者<code>asyncGenerator.throw</code>并不会无缘无故地将之释放掉。<br>也就是说<code>finally</code>的代码一定要等到下一次<code>emitChanged</code>触发的时候，才会到 yield 字段这里跳出来。同时被<code>for-await</code>这时候才会真的跳出来<br>以下这段代码可以简单复现这个问题：<pre class=language-ts><code class=language-ts><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// 一秒后执行 emitChanged</span><br><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  demo<span class="token punctuation">.</span><span class="token function">emitChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> _ <span class="token keyword">of</span> demo<span class="token punctuation">.</span><span class="token function">subscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 执行 asyncGenerator.return，但不会马上跳出循环</span><br><span class="token punctuation">}</span><br><span class="token comment">// 等待一秒后，这句日志才会被打印</span><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"demo._subs.size"</span><span class="token punctuation">,</span> demo<span class="token punctuation">.</span>_subs<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所以要怎么解决这个问题呢？很简单，我们需要重写<code>asyncGenerator.return</code>函数：<pre class=language-ts><code class=language-ts><span class="token comment">/**<br> * 一个特殊的中断信号<br> */</span><br><span class="token keyword">const</span> <span class="token constant">ABORT_SIGNAL</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"abort-signal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span><br>  <span class="token keyword">private</span> async <span class="token operator">*</span><span class="token function">_subscription</span><span class="token punctuation">(</span>sub<span class="token operator">:</span> Sub<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">try</span> <span class="token punctuation">{</span><br>      <span class="token comment">/* 核心代码 */</span><br>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!==</span> <span class="token constant">ABORT_SIGNAL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">throw</span> err<span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span><br>      <span class="token keyword">this</span><span class="token punctuation">.</span>_subs<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token comment">/*将原有的subscription方法改成私有，且sub对象由外部传入*/</span><br>  <span class="token punctuation">}</span><br>  <span class="token function">subscription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> sub<span class="token operator">:</span> Sub <span class="token operator">=</span> <span class="token punctuation">{</span> changed<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">const</span> subject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_subscription</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token comment">/// 重写 return 函数，确保能够直接地释放掉这个订阅</span><br>    <span class="token keyword">const</span> _return <span class="token operator">=</span> subject<span class="token punctuation">.</span>return<span class="token punctuation">;</span><br>    subject<span class="token punctuation">.</span><span class="token function function-variable">return</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token keyword">instanceof</span> <span class="token class-name">PromiseOut</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        sub<span class="token punctuation">.</span>changed<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token constant">ABORT_SIGNAL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token keyword">return</span> <span class="token function">_return</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token comment">/// 同样的，需要重写 throw 函数</span><br>    <span class="token keyword">const</span> _throw <span class="token operator">=</span> subject<span class="token punctuation">.</span>throw<span class="token punctuation">;</span><br>    subject<span class="token punctuation">.</span><span class="token function function-variable">throw</span> <span class="token operator">=</span> <span class="token punctuation">(</span>err<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>sub<span class="token punctuation">.</span>changed <span class="token keyword">instanceof</span> <span class="token class-name">PromiseOut</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        sub<span class="token punctuation">.</span>changed<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token keyword">return</span> <span class="token function">_throw</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>subject<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token keyword">return</span> subject<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>至此，基于 AsyncGenerator 的这个事件流就基本开发完成了。<br>如果你已经能理解以上的代码，那么接下来需要进阶的，其实就是<code>ReadableStream</code>，它同样提供了一个控制器，来用更加统一的方式易懂来实现以上代码中 <code>PromiseOut</code> 的作用。<br>但二者的本质是一样的，这篇文章我不对此展开描述。</div><footer></footer></article></main><footer id=footer><div><nav><a href=https://twitter.com/gaubeebangeel rel="me nofollow" target=_blank>Twitter</a> · <a href=https://github.com/gaubee/gaubee.com/tree/main/./src/articles/基于AsyncIterator的响应式编程.md rel=nofollow target=_blank>Edit this page on GitHub</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>除非有特别的说明, 该站点所有直接内容都使用许可证：<a href=https://creativecommons.org/licenses/by/4.0/deed.zh>署名 4.0 国际 (CC BY 4.0)</a></small><blockquote><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用</small></blockquote></footer><script src=/js/dark-mode-toggle.mjs type=module></script><script src=/js/time-elements.mjs type=module></script><script src=/js/main.mjs type=module></script>