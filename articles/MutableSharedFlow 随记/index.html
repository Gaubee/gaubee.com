<!doctype html><html lang=zh-CN><meta charset=utf-8><title>MutableSharedFlow 随记 · Gaubee</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/css/main.css rel=stylesheet><link href=/webmanifest.json rel=manifest><meta content=#ec407a name=theme-color><link href=/articles.atom rel=alternate title="Gaubee's Articles Atom feed" type=application/atom+xml><link href=/events.atom rel=alternate title="Gaubee's Events Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><header id=header><h1><a href=/ >Gaubee</a></h1><a href=#navigation-toggle id=nav-toggle>显示导航 Show navigation</a><nav><ul><li><a href=/ >主页 Home</a><li class=current><a href=/articles>文章 Articles</a><li><a href=/events>小事件 Events</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>MutableSharedFlow 随记</h1><p class=meta>发布于 <time datetime=4/5/2024 itemprop=datePublished>4/5/2024</time> · 最后修改时间 <time datetime=4/5/2024 itemprop=dateModified>4/5/2024</time> · 标签： <a href=/blog/tags/kotlin class=tag>Kotlin</a></header><div itemprop=articleBody><p>MutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。<br>因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。<br>举个例子：<pre class=language-kotlin><code class=language-kotlin><span class="token keyword">val</span> sharedFlow <span class="token operator">=</span> MutableSharedFlow<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
launch <span class="token punctuation">{</span>
    sharedFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token comment">// 这里通常不会有任何打印</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
sharedFlow<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。<br>这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。<hr><p>因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。<hr><p>最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。<br>但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。<br>这个方案唯一的好处就是代码量相对比较少。<hr><p>还有一种方案是使用 Channel：<pre class=language-kotlin><code class=language-kotlin><span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">val</span> sharedFlow <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">consumeAsFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">shareIn</span><span class="token punctuation">(</span><span class="token function">currentCoroutineContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SharingStarted<span class="token punctuation">.</span>Lazily<span class="token punctuation">)</span>
launch <span class="token punctuation">{</span>
    sharedFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token comment">// 这里通常不会有任何打印</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>这个方案其实是创建了一个 Channel，两个 Flow。<br>其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。<br>第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。<p>这个方案只能说勉勉强强达到我们的需求，但问题也很多：<ol><li>它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。<li>flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 <code>launch sharedFlow.collect</code> ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。<blockquote><p>这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:<pre class=language-kotlin><code class=language-kotlin><span class="token keyword">val</span> channel <span class="token operator">=</span> Channel<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> MAX <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
launch <span class="token punctuation">{</span>
  <span class="token comment">/// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token function">println</span><span class="token punctuation">(</span><span class="token singleline string-literal"><span class="token string">"start send"</span></span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span>MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    channel<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token singleline string-literal"><span class="token string">"send(</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">$</span><span class="token expression">i</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">val</span> flow <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">receiveAsFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">shareIn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SharingStarted<span class="token punctuation">.</span>Lazily<span class="token punctuation">)</span>
launch <span class="token punctuation">{</span>
  flow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token singleline string-literal"><span class="token string">"collect1(</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">$</span><span class="token expression">it</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
launch <span class="token punctuation">{</span>
  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>
  flow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token singleline string-literal"><span class="token string">"collect2(</span><span class="token interpolation"><span class="token punctuation interpolation-punctuation">$</span><span class="token expression">it</span></span><span class="token string">)"</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></blockquote><li>这里用 consumeAsFlow 还是 receiveAsFlow 都一样</ol><hr><p>但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手：<br>试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。<br>其实标准做法是这样的：<pre class=language-kotlin><code class=language-kotlin><span class="token keyword">val</span> sharedFlow <span class="token operator">=</span> MutableSharedFlow<span class="token operator">&lt;</span>Int<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onSubscription</span> <span class="token punctuation">{</span>
    sharedFlow<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
launch <span class="token punctuation">{</span>
    sharedFlow<span class="token punctuation">.</span><span class="token function">collect</span> <span class="token punctuation">{</span>
        <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token comment">// 这里通常不会有任何打印</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。<hr></div><footer></footer></article></main><footer id=footer><div><nav><a href=https://twitter.com/gaubeebangeel rel="me nofollow" target=_blank>Twitter</a> · <a href="https://github.com/gaubee/gaubee.com/tree/main/./src/articles/MutableSharedFlow 随记.md" rel=nofollow target=_blank>Edit this page on GitHub</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>除非有特别的说明, 该站点所有直接内容都使用许可证：<a href=https://creativecommons.org/licenses/by/4.0/deed.zh>署名 4.0 国际 (CC BY 4.0)</a></small><blockquote><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用</small> <small style=display:block><a href=https://beian.mps.gov.cn/#/query/webSearch>闽ICP备17026139号-1</a></small></blockquote></footer><script src=/js/dark-mode-toggle.mjs type=module></script><script src=/js/time-elements.mjs type=module></script><script src=/js/main.mjs type=module></script>