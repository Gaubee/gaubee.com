<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, article"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>View Transitions API (Level-1 single-document)</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
<link rel="manifest" href="/manifest.webmanifest"><script id="vite-plugin-pwa:register-sw" src="/registerSW.js"></script></head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="target" href="/articles/">Articles</a> <a class="" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="article-wrapper"><main><h1>View Transitions API (Level-1 single-document)</h1><p>今天咱们来聊一个前端圈儿里越来越火的新玩意儿——CSS View Transitions。这东西就好比给你的网页换场加了个丝滑的电影转场特效，告别过去那种生硬的“啪嗒”一下切换页面的体验。</p><p>W3C 的大佬们捣鼓出的这个 <a href="https://www.w3.org/TR/css-view-transitions-1/">CSS View Transitions Module Level 1</a> 规范，目前已经是 CR（Candidate Recommendation）阶段，说明离咱们大规模用上不远了。咱们的目标是彻底搞懂它，从“这啥玩意儿？”到“哦豁，有点意思”再到“爷青回，这动画我自己写！”。</p><h2>一、告别刀耕火种：View Transitions 要解决啥蛋疼问题？</h2><p>想想以前，尤其是在 SPA（单页应用）里搞页面切换动画，那叫一个折腾：</p><ol><li><strong>DOM 大乱炖</strong>：为了让新旧两个状态能同时存在并产生动画效果（比如旧的淡出，新的淡入），你可能得手动控制 DOM，让两个页面的内容在某个时间段内都挂在页面上。这 DOM 结构，简直是为了动画效果“牺牲色相”，乱七八糟。</li><li><strong>JS 胶水代码</strong>：得写一堆 JavaScript 来协调 DOM 的增删、CSS class 的切换、动画的开始结束监听。逻辑复杂，还容易出 bug。</li><li><strong>性能与体验</strong>：DOM 结构复杂了，性能可能受影响；动画过程中，焦点管理、可访问性（ARIA）也容易出问题，用户体验可能打折。比如动画过程中，屏幕阅读器是读旧的还是新的？按钮能点吗？</li></ol><p><strong>核心痛点</strong>：<strong>视觉过渡效果</strong> 和 <strong>DOM 状态更新</strong> 这两件事，在过去是紧密耦合、互相掣肘的。为了视觉效果，我们不得不扭曲 DOM 结构和更新逻辑。</p><h2>二、View Transitions 的核心思想与哲学：解耦！分离！</h2><p>W3C 的大佬们说：“不行，这太 low 了！咱们得想个办法把这两件事分开！”</p><p>于是，View Transitions 的核心哲学诞生了：</p><p><strong>将视觉层面的过渡动画 与 DOM 结构和数据的更新彻底分离。</strong></p><p>怎么分离呢？想象一下：</p><ol><li><strong>DOM 更新？瞬间完成！</strong> 你该怎么更新 DOM 还怎么更新，别管动画的事儿。调用 API 后，你的更新代码（比如 React 的 <code>setState</code>，Vue 的数据修改，或者原生 JS 操作）会立即或异步执行，DOM 状态瞬间变成新的。</li><li><strong>视觉过渡？交给浏览器！</strong> 在你更新 DOM 的前后，浏览器会像个摄影师，“咔嚓”给旧状态拍张照，“咔嚓”给新状态拍张照（这里的“照片”是渲染层面的快照，不是真的图片文件）。</li><li><strong>幕后动画师</strong>：浏览器拿到这两张“照片”后，在一个特殊的、凌驾于普通内容之上的图层里，基于这两张快照玩起了动画。默认是简单的交叉淡入淡出（cross-fade）。旧“照片”慢慢消失，新“照片”慢慢显现。</li><li><strong>动画结束，收工！</strong> 动画播完，这个特殊的图层和里面的“照片”就被清理掉了，用户看到的就是真实的新 DOM 状态。</li></ol><p><strong>好处显而易见：</strong></p><ul><li><strong>DOM 干净</strong>：你的 DOM 结构永远反映真实的应用状态，不用为了动画而妥协。</li><li><strong>关注点分离</strong>：JS 只管数据和 DOM 更新，CSS/Web Animations API 只管动画表现。清爽！</li><li><strong>体验更佳</strong>：因为 DOM 更新是（逻辑上）瞬时的，底层的状态切换更快，可访问性问题也更容易处理。动画只是一个视觉增强层。</li><li><strong>渐进增强</strong>：如果浏览器不支持 View Transitions，或者因为某些原因（如用户设置了减弱动态效果）动画无法执行，你的 DOM 更新逻辑依然会照常运行，页面还是能正常切换，只是没动画而已。完美符合渐进增强的理念。</li></ul><h2>三、上手初体验：<code>document.startViewTransition</code> 登场！</h2><p>说了半天理论，上代码！最最核心的入口就是 <code>document</code> 对象上的新方法 <code>startViewTransition()</code>。</p><pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 假设你原来是这么更新内容的</span>
<span class="token keyword">function</span> <span class="token function">updateContent</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 一顿操作猛如虎，更新 DOM ...</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"DOM 更新完毕！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 现在想加上过渡动画？改成这样：</span>
<span class="token keyword">function</span> <span class="token function">navigate</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断浏览器是否支持</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>document<span class="token punctuation">.</span>startViewTransition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"浏览器不支持 View Transitions，直接更新"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">updateContent</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 调用 startViewTransition ！</span>
  <span class="token keyword">const</span> transition <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">startViewTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 这个回调函数里，放你原来的 DOM 更新逻辑</span>
    <span class="token function">updateContent</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这个回调函数可以是同步的，也可以返回一个 Promise</span>
    <span class="token comment">// 如果返回 Promise，浏览器会等 Promise resolve 后再拍“新照片”</span>
    <span class="token comment">// return new Promise(resolve => setTimeout(resolve, 1000));</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// transition 对象后面会讲，它包含一些有用的 Promise</span>
  transition<span class="token punctuation">.</span>finished<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"过渡动画播放完毕！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 触发导航</span>
<span class="token function">navigate</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">content</span><span class="token operator">:</span> <span class="token string">"新的页面内容"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>发生了什么？</strong></p><ol><li>调用 <code>startViewTransition()</code>，浏览器：“收到！准备拍旧照片！”</li><li>浏览器拍下当前页面的<strong>旧状态快照</strong>。</li><li>浏览器执行你传入的那个回调函数 <code>() =&gt; updateContent(data)</code>。</li><li>你的 <code>updateContent</code> 函数执行，DOM 瞬间变成了新状态。</li><li>（如果回调返回 Promise，浏览器会等它 resolve）浏览器：“OK，DOM 更新完了，拍新照片！”</li><li>浏览器拍下当前页面的<strong>新状态快照</strong>。</li><li>浏览器在幕后创建一个特殊的<strong>伪元素树</strong>（后面细讲），把旧快照和新快照放进去。</li><li>浏览器应用默认的 CSS 动画（交叉淡入淡出）到这些伪元素上。</li><li>动画开始播放。用户看到旧内容淡出，新内容淡入。</li><li>动画结束。</li><li>浏览器清理掉伪元素树。</li><li><code>transition.finished</code> Promise resolve。</li></ol><p>就这么简单，一个基础的页面交叉淡入淡出效果就有了！你几乎没改动原来的 DOM 更新逻辑，只是把它包了一层 <code>startViewTransition</code>。</p><p><strong><code>ViewTransition</code> 对象：你的动画小助手</strong></p><p><code>startViewTransition</code> 返回一个 <code>ViewTransition</code> 对象，它有几个重要的属性（都是 Promise）：</p><ul><li><code>updateCallbackDone</code>: 当你传入的回调函数执行完毕（如果是 Promise，则 resolve）时，这个 Promise 就 resolve。表示 DOM 更新逻辑本身已经跑完了。</li><li><code>ready</code>: 当浏览器准备好新旧快照，并且创建了用于动画的伪元素、即将开始动画时，这个 Promise 就 resolve。如果你想用 JavaScript (Web Animations API) 来控制更复杂的动画，这是最佳时机。</li><li><code>finished</code>: 当整个过渡动画播放完毕，并且伪元素被清理后，这个 Promise 就 resolve。表示一切都结束了，用户看到的是最终的新状态。</li></ul><p>还有一个方法：</p><ul><li><code>skipTransition()</code>: 调用这个方法可以立即跳过动画，直接显示最终状态。这在某些情况下（比如用户快速连续点击）可能有用。</li></ul><h2>四、深入幕后：揭秘伪元素树</h2><p>前面提到，浏览器在幕后创建了一个“伪元素树”来承载动画。这棵树长啥样？</p><pre><code>::view-transition                    (根节点，覆盖整个视口)
└─ ::view-transition-group(name)     (每个独立过渡元素的“分组”)
   └─ ::view-transition-image-pair(name) (新旧快照的“容器对”)
      ├─ ::view-transition-old(name)   (旧状态快照的“图片”)
      └─ ::view-transition-new(name)   (新状态快照的“图片”)
</code></pre><ul><li><code>::view-transition</code>: 整个过渡效果的根容器，通常固定定位，覆盖整个快照区域（Snapshot Containing Block，一般是整个视口）。</li><li><code>::view-transition-group(name)</code>: 代表一个<strong>独立进行过渡的视觉区域</strong>。默认情况下，整个页面是一个匿名的 <code>root</code> 分组。如果你给某个元素指定了 <code>view-transition-name</code>，那么这个元素就会拥有自己的具名分组。这个 group 负责模拟原始元素的大小和位置，并且默认会在这两个状态之间进行动画。</li><li><code>::view-transition-image-pair(name)</code>: 包裹新旧两个快照的容器。它的主要作用是提供一个隔离环境（<code>isolation: isolate</code>），确保新旧快照的混合模式（blend mode）只影响它们俩，不影响外部。</li><li><code>::view-transition-old(name)</code>: 承载旧状态快照的伪元素。你可以把它想象成一个 <code>&lt;img&gt;</code> 标签，内容是旧页面的样子。</li><li><code>::view-transition-new(name)</code>: 承载新状态快照的伪元素。同上，内容是新页面的样子。</li></ul><p><strong>关键点</strong>：</p><ul><li><code>name</code> 通常是 <code>root</code>（代表整个页面），或者是你通过 CSS 的 <code>view-transition-name</code> 属性给元素指定的名字。</li><li>默认情况下，只有 <code>::view-transition-group(root)</code> 这一个分组。</li><li>浏览器提供了一套<strong>用户代理样式表 (UA Stylesheet)</strong>，给这些伪元素加上了默认样式和动画，实现了那个默认的交叉淡入淡出效果。</li><li><code>::view-transition-old(root)</code> 代表着 startViewTransition 开始之前的页面快照（截图）</li><li><code>::view-transition-new(root)</code> 代表着当前 document.documentElement 元素，它被当成快照使用。在这个期间，你实时去续改 dom 的样式，就是直接反应在 <code>::view-transition-new(root)</code> 这个快照上。<ul><li>也就是说，其实你的整个 document.documentElement 已经变成一个快照元素了，如果你隐藏了 <code>::view-transition</code>（opacity:0），你会发现整个 document.documentElement 都不见了，其实是灯下黑，它就是挂载在 <code>::view-transition-new(root)</code> 里头。同时因为处于快照模式，DOM 的交互实现现在完全无法响应。</li></ul></li><li>如果你通过<code>view-transition-name: name</code> 去定义一个 Element，那么等同于这个元素被剥离出来，独立成一个图层来渲染。<ul><li>如果这个 name 在<code>::view-transition-new(root)</code>中存在，那么它会被抽出来作为<code>::view-transition-new(name)</code>进行渲染，否则那么就默认使用<code>::view-transition-old(name)</code>复制成<code>::view-transition-new(name)</code></li><li>也就是说，这时候有两个层叠在一起的元素<code>::view-transition-old(name)</code>和<code>::view-transition-new(name)</code>，默认情况下，前者会做淡出动画，后者会做淡入动画。因此你可以拿着这两个元素分别搞事情，从而实现复杂的动画效果。</li><li>以上同时二者被包含在 <code>::view-transition-image-pair(name)</code> 下面，同时 <code>::view-transition-image-pair(name)</code> 被包含在<code>::view-transition-group(name)</code>下面。目前 group 下面只有一个 image-pair 对象，之所以要设计成两层。是因为 image-pair 负责提供 <code>isolation: isolate</code>，然后 group 负责提供几何变 —— 即位置（transform）、尺寸（width, height）从旧状态到新状态的动画。</li><li>这里是因为 <code>isolation: isolate</code> 局限性，导致不得不分成两层。首先对于其作用，这里不展开细说，目的就是为了更好的前后过渡的混合效果</li><li>然后是如果将 image-pair 和 group 合并成一个行不行？答案是：不行。我们先假设如果分开，你可以在 group 上做背景色，而不会被 image-pair 所影响。因为<code>new</code>和<code>old</code>的 mix-blend-mode 只会干扰到 image-pair 就终止了。如果合成一个，那么背景色就会被参与到混合中去。</li><li>这里给一个例子 <a href="https://appn.dwewb.com/examples/kitchen-sink/isolation-isolate/">Isolation Demo</a></li></ul></li></ul><h2>五、定制你的专属转场：CSS 大显身手</h2><p>默认的淡入淡出太普通？没问题！既然是伪元素，我们就可以用 CSS 来定制它们的样式和动画！</p><p><strong>1. 改变默认动画时长或效果 (针对整个页面 root)</strong></p><pre class="language-css"><code class="language-css"><span class="token comment">/* 让默认的交叉淡入淡出变慢一点 */</span>
<span class="token selector">::view-transition-old(root),
::view-transition-new(root)</span> <span class="token punctuation">{</span>
  <span class="token property">animation-duration</span><span class="token punctuation">:</span> 0.5s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 自定义动画：比如，旧的向左滑出并淡出，新的从右滑入并淡入 */</span>
<span class="token atrule"><span class="token rule">@keyframes</span> slide-to-left</span> <span class="token punctuation">{</span>
  <span class="token selector">to</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateX</span><span class="token punctuation">(</span>-30px<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token atrule"><span class="token rule">@keyframes</span> slide-from-right</span> <span class="token punctuation">{</span>
  <span class="token selector">from</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateX</span><span class="token punctuation">(</span>30px<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector">::view-transition-old(root)</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> 300ms <span class="token function">cubic-bezier</span><span class="token punctuation">(</span>0.4<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 1<span class="token punctuation">,</span> 1<span class="token punctuation">)</span> both slide-to-left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">::view-transition-new(root)</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> 300ms <span class="token function">cubic-bezier</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 0.2<span class="token punctuation">,</span> 1<span class="token punctuation">)</span> 90ms both slide-from-right<span class="token punctuation">;</span> <span class="token comment">/* 延迟一点出现 */</span>
<span class="token punctuation">}</span></code></pre><p><strong>2. 让特定元素动起来：<code>view-transition-name</code></strong></p><p>想让页面上的某个卡片、头像、标题单独动起来？给它一个名字！</p><pre class="language-css"><code class="language-css"><span class="token comment">/* HTML 里有个卡片 */</span>
<span class="token comment">/* &lt;div class="card detailed-card">...&lt;/div> */</span>

<span class="token comment">/* CSS 里给它命名 */</span>
<span class="token selector">.detailed-card</span> <span class="token punctuation">{</span>
  <span class="token property">view-transition-name</span><span class="token punctuation">:</span> detailed-card<span class="token punctuation">;</span> <span class="token comment">/* 起个名字，必须唯一！ */</span>
  <span class="token property">contain</span><span class="token punctuation">:</span> layout<span class="token punctuation">;</span> <span class="token comment">/* 建议加上 contain，帮助浏览器优化 */</span>
<span class="token punctuation">}</span></code></pre><p>一旦你给元素加了 <code>view-transition-name</code>：</p><ul><li>浏览器会为这个 <code>detailed-card</code> 创建<strong>单独的</strong> <code>::view-transition-group(detailed-card)</code>、<code>::view-transition-image-pair(detailed-card)</code> 等伪元素。</li><li>这个元素在旧状态和新状态的快照会被单独截取。</li><li><code>::view-transition-group(detailed-card)</code> 会自动从旧元素的位置/大小<strong>动画过渡</strong>到新元素的位置/大小。</li><li><code>::view-transition-old(detailed-card)</code> 和 <code>::view-transition-new(detailed-card)</code> 默认还是会进行<strong>交叉淡入淡出</strong>。</li></ul><p>你可以像上面修改 <code>root</code> 一样，针对 <code>detailed-card</code> 这个名字来定制动画：</p><pre class="language-css"><code class="language-css"><span class="token selector">::view-transition-group(detailed-card)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 可以改变 group 的动画，比如弹跳效果 */</span>
  <span class="token property">animation-timing-function</span><span class="token punctuation">:</span> <span class="token function">cubic-bezier</span><span class="token punctuation">(</span>0.5<span class="token punctuation">,</span> 1.5<span class="token punctuation">,</span> 0.5<span class="token punctuation">,</span> 1.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">::view-transition-old(detailed-card)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 比如让旧卡片直接消失，不淡出 */</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
  <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">::view-transition-new(detailed-card)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 比如让新卡片从下面飞入 */</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> 300ms ease-out both slide-from-bottom<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token atrule"><span class="token rule">@keyframes</span> slide-from-bottom</span> <span class="token punctuation">{</span>
  <span class="token selector">from</span> <span class="token punctuation">{</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateY</span><span class="token punctuation">(</span>50px<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p><strong>重要提示</strong>：<code>view-transition-name</code> 的值在<strong>同一时刻</strong>必须是唯一的。如果在拍快照时发现有两个元素用了同一个名字，整个 View Transition 过程会失败（但 DOM 更新还是会执行）。</p><p><strong>3. 处理进入和离开动画 (使用 <code>:only-child</code>)</strong></p><p>有时候，某个元素只在新状态或旧状态存在（比如一个侧边栏导航只在某些页面有）。这时 <code>::view-transition-image-pair</code> 里就只有一个孩子 (<code>::view-transition-old</code> 或 <code>::view-transition-new</code>)。我们可以利用 CSS 的 <code>:only-child</code> 伪类来专门处理这种情况：</p><pre class="language-css"><code class="language-css"><span class="token selector">.sidebar</span> <span class="token punctuation">{</span>
  <span class="token property">view-transition-name</span><span class="token punctuation">:</span> sidebar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 侧边栏进入动画 (新状态有，旧状态没有) */</span>
<span class="token selector">::view-transition-new(sidebar):only-child</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> slide-in 300ms ease-out<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 侧边栏离开动画 (旧状态有，新状态没有) */</span>
<span class="token selector">::view-transition-old(sidebar):only-child</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> slide-out 300ms ease-in<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 如果新旧状态都有侧边栏，默认的 group 位置/大小动画 + image-pair 淡入淡出可能就够了， */</span>
<span class="token comment">/* 或者你也可以单独为这种情况写动画 (不加 :only-child) */</span></code></pre><h2>六、更骚的操作：JavaScript 动画 (Web Animations API)</h2><p>CSS 动画很方便，但对于某些交互性强、需要动态计算的动画（比如规范里的那个鼠标点击位置圆形展开的例子），JavaScript 就派上用场了。</p><p>最佳时机是等待 <code>transition.ready</code> Promise resolve 之后：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">navigateWithCircularReveal</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> clickEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>document<span class="token punctuation">.</span>startViewTransition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">updateContent</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 获取点击位置</span>
  <span class="token keyword">const</span> x <span class="token operator">=</span> clickEvent<span class="token operator">?.</span>clientX <span class="token operator">??</span> window<span class="token punctuation">.</span>innerWidth <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> y <span class="token operator">=</span> clickEvent<span class="token operator">?.</span>clientY <span class="token operator">??</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token comment">// 计算到最远角的距离作为最终半径</span>
  <span class="token keyword">const</span> endRadius <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">hypot</span><span class="token punctuation">(</span>
    Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> window<span class="token punctuation">.</span>innerWidth <span class="token operator">-</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> window<span class="token punctuation">.</span>innerHeight <span class="token operator">-</span> y<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> transition <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">startViewTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">updateContent</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 等待伪元素准备好</span>
  transition<span class="token punctuation">.</span>ready<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 Web Animations API</span>
    document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// 动画目标：从点击位置的小圆变成覆盖全屏的大圆</span>
        <span class="token literal-property property">clipPath</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">circle(0px at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>y<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
          <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">circle(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>endRadius<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>y<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">px)</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token literal-property property">duration</span><span class="token operator">:</span> <span class="token number">500</span><span class="token punctuation">,</span>
        <span class="token literal-property property">easing</span><span class="token operator">:</span> <span class="token string">"ease-in"</span><span class="token punctuation">,</span>
        <span class="token comment">// 关键：指定动画作用在哪个伪元素上！</span>
        <span class="token literal-property property">pseudoElement</span><span class="token operator">:</span> <span class="token string">"::view-transition-new(root)"</span><span class="token punctuation">,</span> <span class="token comment">// 让新内容以圆形揭示出来</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>在这个例子里，我们还需要修改一下 CSS，阻止默认的淡入淡出，并让新旧内容直接叠加：</p><pre class="language-css"><code class="language-css"><span class="token comment">/* 禁用默认动画 */</span>
<span class="token selector">::view-transition-old(root),
::view-transition-new(root)</span> <span class="token punctuation">{</span>
  <span class="token property">animation</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 让新旧内容直接叠加，由 clip-path 控制谁可见 */</span>
<span class="token selector">::view-transition-image-pair(root)</span> <span class="token punctuation">{</span>
  <span class="token property">isolation</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span> <span class="token comment">/* 如果不需要混合模式，可以设为 auto */</span>
<span class="token punctuation">}</span>

<span class="token selector">::view-transition-new(root)</span> <span class="token punctuation">{</span>
  <span class="token property">mix-blend-mode</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span> <span class="token comment">/* 确保 JS 动画时混合模式正常 */</span>
  <span class="token property">z-index</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span> <span class="token comment">/* 确保新内容在上面，被 clip-path 控制 */</span>
<span class="token punctuation">}</span>

<span class="token selector">::view-transition-old(root)</span> <span class="token punctuation">{</span>
  <span class="token property">mix-blend-mode</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>
  <span class="token property">z-index</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h2>七、注意事项与最佳实践</h2><ol><li><strong><code>view-transition-name</code> 唯一性</strong>：再强调一次，非常重要！</li><li><strong><code>contain: layout</code> / <code>content-visibility: hidden</code></strong>：对于指定了 <code>view-transition-name</code> 的元素，加上 <code>contain: layout;</code> 或类似的 CSS（如 <code>contain: strict;</code> 或 <code>content-visibility: hidden;</code> 如果适用）可以帮助浏览器更好地隔离该元素的布局和渲染，提升性能。浏览器只需要知道这个元素的大小和位置，内部细节在快照时再处理。</li><li><strong>过渡是增强</strong>：时刻记住 View Transitions 是锦上添花。即使动画失败或被跳过，核心功能（DOM 更新）也应该能正常工作。</li><li><strong>性能考量</strong>：虽然浏览器会做优化，但截取快照、创建伪元素、运行动画还是有成本的。对于非常复杂的页面或大量的独立过渡元素，要注意测试性能。避免给太多小元素指定 <code>view-transition-name</code>。</li><li><strong>快照内容</strong>：快照是渲染结果，包括 CSS 绘制的背景、伪元素内容等。但不包括 <code>&lt;iframe&gt;</code> 内部的内容（除非同源）或某些插件内容。</li><li><strong>调试</strong>：现代浏览器的开发者工具（如 Chrome DevTools）已经开始支持调试 View Transitions，可以检查伪元素树、查看应用的动画等。</li></ol><h2>八、总结</h2><p>CSS View Transitions 绝对是近年来 Web 平台最令人兴奋的新特性之一。它精准地抓住了前端开发中关于页面切换动画的痛点，提供了一种优雅、高效且符合渐进增强理念的解决方案。</p><p>其核心在于<strong>分离 DOM 更新与视觉过渡</strong>，通过<strong>快照</strong>和<strong>伪元素树</strong>，让浏览器接管了繁琐的过渡动画协调工作，开发者只需要：</p><ol><li>用 <code>document.startViewTransition</code> 包裹你的 DOM 更新逻辑。</li><li>（可选）用 <code>view-transition-name</code> 标记需要独立动画的元素。</li><li>（可选）用 CSS 或 JavaScript (Web Animations API) 定制伪元素的动画效果。</li></ol><p>从此，打造原生 App 般丝滑的页面转场不再是难事。赶紧去试试吧，让你的网页也“纵享丝滑”！</p><p><strong>参考资料：</strong></p><ul><li><a href="https://www.w3.org/TR/css-view-transitions-1/">W3C CSS View Transitions Module Level 1 Spec</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API">MDN 文档: View Transitions API</a></li><li><a href="https://developer.chrome.com/docs/web-platform/view-transitions/same-document">Same-document view transitions for single-page applications</a></li><li><a href="https://github.com/demarketed/view-transitions-polyfill">github.com/demarketed/view-transitions-polyfill</a></li><li><a href="https://caniuse.com/view-transitions"><code>caniuse View Transitions API (single-document)</code></a><ul><li>chrome 111+</li><li>safari 18.0+</li></ul></li></ul></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>