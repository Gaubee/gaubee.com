<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, article, javascript, tools"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>JS的心灵契约——Mide-Pact.js一个简洁又异常强大的Key-Value管理器</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
</head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="target" href="/articles/">Articles</a> <a class="" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="article-wrapper"><main><h1>JS的心灵契约——Mide-Pact.js一个简洁又异常强大的Key-Value管理器</h1><h1>前言</h1><p><a href="https://gist.github.com/Gaubee/e32b0001413d641b224c1f9c9d359161">mind-pact.js</a> 这个东西，以前做过，但是做得不够好，而且是整合在以前开发的MVVM框架里头，作为Model层。 这两天整理了一下，凝练了核心的思想。</p><p>这个库，是一个key-value管理器。简单的说就是：</p><pre class="language-js"><code class="language-js">model<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"a.b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
model<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{ b:1 }</span></code></pre><p><strong>最重要的特性：支持表达式</strong>：</p><pre class="language-js"><code class="language-js">model<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a['b']"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span></code></pre><p>但我们知道JS的表达式里头是可以支持函数的定义等等的，这里做了一定的限制，但又不会失去灵活性，具体看如下API描述：</p><h1>API 文档</h1><h2>MP(basedata)</h2><ul><li><strong>basedata</strong> (<em>except Primitive values</em>) : 除了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Primitive_values">Primitive values</a> 以外的任意对象</li></ul><h2>MP.prototype.set(paths, value, context)</h2><ul><li><strong>paths</strong> (<em>string</em>) : <s>懒得描述</s></li><li><strong>value</strong> (<em>any</em>) : <s>懒得描述</s></li><li><strong>context</strong> (<em>object | null</em>) : 表达式的上下文对象，具体怎么用后面描述</li></ul><h2>MP.prototype.get(paths, context)</h2><ul><li><strong>paths</strong> (<em>string</em>) : <s>懒得描述</s></li><li><strong>context</strong> (<em>object | null</em>) : 表达式的上下文对象，具体怎么用后面描述</li></ul><p>这里说一下这个<strong>context</strong>对象的作用把。就是前面说到的“JS的表达式里头是可以支持函数的定义等等的，这里做了一定的限制，但又不会失去灵活性”的一个解决方案，比如说：</p><pre class="language-js"><code class="language-js"><span class="token comment">// 原始表达式</span>
a<span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token comment">// 提取出function部分后变成：</span>
a<span class="token operator">+</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>b
<span class="token comment">//context就是提取出来的对象：</span>
context <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">foo</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>如何深入去用我就不多说了</p><h2>MP.CustomType(getter [, setter])</h2><blockquote><p>自定义数据类型</p></blockquote><ul><li><strong>getter</strong> (<em>string| [string,any] | function($cur_key, $pre_path_str, $full_path_str)</em>) : 支持三种格式：字符串表达式、字符串表达式+上下文，函数</li><li><strong>setter</strong> (<em>string| [string,any] | function($cur_key, $new_value, $pre_path_str, $full_path_str)</em>) : <em>此参数可空</em></li></ul><p>自定义数据类型，为什么不直接使用JS内置的Getter、Setter呢？这个自定义类型的优势如下：</p><ol><li>支持字符串，而且是<strong>鸭子类型</strong>的数据，这就意味着可以序列化，使用JSON来传递这个动态数据的Getter、Setter。</li><li>更为丰富的上下文信息，JS原始的setter、getter是只能知道自己的this对象，而CustomType在运行getter、setter可以知道自己所在的调用时的具体路径</li></ol><p>值得注意的是这里的表达式会比<code>MP.prototype.get/set</code>中的表达式更为强大，因为内置了一些关键字。这里统一讲一下关键字：</p><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">支持get/set</th><th style="text-align:center">支持CustomType的getter/setter</th><th style="text-align:center">描述</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">__vm</td><td style="text-align:center">√/√</td><td style="text-align:center">√/√</td><td style="text-align:center">model实例对象本身</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">__context</td><td style="text-align:center">√/√</td><td style="text-align:center">√/√</td><td style="text-align:center">上下文对象</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">__global</td><td style="text-align:center">√/√</td><td style="text-align:center">√/√</td><td style="text-align:center">全局对象</td><td style="text-align:center">浏览器环境中指向window</td></tr><tr><td style="text-align:center">$cur_key</td><td style="text-align:center">×/×</td><td style="text-align:center">√/√</td><td style="text-align:center">当前对象所在this中的key</td><td style="text-align:center">a.b.c = CustomType( * , * )，这里指向的就是&quot;c&quot;</td></tr><tr><td style="text-align:center">$pre_path_str</td><td style="text-align:center">×/×</td><td style="text-align:center">√/√</td><td style="text-align:center"><em>看备注</em></td><td style="text-align:center">上述条件，这里指向&quot;a.b&quot;</td></tr><tr><td style="text-align:center">$full_path_str</td><td style="text-align:center">×/×</td><td style="text-align:center">√/√</td><td style="text-align:center"><em>看备注</em></td><td style="text-align:center">上述条件，这里指向&quot;a.b.c&quot;</td></tr><tr><td style="text-align:center">$cur_value</td><td style="text-align:center">×/×</td><td style="text-align:center">√/×</td><td style="text-align:center">当前缓存值</td><td style="text-align:center">初始化是null，每运行一次getter都会被更新</td></tr><tr><td style="text-align:center">$new_value</td><td style="text-align:center">×/×</td><td style="text-align:center">×/√</td><td style="text-align:center">setter所要赋予的值</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$old_value</td><td style="text-align:center">×/×</td><td style="text-align:center">×/√</td><td style="text-align:center">当前缓存值</td><td style="text-align:center">同$cur_value，只是这里只能在setter中使用</td></tr></tbody></table><p>所以围绕这些关键字，来实现一个基础的CustomType对象，就是<code>fullName=firstName lastName</code>。 实现代码如下： <strong>版本1</strong></p><blockquote><p>这个是单纯的getter，简单直观，但是问题在于&quot;me.&quot;这个写死在表达式中了，就意味着如果这个数据发生迁移或者复制到其它地方，就会运行出现问题。</p></blockquote><pre class="language-js"><code class="language-js">m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"me"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">firstname</span><span class="token operator">:</span> <span class="token string">"Gaubee"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">lastname</span><span class="token operator">:</span> <span class="token string">"Bangeel"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">fullname</span><span class="token operator">:</span> <span class="token function">CustomType</span><span class="token punctuation">(</span><span class="token string">"me.firstname+' '+me.lastname"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>版本2</strong></p><blockquote><p>这里用到了<code>__vm</code>与<code>$pre_path_str</code>两个关键字，其中<code>$pre_path_str</code>用来替代版本1中的&quot;me.&quot;，然后由于使用了<code>$pre_path_str</code>关键字，解析就不会用<code>__vm.get(*)</code>自动包裹这个关键字，所以需要手动添加这段代码，结果如下：</p></blockquote><pre class="language-js"><code class="language-js">m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"me"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">firstname</span><span class="token operator">:</span> <span class="token string">"Gaubee"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">lastname</span><span class="token operator">:</span> <span class="token string">"Bangeel"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">fullname</span><span class="token operator">:</span> <span class="token function">CustomType</span><span class="token punctuation">(</span><span class="token string">"__vm.get($pre_path_str+'.firstname')+' '+__vm.get($pre_path_str+'.lastname')"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>版本3</strong></p><blockquote><p>这里实现了Setter，要值得注意的是，setter的表达式里头，多个语句的分割是<code>,</code>而不是<code>;</code>，因为这个单个表达式，简而言之就是解析是把表达式处理成<code>return *</code>，所以如果使用<code>;</code>就会导致<code>;</code>后面的语句不运行（PS：<strong>不要利用这点来实现局部变量的定义，虽然var声明会自动前置，但是请使用context来声明局部变量，否则如果变量名不在context中，会被直接包裹成<code>__vm.get(key)</code>进行处理</strong>）。另外值得注意的是这里表达式最后返回是<code>null</code>，如果返回<code>null/undefined/false</code>，那么就意味着$new_value最后是存储到默认的缓存中；如果返回的不是空值，那么就会被当成是路径，直接将$new_value赋值到这个路径所指定的对象中。</p></blockquote><pre class="language-js"><code class="language-js">m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"me"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">firstname</span><span class="token operator">:</span> <span class="token string">"Gaubee"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">lastname</span><span class="token operator">:</span> <span class="token string">"Bangeel"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">fullname</span><span class="token operator">:</span> <span class="token function">CustomType</span><span class="token punctuation">(</span><span class="token string">"__vm.get($pre_path_str+'.firstname')+' '+__vm.get($pre_path_str+'.lastname')"</span><span class="token punctuation">,</span>
        <span class="token string">"($new_value=$new_value.split(' ')),\
        __vm.set($pre_path_str+'.firstname',$new_value[0]),\
        __vm.set($pre_path_str+'.lastname',$new_value[1]),\
        null"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h1>技术实现细节</h1><blockquote><p>这部分是讲到一些效率优化、解析处理等实现细节。</p></blockquote><h2>1</h2><p>因为不是以往的<code>a.b.c</code>这样耿直的用<code>.</code>来分割了，而MP涉及到表达式，即便用了缓存，如果遇到数组<code>a.1</code>~<code>a.1000</code>，那么缓存还有用么？ 这个是在开始做的时候一个难点，最后实现确实我用了缓存，但是不是耿直用。这里缓存的不是<code>路径:函数</code>，而是<code>模式:函数</code>。基于模式的缓存，比如说<code>a.1</code>与<code>a.1000</code>，这两者的模式是一样的，所以只用了同一个模式工厂函数，而后将<code>a.1/1000</code>传入模式工厂函数中，返回一个带着闭包的函数。怎么解释看下面这个实例：</p><pre class="language-js"><code class="language-js"><span class="token constant">MP</span><span class="token punctuation">.</span><span class="token function">formatKey</span><span class="token punctuation">(</span><span class="token string">"a.b[A.B+C-D(E,F)].c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*[ 'a', 'b', 
function(__vm) {
    return PLA(matchs[0], __vm, __context) +
        PLA(matchs[1], __vm, __context) -
        PLA(matchs[2], __vm, __context)(
            PLA(matchs[3], __vm, __context),
            PLA(matchs[4], __vm, __context)
        )
}
, 'c']
这里返回的数组中的第三个对象，就是模式工厂返回的函数，其中matchs、__context都是处于闭包中，
所以同样模式的表达式（`@+@-@(@,@)`）可以公用这个模式工厂。
*/</span></code></pre><p>因为我认为在一个WebApp中，取值路径可能有上万个，但是模式不过那么几种——应用里头的字符串就那些。所以基于模式的匹配是很靠谱的一种解决方案，即便有动态的模式，使用context也能化繁为简，充分利用模式缓存。</p><h2>2</h2><p>另外，看上面那个formatKey返回的数组数据，可以发现其实<code>[ * ]</code>包裹起来的部分其实是会被解析成函数的，所以<code>[ * ]</code>内外是有性能区别的，也因此，能在外部写<code>a.1</code>这种违反JS语法的写法，正常JS写法是<code>a[1]</code>，而为了性能，我建议是使用<code>a.1</code>。上面说到模式，这里说道表达式，就不得不说一下解析： 这里是提取<code>x.x.x</code>作为<strong>路径单元</strong>，<code>[ * ]</code>作为<strong>模式单元</strong>，所以上述例子里头<code>[A.B+C-D(E,F)]</code>开头的<code>A.B</code>是被会识别成<strong>路径单元</strong>，最后模式才<strong>不是</strong>：<code>@.@+@-@(@,@)</code></p><h2>3</h2><p>动态的赋值。如果一个路径是<code>a.b.c.d</code>，而<code>a</code>属性本身就是空的话，那么在<code>model.set('a.b.c.d',value)</code>的过程中，会动态创建值给<code>a b c d</code>，如果路径某一部分的key是整数，那么动态创建的就会是数组：</p><pre class="language-js"><code class="language-js">m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"A.B.1.C"</span><span class="token punctuation">,</span><span class="token string">"ccc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//{ B: [ , { C: 'ccc' } ] }</span></code></pre><hr><p>【<strong>8/21 6:08</strong>】 目前功能有限，但代码就不到400行，接下来会加入动态监听功能，有了这个MP才完整。</p></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>