<!doctype html><html lang=zh-CH><meta charset=utf-8><title>浅谈Web Worker关闭的问题 · Gaubee</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#ec407a name=theme-color><link href=/articles.atom rel=alternate title="Gaubee's Articles Atom feed" type=application/atom+xml><link href=/events.atom rel=alternate title="Gaubee's Events Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><header id=header><h1><a href=/ >Gaubee</a></h1><a href=#navigation-toggle id=nav-toggle>显示导航 Show navigation</a><nav><ul><li><a href=/ >主页 Home</a><li class=current><a href=/articles>文章 Articles</a><li><a href=/events>小事件 Events</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>浅谈Web Worker关闭的问题</h1><p class=meta>发布于 <time datetime=5/24/2020 itemprop=datePublished>5/24/2020</time> · 最后修改时间 <time datetime=5/24/2020 itemprop=dateModified>5/24/2020</time></header><div itemprop=articleBody><p>Web Worker是没有提供onclose事件的，但它有提供terminate函数。<br>可能官方很自信地觉得Worker只要是用户销毁的，那么就没必要onclose……但其实昨天就遇到这个问题了（在Cordova-Ionic-Webview里头），就是从后台唤起程序，WebWorker没响应了，被杀了……在调试控制台已经看不到这个Worker的身影。<br>解决办法我想有三个：<ol><li>原生层面入手，去监控有什么系统层面的回调会触发<li>改成用ServiceWorker试一下<li>监控WebWorker的销毁</ol><p>为了简单且通用起见，我先选择了3。<br>但其实在官方接口里头是没有相关的接口的，这就只能另辟蹊径。<br>一开始我想到的是研究MessageChannel。因为从接口层面来说，它们几乎是一出的，也许底层实现是一样的。<br>所以就去研究如何识别MessageChannel是close状态的。最糟糕的方式估计就是pingpong，但这就得额外增加脏代码。<br>后来忽然想到transferable这个标准，所以就有了以下的骚操作：<pre class=language-ts><code class=language-ts><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>port1<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>byteLength<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果MessagePort是开启的状态，内存对象会被顺利传输，从而打印“0”。否则如果打印“1”，就说明MessagePort已经被关闭。<br>用这个方法去实验WebWorker。理论上几乎是一个东西吧……事实却是即便WebWorker执行了terminate，ArrayBuffer仍旧会被传输过去……这就很恐怖了，错觉自己是不是遇上了浏览器内存泄漏的问题……一搜索其实github上三四年前就已经有人提出了，到现在仍旧没有音讯。实在不理解terminate居然没有销毁消息管道……那我发送到子进程的ArrayBuffer到底发到哪里了呢?<p>既然这条路不通，我就再换一个操作。我想terminate至少会销毁WebWorker中所有的Promise吧。故而我想起了有这个一个API：LockManager 。<blockquote><p>PS: 我后来测试在使用<code>new Worker('data:text/javascript;,')</code>这样的<code>data:</code>协议下的Worker环境，是不支持的。建议还是用https协议。<br>它的用法很简单，虽然还是需要在子进程中注入代码，但至少也比pingpong的方案好，毕竟Worker就是要用来执行密集型任务，哪里还能保障一定能返回pingpong呢。所以只要在子进程启动后，执行一个永远不释放的request，然后发一个信号告知主进程开始监听这个request：</blockquote><pre class=language-ts><code class=language-ts><span class="token comment">/// worker</span><br><span class="token keyword">const</span> lockReqId <span class="token operator">=</span> <span class="token string">'process-live-'</span><span class="token operator">+</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>navigator<span class="token punctuation">.</span>locks<span class="token punctuation">.</span><span class="token function">request</span> <span class="token punctuation">(</span>lockReqId<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token keyword">new</span> <span class="token class-name"><span class="token builtin">Promise</span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">postMessage</span><span class="token punctuation">(</span>lockReqId<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">/// master</span><br>worker<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> me<span class="token operator">=></span><span class="token punctuation">{</span><br>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> me<span class="token punctuation">.</span>data<span class="token operator">===</span><span class="token string">'string'</span> <span class="token operator">&&</span> me<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"process-live-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>    navigator<span class="token punctuation">.</span>locks<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>me<span class="token punctuation">.</span>data<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span><br>      worker<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CloseEvent</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个方案几乎是完美的。因为是直接跟js引擎的销毁与否进行绑定。不过它只有chrome69+才支持。<hr><p>不过pingpong只能识别出Worker不响应，它可能繁忙。如果没有预期中的响应，应该将是否重启WebWorker</div><footer></footer></article></main><footer id=footer><div><nav><a href=https://twitter.com/gaubeebangeel rel="me nofollow" target=_blank>Twitter</a> · <a href="https://github.com/gaubee/gaubee.com/tree/main/./src/articles/浅谈Web Worker关闭的问题.md" rel=nofollow target=_blank>Edit this page on GitHub</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>除非有特别的说明, 该站点所有直接内容都使用许可证：<a href=https://creativecommons.org/licenses/by/4.0/deed.zh>署名 4.0 国际 (CC BY 4.0)</a></small><blockquote><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用</small></blockquote></footer><script src=/js/dark-mode-toggle.mjs type=module></script><script src=/js/time-elements.mjs type=module></script><script src=/js/main.mjs type=module></script>