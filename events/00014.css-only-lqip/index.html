<!doctype html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keywords" content="Appn, WebComponent, event"><meta name="author" content="Gaubee, gaubeebangeel@gmail.com"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=5"><title>undefined</title><link rel="shortcut icon" href="/assets/favicon-wB3RD3gX.ico"><link rel="stylesheet" href="/index.css">  <link rel="stylesheet" crossorigin href="/assets/prism-okaidia-D95GE6Gn.css">
</head><body><header class="bg-ani"><style>.nav{padding:0 2em;border-radius:2em;backdrop-filter:contrast(0.5) brightness(2);width:fit-content;max-width:100%}.nav{display:grid;grid-template-columns:repeat(auto-fit,180px);justify-content:center;gap:12px}.nav>a{display:block;flex:1;font-size:18px;padding:16px;text-align:center}.nav>a{color:#e91e63}@supports (-webkit-background-clip:text){.nav>a{background:-webkit-linear-gradient(#e91e63,#673ab7);color:transparent;-webkit-background-clip:text;-webkit-text-fill-color:transparent}}</style><nav class="nav"><a class="" href="/">Home</a> <a class="" href="/articles/">Articles</a> <a class="target" href="/events/">Events</a> <a class="" href="/timeline/">Timeline</a> <a class="" href="/projects/">Projects</a></nav></header><div id="main-wrapper" class="event-wrapper"><main><p><a href="https://leanrada.com/notes/css-only-lqip/">Minimal CSS-only blurry-image-placeholders(LQIPs)</a> <strong>这是一个天才般的想法，它把原本需要用 js 解码的工作，直接放到 css 表达式里，不仅仅是计算加快了，而且消除了很多中间成本。</strong></p><hr><p>我们项目有用到类似的需求。在我们项目中，图片名称（url）的一部分包含了 blurhash。 简单来说，我们使用文件名来存在 blurhash，然后将这个 blurhash 字符串解码成图片，但这是有代价的，需要用一个小 canvas 绘制：</p><ol><li>首先用算法绘制出模糊图片然后将它绘制到 canvas 上(消耗 CPU)；</li><li>然后将图片导出数据(消耗 CPU 和内存，这里做一次编码)；</li><li>最后将数据转成 blob-url（消耗 IO）；</li><li>最终设置 image-src（消耗 Network-IO，这里做一次解码）。</li></ol><p>尽管我已经将大部分流程放到 webworker 中，使用 offscreencanvas 来生产最后需要的 blob-url，从而避免对主线程的消耗，但是总成本是不会减少的。</p><p>这篇文章的方案，直接将算法硬编码到 css 表达式中，直接输出图片。原本依赖 js 方案中，很多中间的 CPU 和 IO 成本都消解了。 本质是把 background-image 直接当作一个 canvas 来进行绘制。所以我说它是天才般的想法！！</p><p>确实，如果直接在 image 上放一个绘制 blurhash 的 canvas，那么也就没那么多 CPU 和 IO 成本了。 然而如果真的放 canvas，内存成本会非常多，而且不同浏览器对于 canvas 的数量还会有限制。</p><hr><p>于此同时，css-only 方案还有一个巨大的改进，就是图片的精度。 我们知道 background-image 到 gradient 绘制，底层走的是 GPU 绘制，它是极快的。因此不论图片尺寸多大，它始终是可以非常高分辨率的（当然你也可以用 backgrond-size 来控制最终的分辨率）。 虽然是模糊图片，但是高分辨率的模糊和低分辨率的模糊是两码事情。 低分辨率的图片，放大的时候，浏览器走的是 图像插值算法 ​​（Image Interpolation）（通常使用双线性插值（Bilinear Interpolation）​​ 或 ​​ 双三次插值（Bicubic Interpolation），有一个 css 属性可以控制这种差值算法的使用：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering"><code>image-rendering: auto|smooth|crisp-edges|pixelated;</code></a>）。 然而这种插值算法的效果并不是那么理想，特别是我们用 blurhash 存储的其实就是几个图片像素而已，所以直接对一个低分辨率的图片进行插值，会出现很明显的“✨”效果。这里给一个例子：</p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAYAAACddGYaAAAAAXNSR0IArs4c6QAAAB5JREFUGFcFwQEBADAIAyCsaZo9jDl3mFKHZUSl4vlciQb/2bFejgAAAABJRU5ErkJggg==" alt="3x2 Rainbow Pixels PNG" style="image-rendering:auto;width:120px;height:80px"><p>然而在 js 方案中，我们如果要避免插值算法对模糊图的影响，只能是输出更高质量的图片，比如从 <code>3*2</code> 提升到 <code>6*4</code> 或者 <code>12*8</code>，然而代价输出的 DataURL 变长，也就意味着 CPU 和 IO 的消耗增多。 因此在 css-only 方案中，这个问题可以从根源上避免，不用再受插值算法的困扰，使用 gradient 进行高精度的矢量绘制，不用担心模糊图的质量问题。</p></main></div><style>footer a{line-height:1}footer nav{display:flex;gap:1rem}</style><footer class="bg-ani"><nav><a target="_blank" href="https://github.com/gaubee/gaubee.com">Github</a> <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></nav></footer></body></html>