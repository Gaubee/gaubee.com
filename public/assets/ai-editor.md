太好了，最后我们优化一些细节就行了：

1. 元数据的添加字段，不要使用 prompt，而是直接弹出 FieldMetadataEditDialog，此时的 title 是：New Field（新字段）
2. FieldMetadataEditDialog 内部的字段的排布不符合响应式布局的要求，字段会拥挤在一起
3. description 字段可以考虑显示出来
4. 我们的表单类型是有验证功能的，你好像忘了实现我之前提到的三种状态：验证正确、验证错误但是编辑中、验证错误且不在编辑中。
5. isArray 勾选的时候，如果 type 是 datetime 类型，Input 居然没有变更 type。isArray 和 noArray 唯一的区别只是可以添加删除，不该区别对待，可以充分提高代码的可复用性。
6. 字段要支持重新排序，isArray 中的元素也要支持重新排序
7. 加分项，如果简单可以实现，如果复杂我后续再实现：
   1. 为编辑器补充更多的 markdown 的格式功能按钮
   2. 如果可以，改进编辑器功能按钮的体验：比如如果我加粗了一段文本，那么光标所处位置的能被识别出已经被加粗了，再点击加粗应该取消加粗，其它同理。

---

我需要补充一点，我之所以让你将渲染器和验证器放在同一个文件里，目的是设定一种通用结构:

```ts
interface MetadataFieldRegister<T>{
    typeName: string
    parse(v:string):T
    verify(v:string):boolean|Promise<boolean>
    render(props:DateRendererProps):React.ReactNode {}
}
```

基于这种结构，我们就可以去做注册器。从而实现动态的自动类型自定义。（遇到未注册的类型，就回退到text类型来统一处理）

请你理解后，融合到你给我的计划书中，然后开始工作。

---

我描述一下我刚才看到的一些问题：

1. 关于拖动的问题，可能不是你的问题，而是第三方库的问题，你尝试修复，如果修复不了就算了。后续我自己想办法解决
   1. fieldInput之间拖动排序，拖动的过程中，一旦将要触发交换，那么元素会被scale，因为fieldInput的DOM-Height并不一样，这种scale导致很严重的观感问题
   2. 因为fieldInput是处于一个响应式布局的容器里，在桌面环境下，它们变成了双栏布局，这导致了拖动排序好像有一点问题：有的字段之间能拖动排序，有的就不行
      - 这里我给一种解决方案，就是将metadata也变成编辑区和预览区：
      1. 也就是说，它和下方的 CodeMirrorEditor 其实是同一列
      2. 所有编辑字段始终是单列排布
      3. 在“只预览”模式下，Metadata区域只显示最终的yaml数据（高亮显示）
      4. 在“只编辑”模式下，Metadata区域只显示现在这套可视化的yaml编辑器
      5. 在能进行“双栏显示”的模式下，Metadata区域同样显示左右两栏，只不过右边显示的是最终yaml数据
   3. 在Array字段中，拖动排序也许可以生效，但是拖动完后，它的动画好像是回撤的，但是新的排序好像又能生效，我猜测这是react-key的问题。
2. 有一些是我们代码的问题：
   1. 在Array中，Remove按钮溢出换行到下一行了
   2. Array的输入无效了，始终无法正确输入
   3. Array字段的的Input边框始终是红色的，说明它的验证函数不通过？
   4. Array字段中，如果我改变类型，不该清空原本的数据：
      1. 如果是从isArray改成noArray，那么应该留下第一个元素作为noArray的值
      2. 如果是noArray改成了isArray，那么应该将原本的值变成Array的第一个元素
      3. 如果是Array内的类型改变，不应该重置整个字段的值成为一个空Array，而应该保留所有的元素，然后走验证器，验证失败的项自然会亮起红色提示用户去修复。
   5. Array字段中，它的添加字段的那一栏，居然没有同步type进行正确的filedInput渲染
   6. Array字段中，能否成功添加，不是基于值是否非空，而是基于值是否验证通过。
   7. 我们现在能新增字段，却不能删除字段。

我要去睡觉了，接下来你必须自己前行，不要再过问我任何事情，直到代码提交。
提交代码只有两种情况：
一种是你自己独立解决了所有的问题并验证通过了。
一种是你遇到自己无法解决的问题，无法坚持下去，所以提交代码并提交所有的待审核的问题到commit-message中，等待我来处理。

等下一次我跟你沟通的时候，就是我睡醒后开始工作的时候

---

我体验了一下，确实好很多了，不过有两个看上去可能是小问题：

1. Array元素在编辑的时候，输入一个字符就blur了
2. 我们之前提到的验证有三种结果：“验证成功”、“验证失败但正在输入”、“验证失败也不在输入中”这三种结果并没有影响到样式。这样样式控制不是应该从className传递进来吗？

---

我还发现一个细节点，就是在编辑器那边，handleBold、handleItalic这几个函数，虽然说都实现了toggle，来达成 apply + cancel 的效果，但是算法上有点脱离预期。我先抛开你目前的实现，我简单说说我个人的想法：

1. 因此我们应该基于 activeFormats 和光标选择器的状态 来实现apply和cancel的逻辑：
2. 如果光标选择器没有选中任何字符，handleBold的逻辑为：
   1. activeFormats.bold 如果为true，那应该从光标出开始向左右两边寻找最近的bold语义块，然后取消当前的bold
   2. activeFormats.bold 如果为false，那么应该让生成`**|**`，其中`|`代表光标的位置
3. 如果光标选择器选中了部分字符，handleBold的逻辑为：
   1. 基于选择器范围的起点和终点：如果起点的左边马上就是`**`，那么应该剔除`**`，否则应该添加`**`；
   2. 同理如果终点的右边马上就是`**`，那么应该剔除`**`，否则应该添加`**`
   3. 这里的马上就是`**`有三种可能：`WORD|**WORD`、`WORD*|*WORD`、`WORD**|WORD`都要考虑。这种考虑是因为不能吧`**`当作字符，而是控制符号，所以我逻辑是要考虑到光标在控制符号内的可能，从而避免误判，最终目的是符合用户直觉。
4. 对此你需要实现几个专门的函数来解决以上的问题，比如`isNearControlSymbol(pos: number, controlSymbolChars: string): false|{start: number, end: number}`
5. 以上的编辑逻辑可以满足 `handleBold`、`handleItalic`、`handleStrikethrough`、`handleCode` 这类有start-end控制符号的逻辑。
6. 但是其中handleCode还需要更加复杂一点：
   1. 它是行逻辑，所以它需要做的是往当前行的前面和后面插入两行控制符号，因此它的逻辑可能需要另外编写。
   2. 同时它还有嵌套行为，因此它不能类似bold是可以取消。
   3. 同时因为它的嵌套行为，不能简单地始终插入三个<code>`</code>符号就行，而是要考虑包裹的行内，是不是有完整的start-end-code块，如果有，那么就要比这个start-end-code块多控制符多长度多一位。
7. 然后就是`handleQuote`、`handleList`这种单行控制符号了，相对比较简单。只不过和code类似，考虑的是选中的行号范围，而不是选中的字符范围。这点目前的toggleLinePrefix好像用起来没什么问题，但是也不是说没问题，因为你没有考虑语法缩进。我可能会建议你在activeFormats中增加一个“缩进量”的属性从而解决这个问题。
8. 剩下的就是toolbar对于md语法的支持不够全面的问题。等完成了以上的功能，就可以很简单地增加**完整**的md语法支持了，特别是TODO语法(`- [] `)的支持也要有。然后list的样式也有好几种。
9. 另外我还想补充一个编辑器自身的体验问题，就是对于`*`、<code>`</code>、`\_`、`~`等等这些和markdown相关的inline-block符号、都应该和内置的`[]`、`()`、`{}`、符号一样有 自动包裹、自动补全 的支持。我不知道codeMirror有没有这个功能，如果有的话，请配置这些符号对。
