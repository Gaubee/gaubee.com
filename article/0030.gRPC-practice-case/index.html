<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.B0ujMgz2.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }

          main > p > img {
            max-width: 100%;
            margin: 0 auto;
            display: block;
          }
        </style><h1>gRPC实践案例</h1><main><p>类似Google这种大公司产出的产品，一般就两种情况，一种是面向小白用户的，如此让G粉簇拥而来找Bug优化产品思路，等到时机成熟再推出正式版或者取消产品，AngularJS就是这一类。还有一种就是Google自己的需求而总结出来的产品，优点什么的我就不吹了，gRPC就是这一类的。</p>
<h2>序言</h2>
<blockquote>
<p>今年年初的时候我就一直想做一款基于RPC实现组件化搭建网站的一款产品。目的就是为了让各种语言的程序员能以最低沟通、学习代价来进行快速、稳定开发产品。而当初做的时候为了速度摸坑，用了Nodejs来进行开发，做出了<a href="https://github.com/gaubee/GQ">GQ</a>这款产品，自己边用边总结，说真的坑是真的多，JSON是不够用的，还有bytes、流数据等等问题。几个月下来，发现这个东西是个史诗大坑，因为要考虑到各种语言的兼容、使用难易、不同类型组件（数据库组件、流文件处理组件等）通用接口等等问题，迟迟没有拿出一套跨语言的规范来。几乎要放弃。这项目被我搁置。
不巧，gRPC出来了。当初心想有搞头，但是当时文档不够健全，让那些爱折腾的人先去探探路吧。
现在我作为第二批吃螃蟹的人，上手一试，心中暗叹：厉害了我的Goggle</p>
</blockquote>
<h2>案例简介</h2>
<p>一套基于路由注册的分发服务。这里使用Nodejs来快速上手。
服务端：注册HTTP端口，以及gRPC基础服务，通过基础服务，可以注册HTTP请求的处理权。
子服务：注册基础服务，实现对HTTP请求的处理。
流程如下：</p>
<pre><code>HTTP请求--->服务端--/a/b-->子服务1
　　　　　　　　　|--/a/c-->子服务2
　　　　　　　　　+--/a/d-->子服务3
</code></pre>
<h1>实现流程</h1>
<blockquote>
<p>PS:我这里不赘述<strong>XX为什么要这以做</strong>之类的话语，直接上代码，并简单解释代码中的重点。这个案例没有难点。
gRPC的安装省略。
使用Nodejs版本v6.9.1。用到一些ES6的语法，不完全兼容v4.*</p>
</blockquote>
<h2>proto文件</h2>
<pre><code class="language-protobuf">syntax = "proto3";

option objc_class_prefix = "Gaubee";

package httpserver;

// HttpServer服务的定义
service HttpServer {
    rpc BindRoute(RouteInfo) returns(RequestInfo) {}
    rpc ReturnResponse(ResponInfo) returns(ResponReply) {}
}

message RouteInfo {
    enum Method {
        GET = 0;
        POST = 1;
        PUT = 2;
        DELETE = 3;
    }
    // 注册的路由pathname
    string path = 1;
    Method method = 2;
    // 是否直接解析query到query中
    bool is_parse_query = 3;
    // 是否解析带有Body的请求
    bool is_parse_body = 4;
}
message RequestInfo {
    // 请求的ID，在做响应的时候需要带上
    string require_id = 1;
    // 请求链接中的数据
    map&#x3C;string, string> query = 2;
    // 请求数据包中的数据
    map&#x3C;string, string> body = 3;
}
message ResponInfo{
    string require_id = 1;
    map&#x3C;string, string> response_head = 2;
    string response_data = 3;
    int32 statusCode = 4;
}
// 返回整个请求的时间信息
message ResponReply{
    // 收到请求，解析请求query、body花费的时间
    float route_parsed_time = 1;
    // 传输请求数据花费的时间
    float route_send_time = 2;
    // 处理请求至服务端收到数据花费的时间
    float responsed_time = 3;
    // 返回请求结果给客户花费的时间
    float responsed_send_time = 4;
}
</code></pre>
<p>以上的proto文件描述了两个接口：</p>
<ul>
<li>BindRoute：实现路由绑定把要绑定的路由写道path中，这里为了简单，我只是进行了字符串相等匹配。BindRoute的回调函数不会马上触发。要等到服务端有HTTP请求的时候，匹配到对应的路由，最后再执行返回。</li>
<li>ReturnResponse：BindRoute收到回调后，意味着子服务开始处理HTTP请求，在处理完成后，需要调用此函数来返回处理结果。</li>
</ul>
<p><strong>require_id</strong>是注册基础服务后生成的一次性编号，每一次注册都会生成一个，在收到HTTP请求是，匹配到对应的路由，就要通过这个require_id来发送请求、接受处理结果。</p>
<h2>服务端</h2>
<pre><code class="language-js">"use strict";
// PROTO文件路径，按需换成自己的文件路径
const PROTO_PATH = __dirname + '/../pingpong/http-server.proto';
const grpc = require('grpc');
const http = require("http");
const url = require("url");
const querystring = require("querystring");

// 动态加载PROTO文件，生成接口
const httpserver = grpc.load(PROTO_PATH).httpserver;

/** 路由映射表
 *  结构为：{ [METHOD:GET|POST|PUT|DELETE] : { [PATHNAME] : Array&#x3C;String>[require_id,...] } }
 */
const route_res_list = {};

/** require_id对应的路由注册信息与回调函数
 *  结构为：{ args : 路由注册信息, callback: 回调函数，用于通知子服务来处理HTTP请求 }
 */
const handleCache = new Map();
/** require_id对应的HTTP请求
 *  结构为：{ req : HTTP.Request, res: HTTP.Response }
 */
const reqresCache = new Map();
// 初始化路由映射表的结构
for (let method in httpserver.RouteInfo.Method) {
    route_res_list[method] = {};
}

/** rgRPC服务：绑定路由
 *
 */
function BindRoute(call, callback) {
    const args = call.request;
    const routes = route_res_list[args.method];
    var handles = routes[args.path];
    if (!handles) {
        handles = routes[args.path] = new Set();
    }
    // 生成require_id
    const require_id = Math.random().toString(36).substr(2);

    // 加入路由映射表
    handles.add(require_id);

    // 这里不调用callback，而是等待到收到HTTP请求的时候再执行
    handleCache.set(require_id, {
        args: args,
        callback
    });
}

/** rgRPC服务：响应HTTP请求
 *
 */
function ReturnResponse(call, callback) {
    const args = call.request;
    const require_id = args.require_id;
    // 取出缓存中的req、res对象
    const {
        req,
        res
    } = reqresCache.get(require_id);
    if (!res) {
        return callback(`Ref Error:require_id:${require_id} no ref.`);
    }
    // 返回数据
    res.writeHead(args.statusCode, args.response_head);
    res.end(args.response_data);
    // 清除缓存
    reqresCache.delete(require_id);

    // 返回整个流程的消耗时间，这里为了简化代码没有加统计时间的代码
    callback(null, {
        route_parsed_time: 0,
        route_send_time: 0,
        responsed_time: 0,
        responsed_send_time: 0,
    });
}

function main() {
    const grpc_server = new grpc.Server();
    grpc_server.addProtoService(httpserver.HttpServer.service, {
        bindRoute: BindRoute,
        returnResponse: ReturnResponse,
    });
    // 注册gRPC服务
    grpc_server.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure());
    grpc_server.start();
}

main();
// 注册HTTP服务
const server = http.createServer((req, res) => {
    const routes = route_res_list[req.method];
    if (routes) {
        const url_info = url.parse(req.url);
        const handles = routes[url_info.pathname];
        if (handles &#x26;&#x26; handles.size) {
            const {
                value: require_id,
                has_key
            } = handles.values().next();
            if (has_key) {
                console.log("no handle");
                return
            }
            const handle = handleCache.get(require_id);
            // 通知客户端处理HTTP请求，并带上HTTP请求的一些数据
            handle.callback(null, {
                require_id,
                // TODO：headers
                query: handle.args.is_parse_query ? Object.assign({}, querystring.parse(url_info.query)) : {},
                // TODO：body应该改用流数据传输
                body: (handle.args.method !== "GET" &#x26;&#x26; handle.args.is_parse_body) ? {} : {}
            });
            // 缓存req、res
            reqresCache.set(require_id, {
                req,
                res
            });
            // 清除缓存，此require_id已经报废，只用于最后的响应res的处理
            handleCache.delete(require_id);
            handles.delete(require_id);
        }
    }
});
server.listen(1337, "0.0.0.0", () => {});
</code></pre>
<h2>子服务</h2>
<pre><code class="language-js">const PROTO_PATH = __dirname + '/../pingpong/http-server.proto';
const grpc = require('grpc');
const http = require("http");
const httpserver = grpc.load(PROTO_PATH).httpserver;
const address = 'localhost:50051'

function main() {
    var client = new httpserver.HttpServer(address, grpc.credentials.createInsecure());
    // 注册路由
    client.bindRoute({
        path: "/QAQ",
        method: httpserver.RouteInfo.Method.GET,
        is_parse_query: true,
        is_parse_body: false,
    }, function(err, response) {
        // 收到路由请求
        console.log(err, response);
        // 返回路由处理结果
        client.returnResponse({
            require_id: response.require_id,
            statusCode: 200,
            response_head: {},
            response_data: JSON.stringify(response.query)
        }, function(err, response) {
            // 收到性能统计
            console.log(err, response);
        })

    });

    // 模拟发起请求
    setTimeout(function() {
        var req = http.get("http://localhost:1337/QAQ?a=a", (res, socket, head) => {
            var datas = []
            res.on("data", (chunk) => {
                datas.push(chunk);
            });
            res.on("end", () => {
                // 打印结果
                console.log("request res:", Buffer.concat(datas).toString());
            });
        });
    }, 200)
}

main();
</code></pre>
<hr>
<h2>总结</h2>
<p>以上代码流程只是简单的示例，有一点不好的就是路由的注册变成了一次性，这不能说完全不对。但更优的做法应该改为流数据，这就不需要调用callback来结束服务，而是可以通过流不停地发起请求，流的实践参考官方代码：<a href="https://github.com/grpc/grpc/blob/master/examples/node/dynamic_codegen/route_guide/route_guide_server.js">route_guide</a>。</p></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0030.gRPC-practice-case"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0030.gRPC-practice-case.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"gRPC实践案例","date":"!Date:2016-10-24T21:39:05.000Z","updated":"!Date:2017-02-09T14:43:25.000Z"},"metadata":{"layout":"layouts/article.njk","title":"gRPC实践案例","date":"!Date:2016-10-24T21:39:05.000Z","updated":"!Date:2017-02-09T14:43:25.000Z","id":"0030.gRPC-practice-case","createdAt":"!Date:2016-10-24T21:39:05.000Z","updatedAt":"!Date:2017-02-09T14:43:25.000Z","tags":[]},"htmlContent":"\u003cp>类似Google这种大公司产出的产品，一般就两种情况，一种是面向小白用户的，如此让G粉簇拥而来找Bug优化产品思路，等到时机成熟再推出正式版或者取消产品，AngularJS就是这一类。还有一种就是Google自己的需求而总结出来的产品，优点什么的我就不吹了，gRPC就是这一类的。\u003c/p>\n\u003ch2>序言\u003c/h2>\n\u003cblockquote>\n\u003cp>今年年初的时候我就一直想做一款基于RPC实现组件化搭建网站的一款产品。目的就是为了让各种语言的程序员能以最低沟通、学习代价来进行快速、稳定开发产品。而当初做的时候为了速度摸坑，用了Nodejs来进行开发，做出了\u003ca href=\"https://github.com/gaubee/GQ\">GQ\u003c/a>这款产品，自己边用边总结，说真的坑是真的多，JSON是不够用的，还有bytes、流数据等等问题。几个月下来，发现这个东西是个史诗大坑，因为要考虑到各种语言的兼容、使用难易、不同类型组件（数据库组件、流文件处理组件等）通用接口等等问题，迟迟没有拿出一套跨语言的规范来。几乎要放弃。这项目被我搁置。\n不巧，gRPC出来了。当初心想有搞头，但是当时文档不够健全，让那些爱折腾的人先去探探路吧。\n现在我作为第二批吃螃蟹的人，上手一试，心中暗叹：厉害了我的Goggle\u003c/p>\n\u003c/blockquote>\n\u003ch2>案例简介\u003c/h2>\n\u003cp>一套基于路由注册的分发服务。这里使用Nodejs来快速上手。\n服务端：注册HTTP端口，以及gRPC基础服务，通过基础服务，可以注册HTTP请求的处理权。\n子服务：注册基础服务，实现对HTTP请求的处理。\n流程如下：\u003c/p>\n\u003cpre>\u003ccode>HTTP请求--->服务端--/a/b-->子服务1\n　　　　　　　　　|--/a/c-->子服务2\n　　　　　　　　　+--/a/d-->子服务3\n\u003c/code>\u003c/pre>\n\u003ch1>实现流程\u003c/h1>\n\u003cblockquote>\n\u003cp>PS:我这里不赘述\u003cstrong>XX为什么要这以做\u003c/strong>之类的话语，直接上代码，并简单解释代码中的重点。这个案例没有难点。\ngRPC的安装省略。\n使用Nodejs版本v6.9.1。用到一些ES6的语法，不完全兼容v4.*\u003c/p>\n\u003c/blockquote>\n\u003ch2>proto文件\u003c/h2>\n\u003cpre>\u003ccode class=\"language-protobuf\">syntax = \"proto3\";\n\noption objc_class_prefix = \"Gaubee\";\n\npackage httpserver;\n\n// HttpServer服务的定义\nservice HttpServer {\n    rpc BindRoute(RouteInfo) returns(RequestInfo) {}\n    rpc ReturnResponse(ResponInfo) returns(ResponReply) {}\n}\n\nmessage RouteInfo {\n    enum Method {\n        GET = 0;\n        POST = 1;\n        PUT = 2;\n        DELETE = 3;\n    }\n    // 注册的路由pathname\n    string path = 1;\n    Method method = 2;\n    // 是否直接解析query到query中\n    bool is_parse_query = 3;\n    // 是否解析带有Body的请求\n    bool is_parse_body = 4;\n}\nmessage RequestInfo {\n    // 请求的ID，在做响应的时候需要带上\n    string require_id = 1;\n    // 请求链接中的数据\n    map&#x3C;string, string> query = 2;\n    // 请求数据包中的数据\n    map&#x3C;string, string> body = 3;\n}\nmessage ResponInfo{\n    string require_id = 1;\n    map&#x3C;string, string> response_head = 2;\n    string response_data = 3;\n    int32 statusCode = 4;\n}\n// 返回整个请求的时间信息\nmessage ResponReply{\n    // 收到请求，解析请求query、body花费的时间\n    float route_parsed_time = 1;\n    // 传输请求数据花费的时间\n    float route_send_time = 2;\n    // 处理请求至服务端收到数据花费的时间\n    float responsed_time = 3;\n    // 返回请求结果给客户花费的时间\n    float responsed_send_time = 4;\n}\n\u003c/code>\u003c/pre>\n\u003cp>以上的proto文件描述了两个接口：\u003c/p>\n\u003cul>\n\u003cli>BindRoute：实现路由绑定把要绑定的路由写道path中，这里为了简单，我只是进行了字符串相等匹配。BindRoute的回调函数不会马上触发。要等到服务端有HTTP请求的时候，匹配到对应的路由，最后再执行返回。\u003c/li>\n\u003cli>ReturnResponse：BindRoute收到回调后，意味着子服务开始处理HTTP请求，在处理完成后，需要调用此函数来返回处理结果。\u003c/li>\n\u003c/ul>\n\u003cp>\u003cstrong>require_id\u003c/strong>是注册基础服务后生成的一次性编号，每一次注册都会生成一个，在收到HTTP请求是，匹配到对应的路由，就要通过这个require_id来发送请求、接受处理结果。\u003c/p>\n\u003ch2>服务端\u003c/h2>\n\u003cpre>\u003ccode class=\"language-js\">\"use strict\";\n// PROTO文件路径，按需换成自己的文件路径\nconst PROTO_PATH = __dirname + '/../pingpong/http-server.proto';\nconst grpc = require('grpc');\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst querystring = require(\"querystring\");\n\n// 动态加载PROTO文件，生成接口\nconst httpserver = grpc.load(PROTO_PATH).httpserver;\n\n/** 路由映射表\n *  结构为：{ [METHOD:GET|POST|PUT|DELETE] : { [PATHNAME] : Array&#x3C;String>[require_id,...] } }\n */\nconst route_res_list = {};\n\n/** require_id对应的路由注册信息与回调函数\n *  结构为：{ args : 路由注册信息, callback: 回调函数，用于通知子服务来处理HTTP请求 }\n */\nconst handleCache = new Map();\n/** require_id对应的HTTP请求\n *  结构为：{ req : HTTP.Request, res: HTTP.Response }\n */\nconst reqresCache = new Map();\n// 初始化路由映射表的结构\nfor (let method in httpserver.RouteInfo.Method) {\n    route_res_list[method] = {};\n}\n\n/** rgRPC服务：绑定路由\n *\n */\nfunction BindRoute(call, callback) {\n    const args = call.request;\n    const routes = route_res_list[args.method];\n    var handles = routes[args.path];\n    if (!handles) {\n        handles = routes[args.path] = new Set();\n    }\n    // 生成require_id\n    const require_id = Math.random().toString(36).substr(2);\n\n    // 加入路由映射表\n    handles.add(require_id);\n\n    // 这里不调用callback，而是等待到收到HTTP请求的时候再执行\n    handleCache.set(require_id, {\n        args: args,\n        callback\n    });\n}\n\n/** rgRPC服务：响应HTTP请求\n *\n */\nfunction ReturnResponse(call, callback) {\n    const args = call.request;\n    const require_id = args.require_id;\n    // 取出缓存中的req、res对象\n    const {\n        req,\n        res\n    } = reqresCache.get(require_id);\n    if (!res) {\n        return callback(`Ref Error:require_id:${require_id} no ref.`);\n    }\n    // 返回数据\n    res.writeHead(args.statusCode, args.response_head);\n    res.end(args.response_data);\n    // 清除缓存\n    reqresCache.delete(require_id);\n\n    // 返回整个流程的消耗时间，这里为了简化代码没有加统计时间的代码\n    callback(null, {\n        route_parsed_time: 0,\n        route_send_time: 0,\n        responsed_time: 0,\n        responsed_send_time: 0,\n    });\n}\n\nfunction main() {\n    const grpc_server = new grpc.Server();\n    grpc_server.addProtoService(httpserver.HttpServer.service, {\n        bindRoute: BindRoute,\n        returnResponse: ReturnResponse,\n    });\n    // 注册gRPC服务\n    grpc_server.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure());\n    grpc_server.start();\n}\n\nmain();\n// 注册HTTP服务\nconst server = http.createServer((req, res) => {\n    const routes = route_res_list[req.method];\n    if (routes) {\n        const url_info = url.parse(req.url);\n        const handles = routes[url_info.pathname];\n        if (handles &#x26;&#x26; handles.size) {\n            const {\n                value: require_id,\n                has_key\n            } = handles.values().next();\n            if (has_key) {\n                console.log(\"no handle\");\n                return\n            }\n            const handle = handleCache.get(require_id);\n            // 通知客户端处理HTTP请求，并带上HTTP请求的一些数据\n            handle.callback(null, {\n                require_id,\n                // TODO：headers\n                query: handle.args.is_parse_query ? Object.assign({}, querystring.parse(url_info.query)) : {},\n                // TODO：body应该改用流数据传输\n                body: (handle.args.method !== \"GET\" &#x26;&#x26; handle.args.is_parse_body) ? {} : {}\n            });\n            // 缓存req、res\n            reqresCache.set(require_id, {\n                req,\n                res\n            });\n            // 清除缓存，此require_id已经报废，只用于最后的响应res的处理\n            handleCache.delete(require_id);\n            handles.delete(require_id);\n        }\n    }\n});\nserver.listen(1337, \"0.0.0.0\", () => {});\n\u003c/code>\u003c/pre>\n\u003ch2>子服务\u003c/h2>\n\u003cpre>\u003ccode class=\"language-js\">const PROTO_PATH = __dirname + '/../pingpong/http-server.proto';\nconst grpc = require('grpc');\nconst http = require(\"http\");\nconst httpserver = grpc.load(PROTO_PATH).httpserver;\nconst address = 'localhost:50051'\n\nfunction main() {\n    var client = new httpserver.HttpServer(address, grpc.credentials.createInsecure());\n    // 注册路由\n    client.bindRoute({\n        path: \"/QAQ\",\n        method: httpserver.RouteInfo.Method.GET,\n        is_parse_query: true,\n        is_parse_body: false,\n    }, function(err, response) {\n        // 收到路由请求\n        console.log(err, response);\n        // 返回路由处理结果\n        client.returnResponse({\n            require_id: response.require_id,\n            statusCode: 200,\n            response_head: {},\n            response_data: JSON.stringify(response.query)\n        }, function(err, response) {\n            // 收到性能统计\n            console.log(err, response);\n        })\n\n    });\n\n    // 模拟发起请求\n    setTimeout(function() {\n        var req = http.get(\"http://localhost:1337/QAQ?a=a\", (res, socket, head) => {\n            var datas = []\n            res.on(\"data\", (chunk) => {\n                datas.push(chunk);\n            });\n            res.on(\"end\", () => {\n                // 打印结果\n                console.log(\"request res:\", Buffer.concat(datas).toString());\n            });\n        });\n    }, 200)\n}\n\nmain();\n\u003c/code>\u003c/pre>\n\u003chr>\n\u003ch2>总结\u003c/h2>\n\u003cp>以上代码流程只是简单的示例，有一点不好的就是路由的注册变成了一次性，这不能说完全不对。但更优的做法应该改为流数据，这就不需要调用callback来结束服务，而是可以通过流不停地发起请求，流的实践参考官方代码：\u003ca href=\"https://github.com/grpc/grpc/blob/master/examples/node/dynamic_codegen/route_guide/route_guide_server.js\">route_guide\u003c/a>。\u003c/p>","markdownContent":"\n类似Google这种大公司产出的产品，一般就两种情况，一种是面向小白用户的，如此让G粉簇拥而来找Bug优化产品思路，等到时机成熟再推出正式版或者取消产品，AngularJS就是这一类。还有一种就是Google自己的需求而总结出来的产品，优点什么的我就不吹了，gRPC就是这一类的。\n## 序言\n\n> 今年年初的时候我就一直想做一款基于RPC实现组件化搭建网站的一款产品。目的就是为了让各种语言的程序员能以最低沟通、学习代价来进行快速、稳定开发产品。而当初做的时候为了速度摸坑，用了Nodejs来进行开发，做出了[GQ](https://github.com/gaubee/GQ)这款产品，自己边用边总结，说真的坑是真的多，JSON是不够用的，还有bytes、流数据等等问题。几个月下来，发现这个东西是个史诗大坑，因为要考虑到各种语言的兼容、使用难易、不同类型组件（数据库组件、流文件处理组件等）通用接口等等问题，迟迟没有拿出一套跨语言的规范来。几乎要放弃。这项目被我搁置。\n> 不巧，gRPC出来了。当初心想有搞头，但是当时文档不够健全，让那些爱折腾的人先去探探路吧。\n> 现在我作为第二批吃螃蟹的人，上手一试，心中暗叹：厉害了我的Goggle\n## 案例简介\n\n一套基于路由注册的分发服务。这里使用Nodejs来快速上手。\n服务端：注册HTTP端口，以及gRPC基础服务，通过基础服务，可以注册HTTP请求的处理权。\n子服务：注册基础服务，实现对HTTP请求的处理。\n流程如下：\n\n```\nHTTP请求--->服务端--/a/b-->子服务1\n　　　　　　　　　|--/a/c-->子服务2\n　　　　　　　　　+--/a/d-->子服务3\n```\n# 实现流程\n\n> PS:我这里不赘述**XX为什么要这以做**之类的话语，直接上代码，并简单解释代码中的重点。这个案例没有难点。\n> gRPC的安装省略。\n> 使用Nodejs版本v6.9.1。用到一些ES6的语法，不完全兼容v4.*\n## proto文件\n\n``` protobuf\nsyntax = \"proto3\";\n\noption objc_class_prefix = \"Gaubee\";\n\npackage httpserver;\n\n// HttpServer服务的定义\nservice HttpServer {\n    rpc BindRoute(RouteInfo) returns(RequestInfo) {}\n    rpc ReturnResponse(ResponInfo) returns(ResponReply) {}\n}\n\nmessage RouteInfo {\n    enum Method {\n        GET = 0;\n        POST = 1;\n        PUT = 2;\n        DELETE = 3;\n    }\n    // 注册的路由pathname\n    string path = 1;\n    Method method = 2;\n    // 是否直接解析query到query中\n    bool is_parse_query = 3;\n    // 是否解析带有Body的请求\n    bool is_parse_body = 4;\n}\nmessage RequestInfo {\n    // 请求的ID，在做响应的时候需要带上\n    string require_id = 1;\n    // 请求链接中的数据\n    map\u003cstring, string> query = 2;\n    // 请求数据包中的数据\n    map\u003cstring, string> body = 3;\n}\nmessage ResponInfo{\n    string require_id = 1;\n    map\u003cstring, string> response_head = 2;\n    string response_data = 3;\n    int32 statusCode = 4;\n}\n// 返回整个请求的时间信息\nmessage ResponReply{\n    // 收到请求，解析请求query、body花费的时间\n    float route_parsed_time = 1;\n    // 传输请求数据花费的时间\n    float route_send_time = 2;\n    // 处理请求至服务端收到数据花费的时间\n    float responsed_time = 3;\n    // 返回请求结果给客户花费的时间\n    float responsed_send_time = 4;\n}\n```\n\n以上的proto文件描述了两个接口：\n- BindRoute：实现路由绑定把要绑定的路由写道path中，这里为了简单，我只是进行了字符串相等匹配。BindRoute的回调函数不会马上触发。要等到服务端有HTTP请求的时候，匹配到对应的路由，最后再执行返回。\n- ReturnResponse：BindRoute收到回调后，意味着子服务开始处理HTTP请求，在处理完成后，需要调用此函数来返回处理结果。\n\n**require_id**是注册基础服务后生成的一次性编号，每一次注册都会生成一个，在收到HTTP请求是，匹配到对应的路由，就要通过这个require_id来发送请求、接受处理结果。\n## 服务端\n\n``` js\n\"use strict\";\n// PROTO文件路径，按需换成自己的文件路径\nconst PROTO_PATH = __dirname + '/../pingpong/http-server.proto';\nconst grpc = require('grpc');\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst querystring = require(\"querystring\");\n\n// 动态加载PROTO文件，生成接口\nconst httpserver = grpc.load(PROTO_PATH).httpserver;\n\n/** 路由映射表\n *  结构为：{ [METHOD:GET|POST|PUT|DELETE] : { [PATHNAME] : Array\u003cString>[require_id,...] } }\n */\nconst route_res_list = {};\n\n/** require_id对应的路由注册信息与回调函数\n *  结构为：{ args : 路由注册信息, callback: 回调函数，用于通知子服务来处理HTTP请求 }\n */\nconst handleCache = new Map();\n/** require_id对应的HTTP请求\n *  结构为：{ req : HTTP.Request, res: HTTP.Response }\n */\nconst reqresCache = new Map();\n// 初始化路由映射表的结构\nfor (let method in httpserver.RouteInfo.Method) {\n    route_res_list[method] = {};\n}\n\n/** rgRPC服务：绑定路由\n *\n */\nfunction BindRoute(call, callback) {\n    const args = call.request;\n    const routes = route_res_list[args.method];\n    var handles = routes[args.path];\n    if (!handles) {\n        handles = routes[args.path] = new Set();\n    }\n    // 生成require_id\n    const require_id = Math.random().toString(36).substr(2);\n\n    // 加入路由映射表\n    handles.add(require_id);\n\n    // 这里不调用callback，而是等待到收到HTTP请求的时候再执行\n    handleCache.set(require_id, {\n        args: args,\n        callback\n    });\n}\n\n/** rgRPC服务：响应HTTP请求\n *\n */\nfunction ReturnResponse(call, callback) {\n    const args = call.request;\n    const require_id = args.require_id;\n    // 取出缓存中的req、res对象\n    const {\n        req,\n        res\n    } = reqresCache.get(require_id);\n    if (!res) {\n        return callback(`Ref Error:require_id:${require_id} no ref.`);\n    }\n    // 返回数据\n    res.writeHead(args.statusCode, args.response_head);\n    res.end(args.response_data);\n    // 清除缓存\n    reqresCache.delete(require_id);\n\n    // 返回整个流程的消耗时间，这里为了简化代码没有加统计时间的代码\n    callback(null, {\n        route_parsed_time: 0,\n        route_send_time: 0,\n        responsed_time: 0,\n        responsed_send_time: 0,\n    });\n}\n\nfunction main() {\n    const grpc_server = new grpc.Server();\n    grpc_server.addProtoService(httpserver.HttpServer.service, {\n        bindRoute: BindRoute,\n        returnResponse: ReturnResponse,\n    });\n    // 注册gRPC服务\n    grpc_server.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure());\n    grpc_server.start();\n}\n\nmain();\n// 注册HTTP服务\nconst server = http.createServer((req, res) => {\n    const routes = route_res_list[req.method];\n    if (routes) {\n        const url_info = url.parse(req.url);\n        const handles = routes[url_info.pathname];\n        if (handles && handles.size) {\n            const {\n                value: require_id,\n                has_key\n            } = handles.values().next();\n            if (has_key) {\n                console.log(\"no handle\");\n                return\n            }\n            const handle = handleCache.get(require_id);\n            // 通知客户端处理HTTP请求，并带上HTTP请求的一些数据\n            handle.callback(null, {\n                require_id,\n                // TODO：headers\n                query: handle.args.is_parse_query ? Object.assign({}, querystring.parse(url_info.query)) : {},\n                // TODO：body应该改用流数据传输\n                body: (handle.args.method !== \"GET\" && handle.args.is_parse_body) ? {} : {}\n            });\n            // 缓存req、res\n            reqresCache.set(require_id, {\n                req,\n                res\n            });\n            // 清除缓存，此require_id已经报废，只用于最后的响应res的处理\n            handleCache.delete(require_id);\n            handles.delete(require_id);\n        }\n    }\n});\nserver.listen(1337, \"0.0.0.0\", () => {});\n```\n## 子服务\n\n``` js\nconst PROTO_PATH = __dirname + '/../pingpong/http-server.proto';\nconst grpc = require('grpc');\nconst http = require(\"http\");\nconst httpserver = grpc.load(PROTO_PATH).httpserver;\nconst address = 'localhost:50051'\n\nfunction main() {\n    var client = new httpserver.HttpServer(address, grpc.credentials.createInsecure());\n    // 注册路由\n    client.bindRoute({\n        path: \"/QAQ\",\n        method: httpserver.RouteInfo.Method.GET,\n        is_parse_query: true,\n        is_parse_body: false,\n    }, function(err, response) {\n        // 收到路由请求\n        console.log(err, response);\n        // 返回路由处理结果\n        client.returnResponse({\n            require_id: response.require_id,\n            statusCode: 200,\n            response_head: {},\n            response_data: JSON.stringify(response.query)\n        }, function(err, response) {\n            // 收到性能统计\n            console.log(err, response);\n        })\n\n    });\n\n    // 模拟发起请求\n    setTimeout(function() {\n        var req = http.get(\"http://localhost:1337/QAQ?a=a\", (res, socket, head) => {\n            var datas = []\n            res.on(\"data\", (chunk) => {\n                datas.push(chunk);\n            });\n            res.on(\"end\", () => {\n                // 打印结果\n                console.log(\"request res:\", Buffer.concat(datas).toString());\n            });\n        });\n    }, 200)\n}\n\nmain();\n```\n\n---\n## 总结\n\n以上代码流程只是简单的示例，有一点不好的就是路由的注册变成了一次性，这不能说完全不对。但更优的做法应该改为流数据，这就不需要调用callback来结束服务，而是可以通过流不停地发起请求，流的实践参考官方代码：[route_guide](https://github.com/grpc/grpc/blob/master/examples/node/dynamic_codegen/route_guide/route_guide_server.js)。\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.XrIATmm0.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.IQG_6ZON.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-vy2czm8u.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-0HRAW6Xj.js" as="script" type="text/javascript">
      </body>
    </html>