{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0030.gRPC-practice-case"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0030.gRPC-practice-case.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"gRPC实践案例","date":"!Date:2016-10-24T21:39:05.000Z","updated":"!Date:2017-02-09T14:43:25.000Z"},"metadata":{"layout":"layouts/article.njk","title":"gRPC实践案例","date":"!Date:2016-10-24T21:39:05.000Z","updated":"!Date:2017-02-09T14:43:25.000Z","id":"0030.gRPC-practice-case","createdAt":"!Date:2016-10-24T21:39:05.000Z","updatedAt":"!Date:2017-02-09T14:43:25.000Z","tags":[]},"htmlContent":"<p>类似Google这种大公司产出的产品，一般就两种情况，一种是面向小白用户的，如此让G粉簇拥而来找Bug优化产品思路，等到时机成熟再推出正式版或者取消产品，AngularJS就是这一类。还有一种就是Google自己的需求而总结出来的产品，优点什么的我就不吹了，gRPC就是这一类的。</p>\n<h2>序言</h2>\n<blockquote>\n<p>今年年初的时候我就一直想做一款基于RPC实现组件化搭建网站的一款产品。目的就是为了让各种语言的程序员能以最低沟通、学习代价来进行快速、稳定开发产品。而当初做的时候为了速度摸坑，用了Nodejs来进行开发，做出了<a href=\"https://github.com/gaubee/GQ\">GQ</a>这款产品，自己边用边总结，说真的坑是真的多，JSON是不够用的，还有bytes、流数据等等问题。几个月下来，发现这个东西是个史诗大坑，因为要考虑到各种语言的兼容、使用难易、不同类型组件（数据库组件、流文件处理组件等）通用接口等等问题，迟迟没有拿出一套跨语言的规范来。几乎要放弃。这项目被我搁置。\n不巧，gRPC出来了。当初心想有搞头，但是当时文档不够健全，让那些爱折腾的人先去探探路吧。\n现在我作为第二批吃螃蟹的人，上手一试，心中暗叹：厉害了我的Goggle</p>\n</blockquote>\n<h2>案例简介</h2>\n<p>一套基于路由注册的分发服务。这里使用Nodejs来快速上手。\n服务端：注册HTTP端口，以及gRPC基础服务，通过基础服务，可以注册HTTP请求的处理权。\n子服务：注册基础服务，实现对HTTP请求的处理。\n流程如下：</p>\n<pre><code>HTTP请求--->服务端--/a/b-->子服务1\n　　　　　　　　　|--/a/c-->子服务2\n　　　　　　　　　+--/a/d-->子服务3\n</code></pre>\n<h1>实现流程</h1>\n<blockquote>\n<p>PS:我这里不赘述<strong>XX为什么要这以做</strong>之类的话语，直接上代码，并简单解释代码中的重点。这个案例没有难点。\ngRPC的安装省略。\n使用Nodejs版本v6.9.1。用到一些ES6的语法，不完全兼容v4.*</p>\n</blockquote>\n<h2>proto文件</h2>\n<pre><code class=\"language-protobuf\">syntax = \"proto3\";\n\noption objc_class_prefix = \"Gaubee\";\n\npackage httpserver;\n\n// HttpServer服务的定义\nservice HttpServer {\n    rpc BindRoute(RouteInfo) returns(RequestInfo) {}\n    rpc ReturnResponse(ResponInfo) returns(ResponReply) {}\n}\n\nmessage RouteInfo {\n    enum Method {\n        GET = 0;\n        POST = 1;\n        PUT = 2;\n        DELETE = 3;\n    }\n    // 注册的路由pathname\n    string path = 1;\n    Method method = 2;\n    // 是否直接解析query到query中\n    bool is_parse_query = 3;\n    // 是否解析带有Body的请求\n    bool is_parse_body = 4;\n}\nmessage RequestInfo {\n    // 请求的ID，在做响应的时候需要带上\n    string require_id = 1;\n    // 请求链接中的数据\n    map&#x3C;string, string> query = 2;\n    // 请求数据包中的数据\n    map&#x3C;string, string> body = 3;\n}\nmessage ResponInfo{\n    string require_id = 1;\n    map&#x3C;string, string> response_head = 2;\n    string response_data = 3;\n    int32 statusCode = 4;\n}\n// 返回整个请求的时间信息\nmessage ResponReply{\n    // 收到请求，解析请求query、body花费的时间\n    float route_parsed_time = 1;\n    // 传输请求数据花费的时间\n    float route_send_time = 2;\n    // 处理请求至服务端收到数据花费的时间\n    float responsed_time = 3;\n    // 返回请求结果给客户花费的时间\n    float responsed_send_time = 4;\n}\n</code></pre>\n<p>以上的proto文件描述了两个接口：</p>\n<ul>\n<li>BindRoute：实现路由绑定把要绑定的路由写道path中，这里为了简单，我只是进行了字符串相等匹配。BindRoute的回调函数不会马上触发。要等到服务端有HTTP请求的时候，匹配到对应的路由，最后再执行返回。</li>\n<li>ReturnResponse：BindRoute收到回调后，意味着子服务开始处理HTTP请求，在处理完成后，需要调用此函数来返回处理结果。</li>\n</ul>\n<p><strong>require_id</strong>是注册基础服务后生成的一次性编号，每一次注册都会生成一个，在收到HTTP请求是，匹配到对应的路由，就要通过这个require_id来发送请求、接受处理结果。</p>\n<h2>服务端</h2>\n<pre><code class=\"language-js\">\"use strict\";\n// PROTO文件路径，按需换成自己的文件路径\nconst PROTO_PATH = __dirname + '/../pingpong/http-server.proto';\nconst grpc = require('grpc');\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst querystring = require(\"querystring\");\n\n// 动态加载PROTO文件，生成接口\nconst httpserver = grpc.load(PROTO_PATH).httpserver;\n\n/** 路由映射表\n *  结构为：{ [METHOD:GET|POST|PUT|DELETE] : { [PATHNAME] : Array&#x3C;String>[require_id,...] } }\n */\nconst route_res_list = {};\n\n/** require_id对应的路由注册信息与回调函数\n *  结构为：{ args : 路由注册信息, callback: 回调函数，用于通知子服务来处理HTTP请求 }\n */\nconst handleCache = new Map();\n/** require_id对应的HTTP请求\n *  结构为：{ req : HTTP.Request, res: HTTP.Response }\n */\nconst reqresCache = new Map();\n// 初始化路由映射表的结构\nfor (let method in httpserver.RouteInfo.Method) {\n    route_res_list[method] = {};\n}\n\n/** rgRPC服务：绑定路由\n *\n */\nfunction BindRoute(call, callback) {\n    const args = call.request;\n    const routes = route_res_list[args.method];\n    var handles = routes[args.path];\n    if (!handles) {\n        handles = routes[args.path] = new Set();\n    }\n    // 生成require_id\n    const require_id = Math.random().toString(36).substr(2);\n\n    // 加入路由映射表\n    handles.add(require_id);\n\n    // 这里不调用callback，而是等待到收到HTTP请求的时候再执行\n    handleCache.set(require_id, {\n        args: args,\n        callback\n    });\n}\n\n/** rgRPC服务：响应HTTP请求\n *\n */\nfunction ReturnResponse(call, callback) {\n    const args = call.request;\n    const require_id = args.require_id;\n    // 取出缓存中的req、res对象\n    const {\n        req,\n        res\n    } = reqresCache.get(require_id);\n    if (!res) {\n        return callback(`Ref Error:require_id:${require_id} no ref.`);\n    }\n    // 返回数据\n    res.writeHead(args.statusCode, args.response_head);\n    res.end(args.response_data);\n    // 清除缓存\n    reqresCache.delete(require_id);\n\n    // 返回整个流程的消耗时间，这里为了简化代码没有加统计时间的代码\n    callback(null, {\n        route_parsed_time: 0,\n        route_send_time: 0,\n        responsed_time: 0,\n        responsed_send_time: 0,\n    });\n}\n\nfunction main() {\n    const grpc_server = new grpc.Server();\n    grpc_server.addProtoService(httpserver.HttpServer.service, {\n        bindRoute: BindRoute,\n        returnResponse: ReturnResponse,\n    });\n    // 注册gRPC服务\n    grpc_server.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure());\n    grpc_server.start();\n}\n\nmain();\n// 注册HTTP服务\nconst server = http.createServer((req, res) => {\n    const routes = route_res_list[req.method];\n    if (routes) {\n        const url_info = url.parse(req.url);\n        const handles = routes[url_info.pathname];\n        if (handles &#x26;&#x26; handles.size) {\n            const {\n                value: require_id,\n                has_key\n            } = handles.values().next();\n            if (has_key) {\n                console.log(\"no handle\");\n                return\n            }\n            const handle = handleCache.get(require_id);\n            // 通知客户端处理HTTP请求，并带上HTTP请求的一些数据\n            handle.callback(null, {\n                require_id,\n                // TODO：headers\n                query: handle.args.is_parse_query ? Object.assign({}, querystring.parse(url_info.query)) : {},\n                // TODO：body应该改用流数据传输\n                body: (handle.args.method !== \"GET\" &#x26;&#x26; handle.args.is_parse_body) ? {} : {}\n            });\n            // 缓存req、res\n            reqresCache.set(require_id, {\n                req,\n                res\n            });\n            // 清除缓存，此require_id已经报废，只用于最后的响应res的处理\n            handleCache.delete(require_id);\n            handles.delete(require_id);\n        }\n    }\n});\nserver.listen(1337, \"0.0.0.0\", () => {});\n</code></pre>\n<h2>子服务</h2>\n<pre><code class=\"language-js\">const PROTO_PATH = __dirname + '/../pingpong/http-server.proto';\nconst grpc = require('grpc');\nconst http = require(\"http\");\nconst httpserver = grpc.load(PROTO_PATH).httpserver;\nconst address = 'localhost:50051'\n\nfunction main() {\n    var client = new httpserver.HttpServer(address, grpc.credentials.createInsecure());\n    // 注册路由\n    client.bindRoute({\n        path: \"/QAQ\",\n        method: httpserver.RouteInfo.Method.GET,\n        is_parse_query: true,\n        is_parse_body: false,\n    }, function(err, response) {\n        // 收到路由请求\n        console.log(err, response);\n        // 返回路由处理结果\n        client.returnResponse({\n            require_id: response.require_id,\n            statusCode: 200,\n            response_head: {},\n            response_data: JSON.stringify(response.query)\n        }, function(err, response) {\n            // 收到性能统计\n            console.log(err, response);\n        })\n\n    });\n\n    // 模拟发起请求\n    setTimeout(function() {\n        var req = http.get(\"http://localhost:1337/QAQ?a=a\", (res, socket, head) => {\n            var datas = []\n            res.on(\"data\", (chunk) => {\n                datas.push(chunk);\n            });\n            res.on(\"end\", () => {\n                // 打印结果\n                console.log(\"request res:\", Buffer.concat(datas).toString());\n            });\n        });\n    }, 200)\n}\n\nmain();\n</code></pre>\n<hr>\n<h2>总结</h2>\n<p>以上代码流程只是简单的示例，有一点不好的就是路由的注册变成了一次性，这不能说完全不对。但更优的做法应该改为流数据，这就不需要调用callback来结束服务，而是可以通过流不停地发起请求，流的实践参考官方代码：<a href=\"https://github.com/grpc/grpc/blob/master/examples/node/dynamic_codegen/route_guide/route_guide_server.js\">route_guide</a>。</p>","markdownContent":"\n类似Google这种大公司产出的产品，一般就两种情况，一种是面向小白用户的，如此让G粉簇拥而来找Bug优化产品思路，等到时机成熟再推出正式版或者取消产品，AngularJS就是这一类。还有一种就是Google自己的需求而总结出来的产品，优点什么的我就不吹了，gRPC就是这一类的。\n## 序言\n\n> 今年年初的时候我就一直想做一款基于RPC实现组件化搭建网站的一款产品。目的就是为了让各种语言的程序员能以最低沟通、学习代价来进行快速、稳定开发产品。而当初做的时候为了速度摸坑，用了Nodejs来进行开发，做出了[GQ](https://github.com/gaubee/GQ)这款产品，自己边用边总结，说真的坑是真的多，JSON是不够用的，还有bytes、流数据等等问题。几个月下来，发现这个东西是个史诗大坑，因为要考虑到各种语言的兼容、使用难易、不同类型组件（数据库组件、流文件处理组件等）通用接口等等问题，迟迟没有拿出一套跨语言的规范来。几乎要放弃。这项目被我搁置。\n> 不巧，gRPC出来了。当初心想有搞头，但是当时文档不够健全，让那些爱折腾的人先去探探路吧。\n> 现在我作为第二批吃螃蟹的人，上手一试，心中暗叹：厉害了我的Goggle\n## 案例简介\n\n一套基于路由注册的分发服务。这里使用Nodejs来快速上手。\n服务端：注册HTTP端口，以及gRPC基础服务，通过基础服务，可以注册HTTP请求的处理权。\n子服务：注册基础服务，实现对HTTP请求的处理。\n流程如下：\n\n```\nHTTP请求--->服务端--/a/b-->子服务1\n　　　　　　　　　|--/a/c-->子服务2\n　　　　　　　　　+--/a/d-->子服务3\n```\n# 实现流程\n\n> PS:我这里不赘述**XX为什么要这以做**之类的话语，直接上代码，并简单解释代码中的重点。这个案例没有难点。\n> gRPC的安装省略。\n> 使用Nodejs版本v6.9.1。用到一些ES6的语法，不完全兼容v4.*\n## proto文件\n\n``` protobuf\nsyntax = \"proto3\";\n\noption objc_class_prefix = \"Gaubee\";\n\npackage httpserver;\n\n// HttpServer服务的定义\nservice HttpServer {\n    rpc BindRoute(RouteInfo) returns(RequestInfo) {}\n    rpc ReturnResponse(ResponInfo) returns(ResponReply) {}\n}\n\nmessage RouteInfo {\n    enum Method {\n        GET = 0;\n        POST = 1;\n        PUT = 2;\n        DELETE = 3;\n    }\n    // 注册的路由pathname\n    string path = 1;\n    Method method = 2;\n    // 是否直接解析query到query中\n    bool is_parse_query = 3;\n    // 是否解析带有Body的请求\n    bool is_parse_body = 4;\n}\nmessage RequestInfo {\n    // 请求的ID，在做响应的时候需要带上\n    string require_id = 1;\n    // 请求链接中的数据\n    map<string, string> query = 2;\n    // 请求数据包中的数据\n    map<string, string> body = 3;\n}\nmessage ResponInfo{\n    string require_id = 1;\n    map<string, string> response_head = 2;\n    string response_data = 3;\n    int32 statusCode = 4;\n}\n// 返回整个请求的时间信息\nmessage ResponReply{\n    // 收到请求，解析请求query、body花费的时间\n    float route_parsed_time = 1;\n    // 传输请求数据花费的时间\n    float route_send_time = 2;\n    // 处理请求至服务端收到数据花费的时间\n    float responsed_time = 3;\n    // 返回请求结果给客户花费的时间\n    float responsed_send_time = 4;\n}\n```\n\n以上的proto文件描述了两个接口：\n- BindRoute：实现路由绑定把要绑定的路由写道path中，这里为了简单，我只是进行了字符串相等匹配。BindRoute的回调函数不会马上触发。要等到服务端有HTTP请求的时候，匹配到对应的路由，最后再执行返回。\n- ReturnResponse：BindRoute收到回调后，意味着子服务开始处理HTTP请求，在处理完成后，需要调用此函数来返回处理结果。\n\n**require_id**是注册基础服务后生成的一次性编号，每一次注册都会生成一个，在收到HTTP请求是，匹配到对应的路由，就要通过这个require_id来发送请求、接受处理结果。\n## 服务端\n\n``` js\n\"use strict\";\n// PROTO文件路径，按需换成自己的文件路径\nconst PROTO_PATH = __dirname + '/../pingpong/http-server.proto';\nconst grpc = require('grpc');\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst querystring = require(\"querystring\");\n\n// 动态加载PROTO文件，生成接口\nconst httpserver = grpc.load(PROTO_PATH).httpserver;\n\n/** 路由映射表\n *  结构为：{ [METHOD:GET|POST|PUT|DELETE] : { [PATHNAME] : Array<String>[require_id,...] } }\n */\nconst route_res_list = {};\n\n/** require_id对应的路由注册信息与回调函数\n *  结构为：{ args : 路由注册信息, callback: 回调函数，用于通知子服务来处理HTTP请求 }\n */\nconst handleCache = new Map();\n/** require_id对应的HTTP请求\n *  结构为：{ req : HTTP.Request, res: HTTP.Response }\n */\nconst reqresCache = new Map();\n// 初始化路由映射表的结构\nfor (let method in httpserver.RouteInfo.Method) {\n    route_res_list[method] = {};\n}\n\n/** rgRPC服务：绑定路由\n *\n */\nfunction BindRoute(call, callback) {\n    const args = call.request;\n    const routes = route_res_list[args.method];\n    var handles = routes[args.path];\n    if (!handles) {\n        handles = routes[args.path] = new Set();\n    }\n    // 生成require_id\n    const require_id = Math.random().toString(36).substr(2);\n\n    // 加入路由映射表\n    handles.add(require_id);\n\n    // 这里不调用callback，而是等待到收到HTTP请求的时候再执行\n    handleCache.set(require_id, {\n        args: args,\n        callback\n    });\n}\n\n/** rgRPC服务：响应HTTP请求\n *\n */\nfunction ReturnResponse(call, callback) {\n    const args = call.request;\n    const require_id = args.require_id;\n    // 取出缓存中的req、res对象\n    const {\n        req,\n        res\n    } = reqresCache.get(require_id);\n    if (!res) {\n        return callback(`Ref Error:require_id:${require_id} no ref.`);\n    }\n    // 返回数据\n    res.writeHead(args.statusCode, args.response_head);\n    res.end(args.response_data);\n    // 清除缓存\n    reqresCache.delete(require_id);\n\n    // 返回整个流程的消耗时间，这里为了简化代码没有加统计时间的代码\n    callback(null, {\n        route_parsed_time: 0,\n        route_send_time: 0,\n        responsed_time: 0,\n        responsed_send_time: 0,\n    });\n}\n\nfunction main() {\n    const grpc_server = new grpc.Server();\n    grpc_server.addProtoService(httpserver.HttpServer.service, {\n        bindRoute: BindRoute,\n        returnResponse: ReturnResponse,\n    });\n    // 注册gRPC服务\n    grpc_server.bind('0.0.0.0:50051', grpc.ServerCredentials.createInsecure());\n    grpc_server.start();\n}\n\nmain();\n// 注册HTTP服务\nconst server = http.createServer((req, res) => {\n    const routes = route_res_list[req.method];\n    if (routes) {\n        const url_info = url.parse(req.url);\n        const handles = routes[url_info.pathname];\n        if (handles && handles.size) {\n            const {\n                value: require_id,\n                has_key\n            } = handles.values().next();\n            if (has_key) {\n                console.log(\"no handle\");\n                return\n            }\n            const handle = handleCache.get(require_id);\n            // 通知客户端处理HTTP请求，并带上HTTP请求的一些数据\n            handle.callback(null, {\n                require_id,\n                // TODO：headers\n                query: handle.args.is_parse_query ? Object.assign({}, querystring.parse(url_info.query)) : {},\n                // TODO：body应该改用流数据传输\n                body: (handle.args.method !== \"GET\" && handle.args.is_parse_body) ? {} : {}\n            });\n            // 缓存req、res\n            reqresCache.set(require_id, {\n                req,\n                res\n            });\n            // 清除缓存，此require_id已经报废，只用于最后的响应res的处理\n            handleCache.delete(require_id);\n            handles.delete(require_id);\n        }\n    }\n});\nserver.listen(1337, \"0.0.0.0\", () => {});\n```\n## 子服务\n\n``` js\nconst PROTO_PATH = __dirname + '/../pingpong/http-server.proto';\nconst grpc = require('grpc');\nconst http = require(\"http\");\nconst httpserver = grpc.load(PROTO_PATH).httpserver;\nconst address = 'localhost:50051'\n\nfunction main() {\n    var client = new httpserver.HttpServer(address, grpc.credentials.createInsecure());\n    // 注册路由\n    client.bindRoute({\n        path: \"/QAQ\",\n        method: httpserver.RouteInfo.Method.GET,\n        is_parse_query: true,\n        is_parse_body: false,\n    }, function(err, response) {\n        // 收到路由请求\n        console.log(err, response);\n        // 返回路由处理结果\n        client.returnResponse({\n            require_id: response.require_id,\n            statusCode: 200,\n            response_head: {},\n            response_data: JSON.stringify(response.query)\n        }, function(err, response) {\n            // 收到性能统计\n            console.log(err, response);\n        })\n\n    });\n\n    // 模拟发起请求\n    setTimeout(function() {\n        var req = http.get(\"http://localhost:1337/QAQ?a=a\", (res, socket, head) => {\n            var datas = []\n            res.on(\"data\", (chunk) => {\n                datas.push(chunk);\n            });\n            res.on(\"end\", () => {\n                // 打印结果\n                console.log(\"request res:\", Buffer.concat(datas).toString());\n            });\n        });\n    }, 200)\n}\n\nmain();\n```\n\n---\n## 总结\n\n以上代码流程只是简单的示例，有一点不好的就是路由的注册变成了一次性，这不能说完全不对。但更优的做法应该改为流数据，这就不需要调用callback来结束服务，而是可以通过流不停地发起请求，流的实践参考官方代码：[route_guide](https://github.com/grpc/grpc/blob/master/examples/node/dynamic_codegen/route_guide/route_guide_server.js)。\n"}}}