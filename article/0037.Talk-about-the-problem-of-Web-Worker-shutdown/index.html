<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.BMrmlmx0.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }
        </style><h1>浅谈Web Worker关闭的问题</h1><main><p>Web Worker是没有提供onclose事件的，但它有提供terminate函数。
可能官方很自信地觉得Worker只要是用户销毁的，那么就没必要onclose……但其实昨天就遇到这个问题了（在Cordova-Ionic-Webview里头），就是从后台唤起程序，WebWorker没响应了，被杀了……在调试控制台已经看不到这个Worker的身影。
解决办法我想有三个：</p>
<ol>
<li>原生层面入手，去监控有什么系统层面的回调会触发</li>
<li>改成用ServiceWorker试一下</li>
<li>监控WebWorker的销毁</li>
</ol>
<p>为了简单且通用起见，我先选择了3。
但其实在官方接口里头是没有相关的接口的，这就只能另辟蹊径。
一开始我想到的是研究MessageChannel。因为从接口层面来说，它们几乎是一出的，也许底层实现是一样的。
所以就去研究如何识别MessageChannel是close状态的。最糟糕的方式估计就是pingpong，但这就得额外增加脏代码。
后来忽然想到transferable这个标准，所以就有了以下的骚操作：</p>
<pre><code class="language-ts">const b = new ArrayBuffer(1);
port1.postMessage(0,[b]);
console.log(b.byteLength);
</code></pre>
<p>如果MessagePort是开启的状态，内存对象会被顺利传输，从而打印“0”。否则如果打印“1”，就说明MessagePort已经被关闭。
用这个方法去实验WebWorker。理论上几乎是一个东西吧……事实却是即便WebWorker执行了terminate，ArrayBuffer仍旧会被传输过去……这就很恐怖了，错觉自己是不是遇上了浏览器内存泄漏的问题……一搜索其实github上三四年前就已经有人提出了，到现在仍旧没有音讯。实在不理解terminate居然没有销毁消息管道……那我发送到子进程的ArrayBuffer到底发到哪里了呢?</p>
<p>既然这条路不通，我就再换一个操作。我想terminate至少会销毁WebWorker中所有的Promise吧。故而我想起了有这个一个API：LockManager 。</p>
<blockquote>
<p>PS: 我后来测试在使用<code>new Worker('data:text/javascript;,')</code>这样的<code>data:</code>协议下的Worker环境，是不支持的。建议还是用https协议。
它的用法很简单，虽然还是需要在子进程中注入代码，但至少也比pingpong的方案好，毕竟Worker就是要用来执行密集型任务，哪里还能保障一定能返回pingpong呢。所以只要在子进程启动后，执行一个永远不释放的request，然后发一个信号告知主进程开始监听这个request：</p>
</blockquote>
<pre><code class="language-ts">/// worker
const lockReqId = 'process-live-'+Date.now()+Math.random();
navigator.locks.request (lockReqId,()=>new Promise(()=>{}));
postMessage(lockReqId);

/// master
worker.addEventListener('message', me=>{
  if(typeof me.data==='string' &#x26;&#x26; me.data.startsWith("process-live-")){
    navigator.locks.request(me.data,()=>{
      worker.dispatchEvent(new CloseEvent('close'))
    })
  }
});
</code></pre>
<p>这个方案几乎是完美的。因为是直接跟js引擎的销毁与否进行绑定。不过它只有chrome69+才支持。</p>
<hr>
<p>不过pingpong只能识别出Worker不响应，它可能繁忙。如果没有预期中的响应，应该将是否重启WebWorker</p></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0037.Talk-about-the-problem-of-Web-Worker-shutdown"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0037.Talk-about-the-problem-of-Web-Worker-shutdown.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"浅谈Web Worker关闭的问题","date":"!Date:2020-05-24T08:44:26.000Z","updated":"!Date:2020-05-24T08:46:02.000Z"},"metadata":{"layout":"layouts/article.njk","title":"浅谈Web Worker关闭的问题","date":"!Date:2020-05-24T08:44:26.000Z","updated":"!Date:2020-05-24T08:46:02.000Z","id":"0037.Talk-about-the-problem-of-Web-Worker-shutdown","createdAt":"!Date:2020-05-24T08:44:26.000Z","updatedAt":"!Date:2020-05-24T08:46:02.000Z","tags":[]},"htmlContent":"\u003cp>Web Worker是没有提供onclose事件的，但它有提供terminate函数。\n可能官方很自信地觉得Worker只要是用户销毁的，那么就没必要onclose……但其实昨天就遇到这个问题了（在Cordova-Ionic-Webview里头），就是从后台唤起程序，WebWorker没响应了，被杀了……在调试控制台已经看不到这个Worker的身影。\n解决办法我想有三个：\u003c/p>\n\u003col>\n\u003cli>原生层面入手，去监控有什么系统层面的回调会触发\u003c/li>\n\u003cli>改成用ServiceWorker试一下\u003c/li>\n\u003cli>监控WebWorker的销毁\u003c/li>\n\u003c/ol>\n\u003cp>为了简单且通用起见，我先选择了3。\n但其实在官方接口里头是没有相关的接口的，这就只能另辟蹊径。\n一开始我想到的是研究MessageChannel。因为从接口层面来说，它们几乎是一出的，也许底层实现是一样的。\n所以就去研究如何识别MessageChannel是close状态的。最糟糕的方式估计就是pingpong，但这就得额外增加脏代码。\n后来忽然想到transferable这个标准，所以就有了以下的骚操作：\u003c/p>\n\u003cpre>\u003ccode class=\"language-ts\">const b = new ArrayBuffer(1);\nport1.postMessage(0,[b]);\nconsole.log(b.byteLength);\n\u003c/code>\u003c/pre>\n\u003cp>如果MessagePort是开启的状态，内存对象会被顺利传输，从而打印“0”。否则如果打印“1”，就说明MessagePort已经被关闭。\n用这个方法去实验WebWorker。理论上几乎是一个东西吧……事实却是即便WebWorker执行了terminate，ArrayBuffer仍旧会被传输过去……这就很恐怖了，错觉自己是不是遇上了浏览器内存泄漏的问题……一搜索其实github上三四年前就已经有人提出了，到现在仍旧没有音讯。实在不理解terminate居然没有销毁消息管道……那我发送到子进程的ArrayBuffer到底发到哪里了呢?\u003c/p>\n\u003cp>既然这条路不通，我就再换一个操作。我想terminate至少会销毁WebWorker中所有的Promise吧。故而我想起了有这个一个API：LockManager 。\u003c/p>\n\u003cblockquote>\n\u003cp>PS: 我后来测试在使用\u003ccode>new Worker('data:text/javascript;,')\u003c/code>这样的\u003ccode>data:\u003c/code>协议下的Worker环境，是不支持的。建议还是用https协议。\n它的用法很简单，虽然还是需要在子进程中注入代码，但至少也比pingpong的方案好，毕竟Worker就是要用来执行密集型任务，哪里还能保障一定能返回pingpong呢。所以只要在子进程启动后，执行一个永远不释放的request，然后发一个信号告知主进程开始监听这个request：\u003c/p>\n\u003c/blockquote>\n\u003cpre>\u003ccode class=\"language-ts\">/// worker\nconst lockReqId = 'process-live-'+Date.now()+Math.random();\nnavigator.locks.request (lockReqId,()=>new Promise(()=>{}));\npostMessage(lockReqId);\n\n/// master\nworker.addEventListener('message', me=>{\n  if(typeof me.data==='string' &#x26;&#x26; me.data.startsWith(\"process-live-\")){\n    navigator.locks.request(me.data,()=>{\n      worker.dispatchEvent(new CloseEvent('close'))\n    })\n  }\n});\n\u003c/code>\u003c/pre>\n\u003cp>这个方案几乎是完美的。因为是直接跟js引擎的销毁与否进行绑定。不过它只有chrome69+才支持。\u003c/p>\n\u003chr>\n\u003cp>不过pingpong只能识别出Worker不响应，它可能繁忙。如果没有预期中的响应，应该将是否重启WebWorker\u003c/p>","markdownContent":"\nWeb Worker是没有提供onclose事件的，但它有提供terminate函数。\n可能官方很自信地觉得Worker只要是用户销毁的，那么就没必要onclose……但其实昨天就遇到这个问题了（在Cordova-Ionic-Webview里头），就是从后台唤起程序，WebWorker没响应了，被杀了……在调试控制台已经看不到这个Worker的身影。\n解决办法我想有三个：\n1. 原生层面入手，去监控有什么系统层面的回调会触发\n2. 改成用ServiceWorker试一下\n3. 监控WebWorker的销毁\n\n为了简单且通用起见，我先选择了3。\n但其实在官方接口里头是没有相关的接口的，这就只能另辟蹊径。\n一开始我想到的是研究MessageChannel。因为从接口层面来说，它们几乎是一出的，也许底层实现是一样的。\n所以就去研究如何识别MessageChannel是close状态的。最糟糕的方式估计就是pingpong，但这就得额外增加脏代码。\n后来忽然想到transferable这个标准，所以就有了以下的骚操作：\n```ts\nconst b = new ArrayBuffer(1);\nport1.postMessage(0,[b]);\nconsole.log(b.byteLength);\n```\n如果MessagePort是开启的状态，内存对象会被顺利传输，从而打印“0”。否则如果打印“1”，就说明MessagePort已经被关闭。\n用这个方法去实验WebWorker。理论上几乎是一个东西吧……事实却是即便WebWorker执行了terminate，ArrayBuffer仍旧会被传输过去……这就很恐怖了，错觉自己是不是遇上了浏览器内存泄漏的问题……一搜索其实github上三四年前就已经有人提出了，到现在仍旧没有音讯。实在不理解terminate居然没有销毁消息管道……那我发送到子进程的ArrayBuffer到底发到哪里了呢?\n\n既然这条路不通，我就再换一个操作。我想terminate至少会销毁WebWorker中所有的Promise吧。故而我想起了有这个一个API：LockManager 。\n> PS: 我后来测试在使用`new Worker('data:text/javascript;,')`这样的`data:`协议下的Worker环境，是不支持的。建议还是用https协议。\n它的用法很简单，虽然还是需要在子进程中注入代码，但至少也比pingpong的方案好，毕竟Worker就是要用来执行密集型任务，哪里还能保障一定能返回pingpong呢。所以只要在子进程启动后，执行一个永远不释放的request，然后发一个信号告知主进程开始监听这个request：\n```ts\n/// worker\nconst lockReqId = 'process-live-'+Date.now()+Math.random();\nnavigator.locks.request (lockReqId,()=>new Promise(()=>{}));\npostMessage(lockReqId);\n\n/// master\nworker.addEventListener('message', me=>{\n  if(typeof me.data==='string' && me.data.startsWith(\"process-live-\")){\n    navigator.locks.request(me.data,()=>{\n      worker.dispatchEvent(new CloseEvent('close'))\n    })\n  }\n});\n```\n这个方案几乎是完美的。因为是直接跟js引擎的销毁与否进行绑定。不过它只有chrome69+才支持。\n\n----\n\n不过pingpong只能识别出Worker不响应，它可能繁忙。如果没有预期中的响应，应该将是否重启WebWorker\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.CHhd62G8.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.zKRL1uyc.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-DcLnoLrn.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-BMsgTsFr.js" as="script" type="text/javascript">
      </body>
    </html>