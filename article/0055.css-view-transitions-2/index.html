<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.B0ujMgz2.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }

          main > p > img {
            max-width: 100%;
            margin: 0 auto;
            display: block;
          }
        </style><h1>View Transitions API (Level-2 cross-document)</h1><main><p>上一篇文章咱们聊了 <a href="/article/0054.css-view-transitions-1">View Transitions API (Level-1 single-document)</a> 如何优雅地解决了 SPA（单页应用）里那为了动画而扭曲 DOM、编写复杂 JS 的痛点。通过 <code>document.startViewTransition</code>、快照机制和神奇的伪元素树，它成功地将 <strong>DOM 状态更新</strong> 与 <strong>视觉过渡动画</strong> 解耦，让开发者能轻松实现丝滑的同文档视图切换。</p>
<p>但是，Level 1 的能力仅限于“家里面”（同一个文档）。一旦涉及到“出门串门”（跨文档导航，比如从 <code>a.html</code> 跳到 <code>b.html</code>），那熟悉的白屏闪烁又回来了。MPA（多页应用）的用户体验难道就只能停留在“上古时代”吗？</p>
<p>W3C 的大佬们显然不满足于此。于是，<strong>CSS View Transitions Module Level 2</strong> 应运而生，它的核心使命，就是<strong>将 Level 1 的丝滑体验，延伸到传统的跨文档导航场景</strong>，并在此基础上增加更多强大的功能！</p>
<p>今天，咱们就接着上一篇的步伐，重点探索 Level 2 的世界，看看它是如何打通跨文档的“任督二脉”，以及它带来了哪些令人兴奋的新特性！</p>
<h2>一、初心不改：Level 2 的核心目标与设计哲学</h2>
<p>Level 2 继承并扩展了 Level 1 的核心哲学：<strong>解耦 DOM 更新与视觉过渡</strong>。但它的目标更宏大：</p>
<ol>
<li><strong>拥抱 MPA：</strong> 正视 MPA 在 Web 生态中的重要地位，为其提供现代化的过渡体验。</li>
<li><strong>声明式优先：</strong> 尽可能通过简单的 CSS（<code>@view-transition</code> 规则）来启用跨文档转场，降低接入成本。</li>
<li><strong>生命周期钩子：</strong> 在跨文档导航的关键节点（旧页面卸载前、新页面展现前）提供 JS 事件 (<code>pageswap</code>, <code>pagereveal</code>)，赋予开发者精细控制的能力。</li>
<li><strong>能力增强：</strong> 不仅仅是解决跨文档问题，还基于实践反馈，加入了选择性转场、样式复用、自动命名、嵌套转场、分层捕获等一系列“武功秘籍”。</li>
</ol>
<p>简而言之，Level 2 就是要在尊重并兼容传统 MPA 架构的前提下，将流畅转场的能力普及化、标准化，并让它变得更强大、更灵活。</p>
<h2>二、入门：跨文档转场，只需“一句咒语”？</h2>
<p>想让你的 MPA 页面跳转也动起来？Level 2 说，基础操作很简单：</p>
<p><strong>核心开关：<code>@view-transition</code> 规则</strong></p>
<p>你需要在<strong>跳转前</strong>和<strong>跳转后</strong>两个页面的 CSS 中，都加入这个新的 <code>@</code> 规则，并设置 <code>navigation</code> 描述符：</p>
<pre><code class="language-css">/* 在 page-a.html 和 page-b.html 的 CSS 里都要有 */
@view-transition {
  navigation: auto; /* 关键先生！告诉浏览器，我想自动开启跨文档转场 */
}
</code></pre>
<p>只要加上这句，并且满足以下<strong>浏览器自动触发的条件</strong>：</p>
<ol>
<li><strong>同源（Same Origin）</strong>：安全第一，必须的。</li>
<li><strong>用户触发导航</strong>：点击链接、提交表单、浏览器前进/后退等。地址栏输入、书签等不算。</li>
<li><strong>页面可见</strong>：导航期间页面得在前台。</li>
<li><strong>无跨域重定向</strong>：中间不能有跨域跳转搅局。</li>
<li><strong>双方同意</strong>：两个页面都得写上 <code>navigation: auto;</code>。</li>
</ol>
<p>那么，恭喜你！从 <code>page-a.html</code> 跳转到 <code>page-b.html</code> 时，默认的<strong>交叉淡入淡出 (cross-fade)</strong> 效果就会自动应用。是不是比 Level 1 的 <code>document.startViewTransition</code> 更“傻瓜化”？</p>
<p>当然，这只是起点。默认效果往往不能满足我们骚动的心，我们需要更精妙的控制。</p>
<h2>三、进阶：掌控生命周期，定制跨文档之旅</h2>
<p>Level 1 里我们有 <code>startViewTransition</code> 的回调和返回的 <code>ViewTransition</code> 对象（包含 <code>ready</code>, <code>finished</code> 等 Promise）。在 Level 2 的跨文档场景下，流程变了，控制方式也随之升级：</p>
<p><strong>跨文档生命周期 &#x26; JS 钩子：</strong></p>
<ol>
<li>
<p><strong>用户操作 (Old Document):</strong> 点击链接/后退等。</p>
</li>
<li>
<p><strong><code>pageswap</code> 事件 (Old Document - <code>window</code> 上监听):</strong> 这是旧页面被换掉前的<strong>最后机会</strong>！</p>
<ul>
<li>你可以通过 <code>event.viewTransition</code>（如果转场条件满足，它就是个 <code>ViewTransition</code> 对象，否则为 <code>null</code>）来搞事情。</li>
<li><strong>用途：</strong>
<ul>
<li>检查导航信息（<code>event.activation</code>），比如 <code>navigationType</code> 是不是 <code>traverse</code> (前进/后退)。</li>
<li>动态给转场添加类型 <code>event.viewTransition.types.add('my-type')</code>，用于后续 CSS 选择性应用动画（见下文）。</li>
<li>根据某些条件决定<strong>跳过转场</strong> <code>event.viewTransition.skipTransition()</code>。</li>
<li>在 <code>event.viewTransition.finished</code> Promise 中执行清理工作（注意，这可能在页面从 BFCache 恢复后才触发）。</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">window.addEventListener("pageswap", (event) => {
  if (!event.viewTransition) return; // 不满足转场条件

  console.log("旧页面拜拜前，最后搞点事！");
  // 例如：给后退导航加个特殊类型
  if (event.activation.navigationType === "traverse") {
    event.viewTransition.types.add("going-back");
  }
});
</code></pre>
</li>
<li>
<p><strong>捕获旧状态 &#x26; 卸载旧页面。</strong></p>
</li>
<li>
<p><strong><code>pagereveal</code> 事件 (New Document - <code>window</code> 上监听):</strong> 新页面 DOM 加载完毕，<strong>首次渲染前</strong>触发。</p>
<ul>
<li>同样通过 <code>event.viewTransition</code>（如果转场是从旧页面成功启动的，这里就会有值）来操作。</li>
<li><strong>用途：</strong>
<ul>
<li>在新页面侧确认转场是否依然有效，或根据新页面的状态决定跳过。</li>
<li>可以在这里修改转场类型 <code>event.viewTransition.types.add/remove/clear()</code>。</li>
<li>等待 <code>event.viewTransition.ready</code> 来执行需要新旧状态都捕获完成才能开始的 JS 动画（类似 Level 1）。</li>
<li><strong>重要：</strong> Level 2 里，这个 <code>event.viewTransition</code> 的 <code>updateCallbackDone</code> Promise 是一开始就 resolved 的（因为 DOM 更新是浏览器导航完成的，不是由你的回调触发）。</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">window.addEventListener("pagereveal", async (event) => {
  if (!event.viewTransition) return; // 没有进行转场

  console.log("新页面来了，我瞅瞅！");
  // 例如：如果 URL 包含 #no-transition，就跳过
  if (location.hash.includes("no-transition")) {
    event.viewTransition.skipTransition();
    return;
  }
  // 可以等 ready 后用 JS 控制动画
  await event.viewTransition.ready;
  console.log("新旧状态都好了，准备浪起来！");
  // document.documentElement.animate(...)
});
</code></pre>
</li>
<li>
<p><strong>捕获新状态 &#x26; 执行动画 &#x26; 完成。</strong></p>
</li>
</ol>
<p><strong>新状态何时稳定？靠“渲染阻塞”！</strong></p>
<p>Level 2 没有 <code>updateCallback</code> Promise 了，浏览器怎么知道新页面何时“准备就绪”可以拍新照片了？答案是<strong>渲染阻塞机制 (Render-blocking mechanism)</strong>。</p>
<p>开发者可以通过给 <code>&#x3C;link rel="stylesheet"></code>, <code>&#x3C;script></code>, 甚至新增的 <code>&#x3C;link rel="expect" href="#element-id"></code> (等待特定元素出现) 添加 <code>blocking="render"</code> 属性，来告诉浏览器：“等这些关键资源加载/执行/元素就位后，再算我新页面稳定了，才能拍快照、启动动画！”</p>
<pre><code class="language-html">&#x3C;head>
  &#x3C;!-- 样式必须先应用 -->
  &#x3C;link rel="stylesheet" href="style.css" />
  &#x3C;!-- 默认就是 render-blocking -->
  &#x3C;!-- 这个 JS 可能调整布局，等它执行完 -->
  &#x3C;script src="layout-fix.js" blocking="render" async>&#x3C;/script>
  &#x3C;!-- 等主要内容区域加载并解析出来 -->
  &#x3C;link rel="expect" href="#main-content" blocking="render" />
&#x3C;/head>
</code></pre>
<p><strong>注意：</strong> 过度使用 <code>blocking="render"</code> 会让旧页面卡住太久，体验反而下降。要确保阻塞的资源能快速加载。</p>
<h2>四、精通：Level 2 的独门绝技，让转场更溜！</h2>
<p>Level 2 不仅仅是把 Level 1 搬到了跨文档，还带来了许多激动人心的新功能：</p>
<ol>
<li>
<p><strong>选择性视图转场 (Selective View Transitions):</strong></p>
<ul>
<li>
<p><strong>痛点：</strong> Level 1 里所有转场都一样，想根据不同交互（如导航 VS 卡片展开）应用不同动画比较麻烦。</p>
</li>
<li>
<p><strong>Level 2 方案：</strong> 引入 <strong><code>types</code></strong> 的概念。</p>
<ul>
<li><strong>设置类型：</strong>
<ul>
<li>通过 JS 在 <code>pageswap</code> / <code>pagereveal</code> 里 <code>event.viewTransition.types.add('your-type')</code>。</li>
<li>或者直接在 <code>@view-transition</code> 规则里声明：
<pre><code class="language-css">@view-transition {
  navigation: auto;
  types: slide-nav card-expand; /* 声明默认类型 */
}
</code></pre>
</li>
</ul>
</li>
<li><strong>匹配类型：</strong> 使用新的 CSS 伪类：
<ul>
<li><code>:active-view-transition</code>: 匹配有<strong>任何</strong>转场活动时的 <code>&#x3C;html></code>。</li>
<li><code>:active-view-transition-type(type1, type2...)</code>: 匹配活动转场的 <code>types</code> <strong>包含</strong>括号里<strong>至少一个</strong>类型时的 <code>&#x3C;html></code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>示例：</strong></p>
<pre><code class="language-css">/* 默认淡入淡出 */
::view-transition-old(root) {
  animation: fade-out 0.3s;
}
::view-transition-new(root) {
  animation: fade-in 0.3s;
}

/* 如果是导航滑动类型 */
:root:active-view-transition-type(slide-nav) ::view-transition-old(root) {
  animation-name: slide-left-out;
}
:root:active-view-transition-type(slide-nav) ::view-transition-new(root) {
  animation-name: slide-right-in;
}
</code></pre>
</li>
<li>
<p><strong>好处：</strong> 可以用清晰的 CSS 规则，为不同类型的转场定义不同的动画，逻辑分离。</p>
</li>
</ul>
</li>
<li>
<p><strong>样式复用 (<code>view-transition-class</code>):</strong></p>
<ul>
<li>
<p><strong>痛点：</strong> 很多元素 <code>view-transition-name</code> 不同，但想用同一套动画，写一堆 <code>::view-transition-group(name1)</code>, <code>::view-transition-group(name2)</code>... 太累。</p>
</li>
<li>
<p><strong>Level 2 方案：</strong> <code>view-transition-class</code> CSS 属性 + 类选择器语法。</p>
<pre><code class="language-css">/* 给所有卡片加上 class */
.card {
  view-transition-class: my-card;
  /* name 还是需要的，比如用 auto */
  view-transition-name: auto;
}

/* 用类选择器选中所有这些卡片的 group */
::view-transition-group(*.my-card) {
  /* 注意这个 *.classname 语法 */
  animation-timing-function: ease-in-out;
}
</code></pre>
</li>
<li>
<p><strong>好处：</strong> DRY！极大简化了对共享动画行为的元素的样式定义。</p>
</li>
</ul>
</li>
<li>
<p><strong>自动 <code>view-transition-name</code>:</strong></p>
<ul>
<li><strong>痛点：</strong> 手动给列表项等大量元素起名字太烦。</li>
<li><strong>Level 2 方案：</strong> <code>view-transition-name: auto;</code>
<ul>
<li>有 <code>id</code> 就用 <code>id</code>。</li>
<li>没 <code>id</code> 浏览器内部生成唯一标识。</li>
</ul>
</li>
<li><strong>跨文档注意！！！</strong> <code>auto</code> 生成的、非 <code>id</code> 的名字，在<strong>新旧文档间不会匹配</strong>！这意味着它们总是触发进入/退出动画，而不是平滑过渡。想让元素在新旧页面平滑连接，还是要确保它们有<strong>相同且稳定</strong>的 <code>view-transition-name</code>（用 <code>id</code> 或手动指定相同 name）。</li>
</ul>
</li>
<li>
<p><strong>嵌套视图转场 (<code>view-transition-group</code> CSS 属性):</strong></p>
<ul>
<li>
<p><strong>痛点：</strong> Level 1 的扁平伪元素树无法处理父元素的 <code>clip-path</code>, <code>overflow: hidden</code>, <code>filter</code>, <code>opacity</code> 或复杂的 3D 变换，导致动画效果失真。</p>
</li>
<li>
<p><strong>Level 2 方案：</strong> <code>view-transition-group</code> CSS 属性，允许你指定一个父级 <code>view-transition-name</code> (或 <code>nearest</code>, <code>contain</code>)，从而构建嵌套的伪元素树。</p>
<pre><code class="language-css">.container {
  view-transition-name: container;
  clip-path: circle(50%);
}
.content-inside {
  view-transition-name: content;
  /* 让 content 的 group 成为 container group 的子元素 */
  view-transition-group: container;
}

/* 现在可以给 container group 加 clip-path 动画 */
::view-transition-group(container) {
  animation: clip-reveal 0.5s;
}
</code></pre>
</li>
<li>
<p><strong>好处：</strong> 动画能更好地反映 DOM 的层级和效果（如剪裁、滤镜），实现更复杂的视觉效果。</p>
</li>
</ul>
</li>
<li>
<p><strong>分层捕获 (Layered Capture - 底层改进):</strong></p>
<ul>
<li><strong>痛点：</strong> Level 1 的快照是扁平图片，<code>border</code>, <code>background-gradient</code>, <code>box-shadow</code>, <code>filter</code> 等效果无法独立动画，只能跟着图片一起变形或淡变，很生硬。</li>
<li><strong>Level 2 方案：</strong> 浏览器不再只拍一张扁平快照，而是捕获元素的多个 CSS 属性层（如背景、边框、阴影、滤镜、透明度、内边距等），并在动画时对这些<strong>属性本身</strong>进行插值。</li>
<li><strong>好处：</strong> 动画效果大大丰富！边框可以平滑变色变形，渐变背景可以流畅过渡，阴影和滤镜也能动起来，视觉表现力提升一个档次！这使得转场感觉更“原生”，而不是简单的图片切换。</li>
</ul>
</li>
</ol>
<h2>五、注意事项与未来展望</h2>
<ul>
<li><strong>安全：</strong> 依然严格限制同源，并处理了跨域重定向问题。</li>
<li><strong>兼容性：</strong> <strong>划重点！Level 2 目前 (2025-4-7) 仍是 W3C 工作草案 (Working Draft)</strong>，API 和行为可能变化，浏览器支持尚不完善或处于实验阶段。生产环境使用务必谨慎，关注 Can I use 和浏览器厂商动态。</li>
<li><strong>性能：</strong> 复杂的嵌套、大量的独立元素、消耗大的动画依然需要关注性能测试和优化。</li>
<li><strong>调试：</strong> 现代浏览器开发者工具正在逐步增强对 View Transitions（包括 Level 2 特性）的调试支持。</li>
</ul>
<h2>六、总结：MPA 的春天，体验的飞跃</h2>
<p>CSS View Transitions Module Level 2 是对 Level 1 的一次意义重大的扩展和增强。它不仅将丝滑的转场体验带给了更广泛的 MPA 网站，还通过 <code>types</code>、<code>view-transition-class</code>、<code>auto</code> name、<code>view-transition-group</code> 属性以及底层的分层捕获，极大地提升了转场的灵活性、开发效率和视觉表现力。</p>
<p>虽然还是草案，但它描绘的未来无疑是激动人心的。掌握了 View Transitions Level 1 和 Level 2，你就拥有了打造下一代 Web 流畅体验的利器。</p>
<p>希望这篇结合了 Level 1 回顾与 Level 2 深入的探索，能让你对 View Transitions 有一个更全面、更深入的认识。赶紧动手尝试（在支持的实验性浏览器中），感受这触手可及的未来吧！</p>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.w3.org/TR/css-view-transitions-1/">W3C CSS View Transitions Module Level 1 Spec</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API">MDN 文档: View Transitions API</a></li>
<li><a href="https://developer.chrome.com/docs/web-platform/view-transitions/cross-document">Cross-document view transitions for multi-page applications</a></li>
<li><a href="https://caniuse.com/view-transitions"><code>caniuse View Transitions (cross-document)</code></a>
<ul>
<li>chrome 126+</li>
<li>safari 18.2+</li>
</ul>
</li>
</ul></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0055.css-view-transitions-2"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0055.css-view-transitions-2.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"title":"View Transitions API (Level-2 cross-document)","date":"!Date:2025-04-07T10:14:23.721Z","updated":"!Date:2025-04-07T10:14:23.721Z"},"metadata":{"title":"View Transitions API (Level-2 cross-document)","date":"!Date:2025-04-07T10:14:23.721Z","updated":"!Date:2025-04-07T10:14:23.721Z","id":"0055.css-view-transitions-2","createdAt":"!Date:2025-04-07T10:14:23.721Z","updatedAt":"!Date:2025-04-07T10:14:23.721Z","tags":[]},"htmlContent":"\u003cp>上一篇文章咱们聊了 \u003ca href=\"/article/0054.css-view-transitions-1\">View Transitions API (Level-1 single-document)\u003c/a> 如何优雅地解决了 SPA（单页应用）里那为了动画而扭曲 DOM、编写复杂 JS 的痛点。通过 \u003ccode>document.startViewTransition\u003c/code>、快照机制和神奇的伪元素树，它成功地将 \u003cstrong>DOM 状态更新\u003c/strong> 与 \u003cstrong>视觉过渡动画\u003c/strong> 解耦，让开发者能轻松实现丝滑的同文档视图切换。\u003c/p>\n\u003cp>但是，Level 1 的能力仅限于“家里面”（同一个文档）。一旦涉及到“出门串门”（跨文档导航，比如从 \u003ccode>a.html\u003c/code> 跳到 \u003ccode>b.html\u003c/code>），那熟悉的白屏闪烁又回来了。MPA（多页应用）的用户体验难道就只能停留在“上古时代”吗？\u003c/p>\n\u003cp>W3C 的大佬们显然不满足于此。于是，\u003cstrong>CSS View Transitions Module Level 2\u003c/strong> 应运而生，它的核心使命，就是\u003cstrong>将 Level 1 的丝滑体验，延伸到传统的跨文档导航场景\u003c/strong>，并在此基础上增加更多强大的功能！\u003c/p>\n\u003cp>今天，咱们就接着上一篇的步伐，重点探索 Level 2 的世界，看看它是如何打通跨文档的“任督二脉”，以及它带来了哪些令人兴奋的新特性！\u003c/p>\n\u003ch2>一、初心不改：Level 2 的核心目标与设计哲学\u003c/h2>\n\u003cp>Level 2 继承并扩展了 Level 1 的核心哲学：\u003cstrong>解耦 DOM 更新与视觉过渡\u003c/strong>。但它的目标更宏大：\u003c/p>\n\u003col>\n\u003cli>\u003cstrong>拥抱 MPA：\u003c/strong> 正视 MPA 在 Web 生态中的重要地位，为其提供现代化的过渡体验。\u003c/li>\n\u003cli>\u003cstrong>声明式优先：\u003c/strong> 尽可能通过简单的 CSS（\u003ccode>@view-transition\u003c/code> 规则）来启用跨文档转场，降低接入成本。\u003c/li>\n\u003cli>\u003cstrong>生命周期钩子：\u003c/strong> 在跨文档导航的关键节点（旧页面卸载前、新页面展现前）提供 JS 事件 (\u003ccode>pageswap\u003c/code>, \u003ccode>pagereveal\u003c/code>)，赋予开发者精细控制的能力。\u003c/li>\n\u003cli>\u003cstrong>能力增强：\u003c/strong> 不仅仅是解决跨文档问题，还基于实践反馈，加入了选择性转场、样式复用、自动命名、嵌套转场、分层捕获等一系列“武功秘籍”。\u003c/li>\n\u003c/ol>\n\u003cp>简而言之，Level 2 就是要在尊重并兼容传统 MPA 架构的前提下，将流畅转场的能力普及化、标准化，并让它变得更强大、更灵活。\u003c/p>\n\u003ch2>二、入门：跨文档转场，只需“一句咒语”？\u003c/h2>\n\u003cp>想让你的 MPA 页面跳转也动起来？Level 2 说，基础操作很简单：\u003c/p>\n\u003cp>\u003cstrong>核心开关：\u003ccode>@view-transition\u003c/code> 规则\u003c/strong>\u003c/p>\n\u003cp>你需要在\u003cstrong>跳转前\u003c/strong>和\u003cstrong>跳转后\u003c/strong>两个页面的 CSS 中，都加入这个新的 \u003ccode>@\u003c/code> 规则，并设置 \u003ccode>navigation\u003c/code> 描述符：\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">/* 在 page-a.html 和 page-b.html 的 CSS 里都要有 */\n@view-transition {\n  navigation: auto; /* 关键先生！告诉浏览器，我想自动开启跨文档转场 */\n}\n\u003c/code>\u003c/pre>\n\u003cp>只要加上这句，并且满足以下\u003cstrong>浏览器自动触发的条件\u003c/strong>：\u003c/p>\n\u003col>\n\u003cli>\u003cstrong>同源（Same Origin）\u003c/strong>：安全第一，必须的。\u003c/li>\n\u003cli>\u003cstrong>用户触发导航\u003c/strong>：点击链接、提交表单、浏览器前进/后退等。地址栏输入、书签等不算。\u003c/li>\n\u003cli>\u003cstrong>页面可见\u003c/strong>：导航期间页面得在前台。\u003c/li>\n\u003cli>\u003cstrong>无跨域重定向\u003c/strong>：中间不能有跨域跳转搅局。\u003c/li>\n\u003cli>\u003cstrong>双方同意\u003c/strong>：两个页面都得写上 \u003ccode>navigation: auto;\u003c/code>。\u003c/li>\n\u003c/ol>\n\u003cp>那么，恭喜你！从 \u003ccode>page-a.html\u003c/code> 跳转到 \u003ccode>page-b.html\u003c/code> 时，默认的\u003cstrong>交叉淡入淡出 (cross-fade)\u003c/strong> 效果就会自动应用。是不是比 Level 1 的 \u003ccode>document.startViewTransition\u003c/code> 更“傻瓜化”？\u003c/p>\n\u003cp>当然，这只是起点。默认效果往往不能满足我们骚动的心，我们需要更精妙的控制。\u003c/p>\n\u003ch2>三、进阶：掌控生命周期，定制跨文档之旅\u003c/h2>\n\u003cp>Level 1 里我们有 \u003ccode>startViewTransition\u003c/code> 的回调和返回的 \u003ccode>ViewTransition\u003c/code> 对象（包含 \u003ccode>ready\u003c/code>, \u003ccode>finished\u003c/code> 等 Promise）。在 Level 2 的跨文档场景下，流程变了，控制方式也随之升级：\u003c/p>\n\u003cp>\u003cstrong>跨文档生命周期 &#x26; JS 钩子：\u003c/strong>\u003c/p>\n\u003col>\n\u003cli>\n\u003cp>\u003cstrong>用户操作 (Old Document):\u003c/strong> 点击链接/后退等。\u003c/p>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>\u003ccode>pageswap\u003c/code> 事件 (Old Document - \u003ccode>window\u003c/code> 上监听):\u003c/strong> 这是旧页面被换掉前的\u003cstrong>最后机会\u003c/strong>！\u003c/p>\n\u003cul>\n\u003cli>你可以通过 \u003ccode>event.viewTransition\u003c/code>（如果转场条件满足，它就是个 \u003ccode>ViewTransition\u003c/code> 对象，否则为 \u003ccode>null\u003c/code>）来搞事情。\u003c/li>\n\u003cli>\u003cstrong>用途：\u003c/strong>\n\u003cul>\n\u003cli>检查导航信息（\u003ccode>event.activation\u003c/code>），比如 \u003ccode>navigationType\u003c/code> 是不是 \u003ccode>traverse\u003c/code> (前进/后退)。\u003c/li>\n\u003cli>动态给转场添加类型 \u003ccode>event.viewTransition.types.add('my-type')\u003c/code>，用于后续 CSS 选择性应用动画（见下文）。\u003c/li>\n\u003cli>根据某些条件决定\u003cstrong>跳过转场\u003c/strong> \u003ccode>event.viewTransition.skipTransition()\u003c/code>。\u003c/li>\n\u003cli>在 \u003ccode>event.viewTransition.finished\u003c/code> Promise 中执行清理工作（注意，这可能在页面从 BFCache 恢复后才触发）。\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003c/ul>\n\u003cpre>\u003ccode class=\"language-javascript\">window.addEventListener(\"pageswap\", (event) => {\n  if (!event.viewTransition) return; // 不满足转场条件\n\n  console.log(\"旧页面拜拜前，最后搞点事！\");\n  // 例如：给后退导航加个特殊类型\n  if (event.activation.navigationType === \"traverse\") {\n    event.viewTransition.types.add(\"going-back\");\n  }\n});\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>捕获旧状态 &#x26; 卸载旧页面。\u003c/strong>\u003c/p>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>\u003ccode>pagereveal\u003c/code> 事件 (New Document - \u003ccode>window\u003c/code> 上监听):\u003c/strong> 新页面 DOM 加载完毕，\u003cstrong>首次渲染前\u003c/strong>触发。\u003c/p>\n\u003cul>\n\u003cli>同样通过 \u003ccode>event.viewTransition\u003c/code>（如果转场是从旧页面成功启动的，这里就会有值）来操作。\u003c/li>\n\u003cli>\u003cstrong>用途：\u003c/strong>\n\u003cul>\n\u003cli>在新页面侧确认转场是否依然有效，或根据新页面的状态决定跳过。\u003c/li>\n\u003cli>可以在这里修改转场类型 \u003ccode>event.viewTransition.types.add/remove/clear()\u003c/code>。\u003c/li>\n\u003cli>等待 \u003ccode>event.viewTransition.ready\u003c/code> 来执行需要新旧状态都捕获完成才能开始的 JS 动画（类似 Level 1）。\u003c/li>\n\u003cli>\u003cstrong>重要：\u003c/strong> Level 2 里，这个 \u003ccode>event.viewTransition\u003c/code> 的 \u003ccode>updateCallbackDone\u003c/code> Promise 是一开始就 resolved 的（因为 DOM 更新是浏览器导航完成的，不是由你的回调触发）。\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003c/ul>\n\u003cpre>\u003ccode class=\"language-javascript\">window.addEventListener(\"pagereveal\", async (event) => {\n  if (!event.viewTransition) return; // 没有进行转场\n\n  console.log(\"新页面来了，我瞅瞅！\");\n  // 例如：如果 URL 包含 #no-transition，就跳过\n  if (location.hash.includes(\"no-transition\")) {\n    event.viewTransition.skipTransition();\n    return;\n  }\n  // 可以等 ready 后用 JS 控制动画\n  await event.viewTransition.ready;\n  console.log(\"新旧状态都好了，准备浪起来！\");\n  // document.documentElement.animate(...)\n});\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>捕获新状态 &#x26; 执行动画 &#x26; 完成。\u003c/strong>\u003c/p>\n\u003c/li>\n\u003c/ol>\n\u003cp>\u003cstrong>新状态何时稳定？靠“渲染阻塞”！\u003c/strong>\u003c/p>\n\u003cp>Level 2 没有 \u003ccode>updateCallback\u003c/code> Promise 了，浏览器怎么知道新页面何时“准备就绪”可以拍新照片了？答案是\u003cstrong>渲染阻塞机制 (Render-blocking mechanism)\u003c/strong>。\u003c/p>\n\u003cp>开发者可以通过给 \u003ccode>&#x3C;link rel=\"stylesheet\">\u003c/code>, \u003ccode>&#x3C;script>\u003c/code>, 甚至新增的 \u003ccode>&#x3C;link rel=\"expect\" href=\"#element-id\">\u003c/code> (等待特定元素出现) 添加 \u003ccode>blocking=\"render\"\u003c/code> 属性，来告诉浏览器：“等这些关键资源加载/执行/元素就位后，再算我新页面稳定了，才能拍快照、启动动画！”\u003c/p>\n\u003cpre>\u003ccode class=\"language-html\">&#x3C;head>\n  &#x3C;!-- 样式必须先应用 -->\n  &#x3C;link rel=\"stylesheet\" href=\"style.css\" />\n  &#x3C;!-- 默认就是 render-blocking -->\n  &#x3C;!-- 这个 JS 可能调整布局，等它执行完 -->\n  &#x3C;script src=\"layout-fix.js\" blocking=\"render\" async>&#x3C;/script>\n  &#x3C;!-- 等主要内容区域加载并解析出来 -->\n  &#x3C;link rel=\"expect\" href=\"#main-content\" blocking=\"render\" />\n&#x3C;/head>\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>注意：\u003c/strong> 过度使用 \u003ccode>blocking=\"render\"\u003c/code> 会让旧页面卡住太久，体验反而下降。要确保阻塞的资源能快速加载。\u003c/p>\n\u003ch2>四、精通：Level 2 的独门绝技，让转场更溜！\u003c/h2>\n\u003cp>Level 2 不仅仅是把 Level 1 搬到了跨文档，还带来了许多激动人心的新功能：\u003c/p>\n\u003col>\n\u003cli>\n\u003cp>\u003cstrong>选择性视图转场 (Selective View Transitions):\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\n\u003cp>\u003cstrong>痛点：\u003c/strong> Level 1 里所有转场都一样，想根据不同交互（如导航 VS 卡片展开）应用不同动画比较麻烦。\u003c/p>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>Level 2 方案：\u003c/strong> 引入 \u003cstrong>\u003ccode>types\u003c/code>\u003c/strong> 的概念。\u003c/p>\n\u003cul>\n\u003cli>\u003cstrong>设置类型：\u003c/strong>\n\u003cul>\n\u003cli>通过 JS 在 \u003ccode>pageswap\u003c/code> / \u003ccode>pagereveal\u003c/code> 里 \u003ccode>event.viewTransition.types.add('your-type')\u003c/code>。\u003c/li>\n\u003cli>或者直接在 \u003ccode>@view-transition\u003c/code> 规则里声明：\n\u003cpre>\u003ccode class=\"language-css\">@view-transition {\n  navigation: auto;\n  types: slide-nav card-expand; /* 声明默认类型 */\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003cli>\u003cstrong>匹配类型：\u003c/strong> 使用新的 CSS 伪类：\n\u003cul>\n\u003cli>\u003ccode>:active-view-transition\u003c/code>: 匹配有\u003cstrong>任何\u003c/strong>转场活动时的 \u003ccode>&#x3C;html>\u003c/code>。\u003c/li>\n\u003cli>\u003ccode>:active-view-transition-type(type1, type2...)\u003c/code>: 匹配活动转场的 \u003ccode>types\u003c/code> \u003cstrong>包含\u003c/strong>括号里\u003cstrong>至少一个\u003c/strong>类型时的 \u003ccode>&#x3C;html>\u003c/code>。\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>示例：\u003c/strong>\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">/* 默认淡入淡出 */\n::view-transition-old(root) {\n  animation: fade-out 0.3s;\n}\n::view-transition-new(root) {\n  animation: fade-in 0.3s;\n}\n\n/* 如果是导航滑动类型 */\n:root:active-view-transition-type(slide-nav) ::view-transition-old(root) {\n  animation-name: slide-left-out;\n}\n:root:active-view-transition-type(slide-nav) ::view-transition-new(root) {\n  animation-name: slide-right-in;\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>好处：\u003c/strong> 可以用清晰的 CSS 规则，为不同类型的转场定义不同的动画，逻辑分离。\u003c/p>\n\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>样式复用 (\u003ccode>view-transition-class\u003c/code>):\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\n\u003cp>\u003cstrong>痛点：\u003c/strong> 很多元素 \u003ccode>view-transition-name\u003c/code> 不同，但想用同一套动画，写一堆 \u003ccode>::view-transition-group(name1)\u003c/code>, \u003ccode>::view-transition-group(name2)\u003c/code>... 太累。\u003c/p>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>Level 2 方案：\u003c/strong> \u003ccode>view-transition-class\u003c/code> CSS 属性 + 类选择器语法。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">/* 给所有卡片加上 class */\n.card {\n  view-transition-class: my-card;\n  /* name 还是需要的，比如用 auto */\n  view-transition-name: auto;\n}\n\n/* 用类选择器选中所有这些卡片的 group */\n::view-transition-group(*.my-card) {\n  /* 注意这个 *.classname 语法 */\n  animation-timing-function: ease-in-out;\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>好处：\u003c/strong> DRY！极大简化了对共享动画行为的元素的样式定义。\u003c/p>\n\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>自动 \u003ccode>view-transition-name\u003c/code>:\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\u003cstrong>痛点：\u003c/strong> 手动给列表项等大量元素起名字太烦。\u003c/li>\n\u003cli>\u003cstrong>Level 2 方案：\u003c/strong> \u003ccode>view-transition-name: auto;\u003c/code>\n\u003cul>\n\u003cli>有 \u003ccode>id\u003c/code> 就用 \u003ccode>id\u003c/code>。\u003c/li>\n\u003cli>没 \u003ccode>id\u003c/code> 浏览器内部生成唯一标识。\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003cli>\u003cstrong>跨文档注意！！！\u003c/strong> \u003ccode>auto\u003c/code> 生成的、非 \u003ccode>id\u003c/code> 的名字，在\u003cstrong>新旧文档间不会匹配\u003c/strong>！这意味着它们总是触发进入/退出动画，而不是平滑过渡。想让元素在新旧页面平滑连接，还是要确保它们有\u003cstrong>相同且稳定\u003c/strong>的 \u003ccode>view-transition-name\u003c/code>（用 \u003ccode>id\u003c/code> 或手动指定相同 name）。\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>嵌套视图转场 (\u003ccode>view-transition-group\u003c/code> CSS 属性):\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\n\u003cp>\u003cstrong>痛点：\u003c/strong> Level 1 的扁平伪元素树无法处理父元素的 \u003ccode>clip-path\u003c/code>, \u003ccode>overflow: hidden\u003c/code>, \u003ccode>filter\u003c/code>, \u003ccode>opacity\u003c/code> 或复杂的 3D 变换，导致动画效果失真。\u003c/p>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>Level 2 方案：\u003c/strong> \u003ccode>view-transition-group\u003c/code> CSS 属性，允许你指定一个父级 \u003ccode>view-transition-name\u003c/code> (或 \u003ccode>nearest\u003c/code>, \u003ccode>contain\u003c/code>)，从而构建嵌套的伪元素树。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.container {\n  view-transition-name: container;\n  clip-path: circle(50%);\n}\n.content-inside {\n  view-transition-name: content;\n  /* 让 content 的 group 成为 container group 的子元素 */\n  view-transition-group: container;\n}\n\n/* 现在可以给 container group 加 clip-path 动画 */\n::view-transition-group(container) {\n  animation: clip-reveal 0.5s;\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>好处：\u003c/strong> 动画能更好地反映 DOM 的层级和效果（如剪裁、滤镜），实现更复杂的视觉效果。\u003c/p>\n\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>分层捕获 (Layered Capture - 底层改进):\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\u003cstrong>痛点：\u003c/strong> Level 1 的快照是扁平图片，\u003ccode>border\u003c/code>, \u003ccode>background-gradient\u003c/code>, \u003ccode>box-shadow\u003c/code>, \u003ccode>filter\u003c/code> 等效果无法独立动画，只能跟着图片一起变形或淡变，很生硬。\u003c/li>\n\u003cli>\u003cstrong>Level 2 方案：\u003c/strong> 浏览器不再只拍一张扁平快照，而是捕获元素的多个 CSS 属性层（如背景、边框、阴影、滤镜、透明度、内边距等），并在动画时对这些\u003cstrong>属性本身\u003c/strong>进行插值。\u003c/li>\n\u003cli>\u003cstrong>好处：\u003c/strong> 动画效果大大丰富！边框可以平滑变色变形，渐变背景可以流畅过渡，阴影和滤镜也能动起来，视觉表现力提升一个档次！这使得转场感觉更“原生”，而不是简单的图片切换。\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003c/ol>\n\u003ch2>五、注意事项与未来展望\u003c/h2>\n\u003cul>\n\u003cli>\u003cstrong>安全：\u003c/strong> 依然严格限制同源，并处理了跨域重定向问题。\u003c/li>\n\u003cli>\u003cstrong>兼容性：\u003c/strong> \u003cstrong>划重点！Level 2 目前 (2025-4-7) 仍是 W3C 工作草案 (Working Draft)\u003c/strong>，API 和行为可能变化，浏览器支持尚不完善或处于实验阶段。生产环境使用务必谨慎，关注 Can I use 和浏览器厂商动态。\u003c/li>\n\u003cli>\u003cstrong>性能：\u003c/strong> 复杂的嵌套、大量的独立元素、消耗大的动画依然需要关注性能测试和优化。\u003c/li>\n\u003cli>\u003cstrong>调试：\u003c/strong> 现代浏览器开发者工具正在逐步增强对 View Transitions（包括 Level 2 特性）的调试支持。\u003c/li>\n\u003c/ul>\n\u003ch2>六、总结：MPA 的春天，体验的飞跃\u003c/h2>\n\u003cp>CSS View Transitions Module Level 2 是对 Level 1 的一次意义重大的扩展和增强。它不仅将丝滑的转场体验带给了更广泛的 MPA 网站，还通过 \u003ccode>types\u003c/code>、\u003ccode>view-transition-class\u003c/code>、\u003ccode>auto\u003c/code> name、\u003ccode>view-transition-group\u003c/code> 属性以及底层的分层捕获，极大地提升了转场的灵活性、开发效率和视觉表现力。\u003c/p>\n\u003cp>虽然还是草案，但它描绘的未来无疑是激动人心的。掌握了 View Transitions Level 1 和 Level 2，你就拥有了打造下一代 Web 流畅体验的利器。\u003c/p>\n\u003cp>希望这篇结合了 Level 1 回顾与 Level 2 深入的探索，能让你对 View Transitions 有一个更全面、更深入的认识。赶紧动手尝试（在支持的实验性浏览器中），感受这触手可及的未来吧！\u003c/p>\n\u003cp>\u003cstrong>参考资料：\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\u003ca href=\"https://www.w3.org/TR/css-view-transitions-1/\">W3C CSS View Transitions Module Level 1 Spec\u003c/a>\u003c/li>\n\u003cli>\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API\">MDN 文档: View Transitions API\u003c/a>\u003c/li>\n\u003cli>\u003ca href=\"https://developer.chrome.com/docs/web-platform/view-transitions/cross-document\">Cross-document view transitions for multi-page applications\u003c/a>\u003c/li>\n\u003cli>\u003ca href=\"https://caniuse.com/view-transitions\">\u003ccode>caniuse View Transitions (cross-document)\u003c/code>\u003c/a>\n\u003cul>\n\u003cli>chrome 126+\u003c/li>\n\u003cli>safari 18.2+\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003c/ul>","markdownContent":"\n上一篇文章咱们聊了 [View Transitions API (Level-1 single-document)](/article/0054.css-view-transitions-1) 如何优雅地解决了 SPA（单页应用）里那为了动画而扭曲 DOM、编写复杂 JS 的痛点。通过 `document.startViewTransition`、快照机制和神奇的伪元素树，它成功地将 **DOM 状态更新** 与 **视觉过渡动画** 解耦，让开发者能轻松实现丝滑的同文档视图切换。\n\n但是，Level 1 的能力仅限于“家里面”（同一个文档）。一旦涉及到“出门串门”（跨文档导航，比如从 `a.html` 跳到 `b.html`），那熟悉的白屏闪烁又回来了。MPA（多页应用）的用户体验难道就只能停留在“上古时代”吗？\n\nW3C 的大佬们显然不满足于此。于是，**CSS View Transitions Module Level 2** 应运而生，它的核心使命，就是**将 Level 1 的丝滑体验，延伸到传统的跨文档导航场景**，并在此基础上增加更多强大的功能！\n\n今天，咱们就接着上一篇的步伐，重点探索 Level 2 的世界，看看它是如何打通跨文档的“任督二脉”，以及它带来了哪些令人兴奋的新特性！\n\n## 一、初心不改：Level 2 的核心目标与设计哲学\n\nLevel 2 继承并扩展了 Level 1 的核心哲学：**解耦 DOM 更新与视觉过渡**。但它的目标更宏大：\n\n1.  **拥抱 MPA：** 正视 MPA 在 Web 生态中的重要地位，为其提供现代化的过渡体验。\n2.  **声明式优先：** 尽可能通过简单的 CSS（`@view-transition` 规则）来启用跨文档转场，降低接入成本。\n3.  **生命周期钩子：** 在跨文档导航的关键节点（旧页面卸载前、新页面展现前）提供 JS 事件 (`pageswap`, `pagereveal`)，赋予开发者精细控制的能力。\n4.  **能力增强：** 不仅仅是解决跨文档问题，还基于实践反馈，加入了选择性转场、样式复用、自动命名、嵌套转场、分层捕获等一系列“武功秘籍”。\n\n简而言之，Level 2 就是要在尊重并兼容传统 MPA 架构的前提下，将流畅转场的能力普及化、标准化，并让它变得更强大、更灵活。\n\n## 二、入门：跨文档转场，只需“一句咒语”？\n\n想让你的 MPA 页面跳转也动起来？Level 2 说，基础操作很简单：\n\n**核心开关：`@view-transition` 规则**\n\n你需要在**跳转前**和**跳转后**两个页面的 CSS 中，都加入这个新的 `@` 规则，并设置 `navigation` 描述符：\n\n```css\n/* 在 page-a.html 和 page-b.html 的 CSS 里都要有 */\n@view-transition {\n  navigation: auto; /* 关键先生！告诉浏览器，我想自动开启跨文档转场 */\n}\n```\n\n只要加上这句，并且满足以下**浏览器自动触发的条件**：\n\n1.  **同源（Same Origin）**：安全第一，必须的。\n2.  **用户触发导航**：点击链接、提交表单、浏览器前进/后退等。地址栏输入、书签等不算。\n3.  **页面可见**：导航期间页面得在前台。\n4.  **无跨域重定向**：中间不能有跨域跳转搅局。\n5.  **双方同意**：两个页面都得写上 `navigation: auto;`。\n\n那么，恭喜你！从 `page-a.html` 跳转到 `page-b.html` 时，默认的**交叉淡入淡出 (cross-fade)** 效果就会自动应用。是不是比 Level 1 的 `document.startViewTransition` 更“傻瓜化”？\n\n当然，这只是起点。默认效果往往不能满足我们骚动的心，我们需要更精妙的控制。\n\n## 三、进阶：掌控生命周期，定制跨文档之旅\n\nLevel 1 里我们有 `startViewTransition` 的回调和返回的 `ViewTransition` 对象（包含 `ready`, `finished` 等 Promise）。在 Level 2 的跨文档场景下，流程变了，控制方式也随之升级：\n\n**跨文档生命周期 & JS 钩子：**\n\n1.  **用户操作 (Old Document):** 点击链接/后退等。\n2.  **`pageswap` 事件 (Old Document - `window` 上监听):** 这是旧页面被换掉前的**最后机会**！\n\n    - 你可以通过 `event.viewTransition`（如果转场条件满足，它就是个 `ViewTransition` 对象，否则为 `null`）来搞事情。\n    - **用途：**\n      - 检查导航信息（`event.activation`），比如 `navigationType` 是不是 `traverse` (前进/后退)。\n      - 动态给转场添加类型 `event.viewTransition.types.add('my-type')`，用于后续 CSS 选择性应用动画（见下文）。\n      - 根据某些条件决定**跳过转场** `event.viewTransition.skipTransition()`。\n      - 在 `event.viewTransition.finished` Promise 中执行清理工作（注意，这可能在页面从 BFCache 恢复后才触发）。\n\n    ```javascript\n    window.addEventListener(\"pageswap\", (event) => {\n      if (!event.viewTransition) return; // 不满足转场条件\n\n      console.log(\"旧页面拜拜前，最后搞点事！\");\n      // 例如：给后退导航加个特殊类型\n      if (event.activation.navigationType === \"traverse\") {\n        event.viewTransition.types.add(\"going-back\");\n      }\n    });\n    ```\n\n3.  **捕获旧状态 & 卸载旧页面。**\n4.  **`pagereveal` 事件 (New Document - `window` 上监听):** 新页面 DOM 加载完毕，**首次渲染前**触发。\n\n    - 同样通过 `event.viewTransition`（如果转场是从旧页面成功启动的，这里就会有值）来操作。\n    - **用途：**\n      - 在新页面侧确认转场是否依然有效，或根据新页面的状态决定跳过。\n      - 可以在这里修改转场类型 `event.viewTransition.types.add/remove/clear()`。\n      - 等待 `event.viewTransition.ready` 来执行需要新旧状态都捕获完成才能开始的 JS 动画（类似 Level 1）。\n      - **重要：** Level 2 里，这个 `event.viewTransition` 的 `updateCallbackDone` Promise 是一开始就 resolved 的（因为 DOM 更新是浏览器导航完成的，不是由你的回调触发）。\n\n    ```javascript\n    window.addEventListener(\"pagereveal\", async (event) => {\n      if (!event.viewTransition) return; // 没有进行转场\n\n      console.log(\"新页面来了，我瞅瞅！\");\n      // 例如：如果 URL 包含 #no-transition，就跳过\n      if (location.hash.includes(\"no-transition\")) {\n        event.viewTransition.skipTransition();\n        return;\n      }\n      // 可以等 ready 后用 JS 控制动画\n      await event.viewTransition.ready;\n      console.log(\"新旧状态都好了，准备浪起来！\");\n      // document.documentElement.animate(...)\n    });\n    ```\n\n5.  **捕获新状态 & 执行动画 & 完成。**\n\n**新状态何时稳定？靠“渲染阻塞”！**\n\nLevel 2 没有 `updateCallback` Promise 了，浏览器怎么知道新页面何时“准备就绪”可以拍新照片了？答案是**渲染阻塞机制 (Render-blocking mechanism)**。\n\n开发者可以通过给 `\u003clink rel=\"stylesheet\">`, `\u003cscript>`, 甚至新增的 `\u003clink rel=\"expect\" href=\"#element-id\">` (等待特定元素出现) 添加 `blocking=\"render\"` 属性，来告诉浏览器：“等这些关键资源加载/执行/元素就位后，再算我新页面稳定了，才能拍快照、启动动画！”\n\n```html\n\u003chead>\n  \u003c!-- 样式必须先应用 -->\n  \u003clink rel=\"stylesheet\" href=\"style.css\" />\n  \u003c!-- 默认就是 render-blocking -->\n  \u003c!-- 这个 JS 可能调整布局，等它执行完 -->\n  \u003cscript src=\"layout-fix.js\" blocking=\"render\" async>\u003c/script>\n  \u003c!-- 等主要内容区域加载并解析出来 -->\n  \u003clink rel=\"expect\" href=\"#main-content\" blocking=\"render\" />\n\u003c/head>\n```\n\n**注意：** 过度使用 `blocking=\"render\"` 会让旧页面卡住太久，体验反而下降。要确保阻塞的资源能快速加载。\n\n## 四、精通：Level 2 的独门绝技，让转场更溜！\n\nLevel 2 不仅仅是把 Level 1 搬到了跨文档，还带来了许多激动人心的新功能：\n\n1.  **选择性视图转场 (Selective View Transitions):**\n\n    - **痛点：** Level 1 里所有转场都一样，想根据不同交互（如导航 VS 卡片展开）应用不同动画比较麻烦。\n    - **Level 2 方案：** 引入 **`types`** 的概念。\n      - **设置类型：**\n        - 通过 JS 在 `pageswap` / `pagereveal` 里 `event.viewTransition.types.add('your-type')`。\n        - 或者直接在 `@view-transition` 规则里声明：\n          ```css\n          @view-transition {\n            navigation: auto;\n            types: slide-nav card-expand; /* 声明默认类型 */\n          }\n          ```\n      - **匹配类型：** 使用新的 CSS 伪类：\n        - `:active-view-transition`: 匹配有**任何**转场活动时的 `\u003chtml>`。\n        - `:active-view-transition-type(type1, type2...)`: 匹配活动转场的 `types` **包含**括号里**至少一个**类型时的 `\u003chtml>`。\n    - **示例：**\n\n      ```css\n      /* 默认淡入淡出 */\n      ::view-transition-old(root) {\n        animation: fade-out 0.3s;\n      }\n      ::view-transition-new(root) {\n        animation: fade-in 0.3s;\n      }\n\n      /* 如果是导航滑动类型 */\n      :root:active-view-transition-type(slide-nav) ::view-transition-old(root) {\n        animation-name: slide-left-out;\n      }\n      :root:active-view-transition-type(slide-nav) ::view-transition-new(root) {\n        animation-name: slide-right-in;\n      }\n      ```\n\n    - **好处：** 可以用清晰的 CSS 规则，为不同类型的转场定义不同的动画，逻辑分离。\n\n2.  **样式复用 (`view-transition-class`):**\n\n    - **痛点：** 很多元素 `view-transition-name` 不同，但想用同一套动画，写一堆 `::view-transition-group(name1)`, `::view-transition-group(name2)`... 太累。\n    - **Level 2 方案：** `view-transition-class` CSS 属性 + 类选择器语法。\n\n      ```css\n      /* 给所有卡片加上 class */\n      .card {\n        view-transition-class: my-card;\n        /* name 还是需要的，比如用 auto */\n        view-transition-name: auto;\n      }\n\n      /* 用类选择器选中所有这些卡片的 group */\n      ::view-transition-group(*.my-card) {\n        /* 注意这个 *.classname 语法 */\n        animation-timing-function: ease-in-out;\n      }\n      ```\n\n    - **好处：** DRY！极大简化了对共享动画行为的元素的样式定义。\n\n3.  **自动 `view-transition-name`:**\n\n    - **痛点：** 手动给列表项等大量元素起名字太烦。\n    - **Level 2 方案：** `view-transition-name: auto;`\n      - 有 `id` 就用 `id`。\n      - 没 `id` 浏览器内部生成唯一标识。\n    - **跨文档注意！！！** `auto` 生成的、非 `id` 的名字，在**新旧文档间不会匹配**！这意味着它们总是触发进入/退出动画，而不是平滑过渡。想让元素在新旧页面平滑连接，还是要确保它们有**相同且稳定**的 `view-transition-name`（用 `id` 或手动指定相同 name）。\n\n4.  **嵌套视图转场 (`view-transition-group` CSS 属性):**\n\n    - **痛点：** Level 1 的扁平伪元素树无法处理父元素的 `clip-path`, `overflow: hidden`, `filter`, `opacity` 或复杂的 3D 变换，导致动画效果失真。\n    - **Level 2 方案：** `view-transition-group` CSS 属性，允许你指定一个父级 `view-transition-name` (或 `nearest`, `contain`)，从而构建嵌套的伪元素树。\n\n      ```css\n      .container {\n        view-transition-name: container;\n        clip-path: circle(50%);\n      }\n      .content-inside {\n        view-transition-name: content;\n        /* 让 content 的 group 成为 container group 的子元素 */\n        view-transition-group: container;\n      }\n\n      /* 现在可以给 container group 加 clip-path 动画 */\n      ::view-transition-group(container) {\n        animation: clip-reveal 0.5s;\n      }\n      ```\n\n    - **好处：** 动画能更好地反映 DOM 的层级和效果（如剪裁、滤镜），实现更复杂的视觉效果。\n\n5.  **分层捕获 (Layered Capture - 底层改进):**\n    - **痛点：** Level 1 的快照是扁平图片，`border`, `background-gradient`, `box-shadow`, `filter` 等效果无法独立动画，只能跟着图片一起变形或淡变，很生硬。\n    - **Level 2 方案：** 浏览器不再只拍一张扁平快照，而是捕获元素的多个 CSS 属性层（如背景、边框、阴影、滤镜、透明度、内边距等），并在动画时对这些**属性本身**进行插值。\n    - **好处：** 动画效果大大丰富！边框可以平滑变色变形，渐变背景可以流畅过渡，阴影和滤镜也能动起来，视觉表现力提升一个档次！这使得转场感觉更“原生”，而不是简单的图片切换。\n\n## 五、注意事项与未来展望\n\n- **安全：** 依然严格限制同源，并处理了跨域重定向问题。\n- **兼容性：** **划重点！Level 2 目前 (2025-4-7) 仍是 W3C 工作草案 (Working Draft)**，API 和行为可能变化，浏览器支持尚不完善或处于实验阶段。生产环境使用务必谨慎，关注 Can I use 和浏览器厂商动态。\n- **性能：** 复杂的嵌套、大量的独立元素、消耗大的动画依然需要关注性能测试和优化。\n- **调试：** 现代浏览器开发者工具正在逐步增强对 View Transitions（包括 Level 2 特性）的调试支持。\n\n## 六、总结：MPA 的春天，体验的飞跃\n\nCSS View Transitions Module Level 2 是对 Level 1 的一次意义重大的扩展和增强。它不仅将丝滑的转场体验带给了更广泛的 MPA 网站，还通过 `types`、`view-transition-class`、`auto` name、`view-transition-group` 属性以及底层的分层捕获，极大地提升了转场的灵活性、开发效率和视觉表现力。\n\n虽然还是草案，但它描绘的未来无疑是激动人心的。掌握了 View Transitions Level 1 和 Level 2，你就拥有了打造下一代 Web 流畅体验的利器。\n\n希望这篇结合了 Level 1 回顾与 Level 2 深入的探索，能让你对 View Transitions 有一个更全面、更深入的认识。赶紧动手尝试（在支持的实验性浏览器中），感受这触手可及的未来吧！\n\n**参考资料：**\n\n- [W3C CSS View Transitions Module Level 1 Spec](https://www.w3.org/TR/css-view-transitions-1/)\n- [MDN 文档: View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API)\n- [Cross-document view transitions for multi-page applications](https://developer.chrome.com/docs/web-platform/view-transitions/cross-document)\n- [`caniuse View Transitions (cross-document)`](https://caniuse.com/view-transitions)\n  - chrome 126+\n  - safari 18.2+\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.XrIATmm0.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.IQG_6ZON.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-vy2czm8u.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-0HRAW6Xj.js" as="script" type="text/javascript">
      </body>
    </html>