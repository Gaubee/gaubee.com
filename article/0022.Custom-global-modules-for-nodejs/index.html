<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.B0ujMgz2.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }
        </style><h1>nodejs的自定义全局模块</h1><main><p>需求如下：
写了一个类：<code>function A(){/*...*/}</code>，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。
这里推荐三种方法：
<del>1. 重写require函数，加一层请求拦截的包裹。</del>
2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。
3. 将对象注册到底层模块列表中。
无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。
而第一种和第三种都要涉及到一个对象：<code>process.binding("natives")</code>；这里返回的将是原生模块的代码。
第三种无疑效率最高，实现方法如下：</p>
<pre><code class="language-js">var natives_modules = process.binding("natives");
function defineAs(module_name, obj){
    if (natives_modules.hasOwnProperty(module_name)) {
        throw Error("Module Name has be defined");
    }
    var __module_uuid = +new Date + Math.random().toString(32);
    global[__module_uuid] = obj;
    var scriptContent = 'module.exports = global["'+__module_uuid+'"]';
    natives_modules[module_name] = scriptContent;
};
//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。
</code></pre>
<hr>
<p>不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。</p></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0022.Custom-global-modules-for-nodejs"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0022.Custom-global-modules-for-nodejs.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"nodejs的自定义全局模块","date":"!Date:2015-02-23T16:31:49.000Z","updated":"!Date:2018-10-11T10:29:00.000Z","tags":["javascript","cogitation"]},"metadata":{"layout":"layouts/article.njk","title":"nodejs的自定义全局模块","date":"!Date:2015-02-23T16:31:49.000Z","updated":"!Date:2018-10-11T10:29:00.000Z","tags":["javascript","cogitation"],"id":"0022.Custom-global-modules-for-nodejs","createdAt":"!Date:2015-02-23T16:31:49.000Z","updatedAt":"!Date:2018-10-11T10:29:00.000Z"},"htmlContent":"\u003cp>需求如下：\n写了一个类：\u003ccode>function A(){/*...*/}\u003c/code>，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。\n这里推荐三种方法：\n\u003cdel>1. 重写require函数，加一层请求拦截的包裹。\u003c/del>\n2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。\n3. 将对象注册到底层模块列表中。\n无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。\n而第一种和第三种都要涉及到一个对象：\u003ccode>process.binding(\"natives\")\u003c/code>；这里返回的将是原生模块的代码。\n第三种无疑效率最高，实现方法如下：\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">var natives_modules = process.binding(\"natives\");\nfunction defineAs(module_name, obj){\n    if (natives_modules.hasOwnProperty(module_name)) {\n        throw Error(\"Module Name has be defined\");\n    }\n    var __module_uuid = +new Date + Math.random().toString(32);\n    global[__module_uuid] = obj;\n    var scriptContent = 'module.exports = global[\"'+__module_uuid+'\"]';\n    natives_modules[module_name] = scriptContent;\n};\n//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。\n\u003c/code>\u003c/pre>\n\u003chr>\n\u003cp>不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。\u003c/p>","markdownContent":"\n需求如下：\n写了一个类：`function A(){/*...*/}`，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。\n这里推荐三种方法：\n~~1. 重写require函数，加一层请求拦截的包裹。~~\n2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。\n3. 将对象注册到底层模块列表中。\n无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。\n而第一种和第三种都要涉及到一个对象：`process.binding(\"natives\")`；这里返回的将是原生模块的代码。\n第三种无疑效率最高，实现方法如下：\n\n``` js\nvar natives_modules = process.binding(\"natives\");\nfunction defineAs(module_name, obj){\n    if (natives_modules.hasOwnProperty(module_name)) {\n        throw Error(\"Module Name has be defined\");\n    }\n    var __module_uuid = +new Date + Math.random().toString(32);\n    global[__module_uuid] = obj;\n    var scriptContent = 'module.exports = global[\"'+__module_uuid+'\"]';\n    natives_modules[module_name] = scriptContent;\n};\n//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。\n```\n\n---\n\n不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.D4VBVy3c.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.h5JipGsp.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-vy2czm8u.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-0HRAW6Xj.js" as="script" type="text/javascript">
      </body>
    </html>