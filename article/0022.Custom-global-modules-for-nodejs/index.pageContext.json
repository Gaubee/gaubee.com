{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0022.Custom-global-modules-for-nodejs"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0022.Custom-global-modules-for-nodejs.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"nodejs的自定义全局模块","date":"!Date:2015-02-23T16:31:49.000Z","updated":"!Date:2018-10-11T10:29:00.000Z","tags":["javascript","cogitation"]},"metadata":{"layout":"layouts/article.njk","title":"nodejs的自定义全局模块","date":"!Date:2015-02-23T16:31:49.000Z","updated":"!Date:2018-10-11T10:29:00.000Z","tags":["javascript","cogitation"],"id":"0022.Custom-global-modules-for-nodejs","createdAt":"!Date:2015-02-23T16:31:49.000Z","updatedAt":"!Date:2018-10-11T10:29:00.000Z"},"htmlContent":"<p>需求如下：\n写了一个类：<code>function A(){/*...*/}</code>，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。\n这里推荐三种方法：\n<del>1. 重写require函数，加一层请求拦截的包裹。</del>\n2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。\n3. 将对象注册到底层模块列表中。\n无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。\n而第一种和第三种都要涉及到一个对象：<code>process.binding(\"natives\")</code>；这里返回的将是原生模块的代码。\n第三种无疑效率最高，实现方法如下：</p>\n<pre><code class=\"language-js\">var natives_modules = process.binding(\"natives\");\nfunction defineAs(module_name, obj){\n    if (natives_modules.hasOwnProperty(module_name)) {\n        throw Error(\"Module Name has be defined\");\n    }\n    var __module_uuid = +new Date + Math.random().toString(32);\n    global[__module_uuid] = obj;\n    var scriptContent = 'module.exports = global[\"'+__module_uuid+'\"]';\n    natives_modules[module_name] = scriptContent;\n};\n//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。\n</code></pre>\n<hr>\n<p>不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。</p>","markdownContent":"\n需求如下：\n写了一个类：`function A(){/*...*/}`，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。\n这里推荐三种方法：\n~~1. 重写require函数，加一层请求拦截的包裹。~~\n2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。\n3. 将对象注册到底层模块列表中。\n无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。\n而第一种和第三种都要涉及到一个对象：`process.binding(\"natives\")`；这里返回的将是原生模块的代码。\n第三种无疑效率最高，实现方法如下：\n\n``` js\nvar natives_modules = process.binding(\"natives\");\nfunction defineAs(module_name, obj){\n    if (natives_modules.hasOwnProperty(module_name)) {\n        throw Error(\"Module Name has be defined\");\n    }\n    var __module_uuid = +new Date + Math.random().toString(32);\n    global[__module_uuid] = obj;\n    var scriptContent = 'module.exports = global[\"'+__module_uuid+'\"]';\n    natives_modules[module_name] = scriptContent;\n};\n//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。\n```\n\n---\n\n不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。\n"}}}