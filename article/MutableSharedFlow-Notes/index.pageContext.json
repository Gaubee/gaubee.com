{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"MutableSharedFlow-Notes"},"data":{"article":{"metadata":{"layout":"layouts/article.njk","title":"MutableSharedFlow 随记","date":"!Date:2024-04-05T11:08:28.829Z","updated":"!Date:2024-04-05T11:08:28.829Z","tags":["Kotlin"],"id":"MutableSharedFlow-Notes","createdAt":"!Date:2024-04-05T11:08:28.829Z","updatedAt":"!Date:2024-04-05T11:08:28.829Z"},"htmlContent":"<p>MutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。\n因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。\n举个例子：</p>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-kotlin\"><span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">val</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> sharedFlow </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> MutableSharedFlow</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">&#x3C;</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">Int</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">>();</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">launch</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    sharedFlow.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">collect</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">        println</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(it) </span><span style=\"color:#6A737D;--shiki-dark:#6A737D\">// 这里通常不会有任何打印</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">sharedFlow.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">emit</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">1</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span></code></pre>\n<p>因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。\n这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。</p>\n<hr>\n<p>因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。</p>\n<hr>\n<p>最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。\n但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。\n这个方案唯一的好处就是代码量相对比较少。</p>\n<hr>\n<p>还有一种方案是使用 Channel：</p>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-kotlin\"><span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">val</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> channel </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> Channel</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">&#x3C;</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">Int</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">>();</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">val</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> sharedFlow </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> channel.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">consumeAsFlow</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">().</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">shareIn</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">currentCoroutineContext</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(), SharingStarted.Lazily)</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">launch</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    sharedFlow.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">collect</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">        println</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(it) </span><span style=\"color:#6A737D;--shiki-dark:#6A737D\">// 这里通常不会有任何打印</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">channel.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">send</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">1</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span></code></pre>\n<p>这个方案其实是创建了一个 Channel，两个 Flow。\n其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。\n第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。</p>\n<p>这个方案只能说勉勉强强达到我们的需求，但问题也很多：</p>\n<ol>\n<li>它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。</li>\n<li>flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 <code>launch sharedFlow.collect</code> ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。\n<blockquote>\n<p>这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:</p>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-kotlin\"><span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">val</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> channel </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> Channel</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">&#x3C;</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">Int</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">>()</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">val</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> MAX </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\"> 5</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">launch</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D;--shiki-dark:#6A737D\">  /// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">  delay</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">1000</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">  println</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"start send\"</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">  for</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> (i </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">in</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\"> 1</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">..</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">MAX) {</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    channel.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">send</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(i)</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">    println</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"send(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">$i</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">)\"</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">val</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> flow </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> channel.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">receiveAsFlow</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">().</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">shareIn</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">this</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">, SharingStarted.Lazily)</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">launch</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">  flow.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">collect</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">    println</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"collect1(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">$it</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">)\"</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">    delay</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">1000</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">launch</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">  delay</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">2000</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">  flow.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">collect</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">    println</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"collect2(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">$it</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">)\"</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">}</span></span></code></pre>\n</blockquote>\n</li>\n<li>这里用 consumeAsFlow 还是 receiveAsFlow 都一样</li>\n</ol>\n<hr>\n<p>但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手：\n试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。\n其实标准做法是这样的：</p>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-kotlin\"><span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">val</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> sharedFlow </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> MutableSharedFlow</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">&#x3C;</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">Int</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">>().</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">onSubscription</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    sharedFlow.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">emit</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">1</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">launch</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    sharedFlow.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">collect</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">        println</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(it) </span><span style=\"color:#6A737D;--shiki-dark:#6A737D\">// 这里通常不会有任何打印</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">}</span></span></code></pre>\n<p>但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。</p>\n<hr>\n","markdownContent":"\nMutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。\n因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。\n举个例子：\n\n```kotlin\nval sharedFlow = MutableSharedFlow<Int>();\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nsharedFlow.emit(1)\n```\n\n因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。\n这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。\n\n---\n\n因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。\n\n---\n\n最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。\n但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。\n这个方案唯一的好处就是代码量相对比较少。\n\n---\n\n还有一种方案是使用 Channel：\n\n```kotlin\nval channel = Channel<Int>();\nval sharedFlow = channel.consumeAsFlow().shareIn(currentCoroutineContext(), SharingStarted.Lazily)\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nchannel.send(1)\n```\n\n这个方案其实是创建了一个 Channel，两个 Flow。\n其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。\n第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。\n\n这个方案只能说勉勉强强达到我们的需求，但问题也很多：\n\n1. 它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。\n1. flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 `launch sharedFlow.collect` ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。\n   > 这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:\n   >\n   > ```kotlin\n   > val channel = Channel<Int>()\n   > val MAX = 5;\n   > launch {\n   >   /// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费\n   >   delay(1000)\n   >   println(\"start send\")\n   >   for (i in 1..MAX) {\n   >     channel.send(i)\n   >     println(\"send($i)\")\n   >   }\n   > }\n   > val flow = channel.receiveAsFlow().shareIn(this, SharingStarted.Lazily)\n   > launch {\n   >   flow.collect {\n   >     println(\"collect1($it)\")\n   >     delay(1000)\n   >   }\n   > }\n   > launch {\n   >   delay(2000)\n   >   flow.collect {\n   >     println(\"collect2($it)\")\n   >   }\n   > }\n   > ```\n1. 这里用 consumeAsFlow 还是 receiveAsFlow 都一样\n\n---\n\n但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手：\n试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。\n其实标准做法是这样的：\n\n```kotlin\nval sharedFlow = MutableSharedFlow<Int>().onSubscription {\n    sharedFlow.emit(1)\n}\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\n```\n\n但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。\n\n---\n"}}}