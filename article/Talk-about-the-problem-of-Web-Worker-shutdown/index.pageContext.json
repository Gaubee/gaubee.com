{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"Talk-about-the-problem-of-Web-Worker-shutdown"},"data":{"article":{"metadata":{"layout":"layouts/article.njk","title":"浅谈Web Worker关闭的问题","date":"!Date:2020-05-24T08:44:26.000Z","updated":"!Date:2020-05-24T08:46:02.000Z","id":"Talk-about-the-problem-of-Web-Worker-shutdown","createdAt":"!Date:2020-05-24T08:44:26.000Z","updatedAt":"!Date:2020-05-24T08:46:02.000Z","tags":[]},"htmlContent":"<p>Web Worker是没有提供onclose事件的，但它有提供terminate函数。\n可能官方很自信地觉得Worker只要是用户销毁的，那么就没必要onclose……但其实昨天就遇到这个问题了（在Cordova-Ionic-Webview里头），就是从后台唤起程序，WebWorker没响应了，被杀了……在调试控制台已经看不到这个Worker的身影。\n解决办法我想有三个：</p>\n<ol>\n<li>原生层面入手，去监控有什么系统层面的回调会触发</li>\n<li>改成用ServiceWorker试一下</li>\n<li>监控WebWorker的销毁</li>\n</ol>\n<p>为了简单且通用起见，我先选择了3。\n但其实在官方接口里头是没有相关的接口的，这就只能另辟蹊径。\n一开始我想到的是研究MessageChannel。因为从接口层面来说，它们几乎是一出的，也许底层实现是一样的。\n所以就去研究如何识别MessageChannel是close状态的。最糟糕的方式估计就是pingpong，但这就得额外增加脏代码。\n后来忽然想到transferable这个标准，所以就有了以下的骚操作：</p>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-ts\"><span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">const</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\"> b</span><span style=\"color:#D73A49;--shiki-dark:#F97583\"> =</span><span style=\"color:#D73A49;--shiki-dark:#F97583\"> new</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> ArrayBuffer</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">1</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">port1.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">postMessage</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">0</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">,[b]);</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">console.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">log</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(b.byteLength);</span></span></code></pre>\n<p>如果MessagePort是开启的状态，内存对象会被顺利传输，从而打印“0”。否则如果打印“1”，就说明MessagePort已经被关闭。\n用这个方法去实验WebWorker。理论上几乎是一个东西吧……事实却是即便WebWorker执行了terminate，ArrayBuffer仍旧会被传输过去……这就很恐怖了，错觉自己是不是遇上了浏览器内存泄漏的问题……一搜索其实github上三四年前就已经有人提出了，到现在仍旧没有音讯。实在不理解terminate居然没有销毁消息管道……那我发送到子进程的ArrayBuffer到底发到哪里了呢?</p>\n<p>既然这条路不通，我就再换一个操作。我想terminate至少会销毁WebWorker中所有的Promise吧。故而我想起了有这个一个API：LockManager 。</p>\n<blockquote>\n<p>PS: 我后来测试在使用<code>new Worker('data:text/javascript;,')</code>这样的<code>data:</code>协议下的Worker环境，是不支持的。建议还是用https协议。\n它的用法很简单，虽然还是需要在子进程中注入代码，但至少也比pingpong的方案好，毕竟Worker就是要用来执行密集型任务，哪里还能保障一定能返回pingpong呢。所以只要在子进程启动后，执行一个永远不释放的request，然后发一个信号告知主进程开始监听这个request：</p>\n</blockquote>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-ts\"><span class=\"line\"><span style=\"color:#6A737D;--shiki-dark:#6A737D\">/// worker</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">const</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\"> lockReqId</span><span style=\"color:#D73A49;--shiki-dark:#F97583\"> =</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\"> 'process-live-'</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">+</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">Date.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">now</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">()</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">+</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">Math.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">random</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">navigator.locks.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">request</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> (lockReqId,()</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=>new</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\"> Promise</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(()</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=></span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">{}));</span></span>\n<span class=\"line\"><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">postMessage</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(lockReqId);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D;--shiki-dark:#6A737D\">/// master</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">worker.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">addEventListener</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">'message'</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">, </span><span style=\"color:#E36209;--shiki-dark:#FFAB70\">me</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=></span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">  if</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">typeof</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> me.data</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">===</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">'string'</span><span style=\"color:#D73A49;--shiki-dark:#F97583\"> &#x26;&#x26;</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> me.data.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">startsWith</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"process-live-\"</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)){</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    navigator.locks.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">request</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(me.data,()</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=></span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">      worker.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">dispatchEvent</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">new</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> CloseEvent</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">'close'</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">});</span></span></code></pre>\n<p>这个方案几乎是完美的。因为是直接跟js引擎的销毁与否进行绑定。不过它只有chrome69+才支持。</p>\n<hr>\n<p>不过pingpong只能识别出Worker不响应，它可能繁忙。如果没有预期中的响应，应该将是否重启WebWorker</p>\n","markdownContent":"\nWeb Worker是没有提供onclose事件的，但它有提供terminate函数。\n可能官方很自信地觉得Worker只要是用户销毁的，那么就没必要onclose……但其实昨天就遇到这个问题了（在Cordova-Ionic-Webview里头），就是从后台唤起程序，WebWorker没响应了，被杀了……在调试控制台已经看不到这个Worker的身影。\n解决办法我想有三个：\n1. 原生层面入手，去监控有什么系统层面的回调会触发\n2. 改成用ServiceWorker试一下\n3. 监控WebWorker的销毁\n\n为了简单且通用起见，我先选择了3。\n但其实在官方接口里头是没有相关的接口的，这就只能另辟蹊径。\n一开始我想到的是研究MessageChannel。因为从接口层面来说，它们几乎是一出的，也许底层实现是一样的。\n所以就去研究如何识别MessageChannel是close状态的。最糟糕的方式估计就是pingpong，但这就得额外增加脏代码。\n后来忽然想到transferable这个标准，所以就有了以下的骚操作：\n```ts\nconst b = new ArrayBuffer(1);\nport1.postMessage(0,[b]);\nconsole.log(b.byteLength);\n```\n如果MessagePort是开启的状态，内存对象会被顺利传输，从而打印“0”。否则如果打印“1”，就说明MessagePort已经被关闭。\n用这个方法去实验WebWorker。理论上几乎是一个东西吧……事实却是即便WebWorker执行了terminate，ArrayBuffer仍旧会被传输过去……这就很恐怖了，错觉自己是不是遇上了浏览器内存泄漏的问题……一搜索其实github上三四年前就已经有人提出了，到现在仍旧没有音讯。实在不理解terminate居然没有销毁消息管道……那我发送到子进程的ArrayBuffer到底发到哪里了呢?\n\n既然这条路不通，我就再换一个操作。我想terminate至少会销毁WebWorker中所有的Promise吧。故而我想起了有这个一个API：LockManager 。\n> PS: 我后来测试在使用`new Worker('data:text/javascript;,')`这样的`data:`协议下的Worker环境，是不支持的。建议还是用https协议。\n它的用法很简单，虽然还是需要在子进程中注入代码，但至少也比pingpong的方案好，毕竟Worker就是要用来执行密集型任务，哪里还能保障一定能返回pingpong呢。所以只要在子进程启动后，执行一个永远不释放的request，然后发一个信号告知主进程开始监听这个request：\n```ts\n/// worker\nconst lockReqId = 'process-live-'+Date.now()+Math.random();\nnavigator.locks.request (lockReqId,()=>new Promise(()=>{}));\npostMessage(lockReqId);\n\n/// master\nworker.addEventListener('message', me=>{\n  if(typeof me.data==='string' && me.data.startsWith(\"process-live-\")){\n    navigator.locks.request(me.data,()=>{\n      worker.dispatchEvent(new CloseEvent('close'))\n    })\n  }\n});\n```\n这个方案几乎是完美的。因为是直接跟js引擎的销毁与否进行绑定。不过它只有chrome69+才支持。\n\n----\n\n不过pingpong只能识别出Worker不响应，它可能繁忙。如果没有预期中的响应，应该将是否重启WebWorker"}}}