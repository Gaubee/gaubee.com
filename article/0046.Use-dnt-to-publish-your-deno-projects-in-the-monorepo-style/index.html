<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.-4-S6IZd.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }

          main > p > img {
            max-width: 100%;
            margin: 0 auto;
            display: block;
          }
        </style><h1>使用 dnt 将你的 deno 项目发布成 monorepo 风格</h1><main><h2>使用 dnt 将你的 deno 项目发布成 monorepo 风格</h2>
<blockquote>
<p>在提供理论指导之前，我们先看具体的实践如何做到，完成后，我再说明这种项目管理方案的优势在哪里。</p>
</blockquote>
<h3>工具</h3>
<ol>
<li><a href="https://deno.com/">deno</a></li>
<li><a href="https://pnpm.io/installation">pnpm</a></li>
</ol>
<h3>准备工作</h3>
<ol>
<li>
<p>创建你的项目：</p>
<pre><code class="language-shell">deno init dnt-mono
# cd dnt-mono
# code . # open in ide
</code></pre>
</li>
<li>
<p>初始化 git 仓库</p>
<pre><code class="language-shell">git init
echo "npm\nnode_modules" > .gitignore # ignore the npm folder
</code></pre>
</li>
<li>
<p>初始化 package.json，以及一些 npm/pnpm 通常所需的文件</p>
<pre><code class="language-shell">npm init --yes --private # create a package.json file
echo "MIT" > LICENSE
echo "# Hello Dnt ❤️ Monorepo" > README.md
echo "packages:\n  - \"npm/*\"" > pnpm-workspace.yaml
</code></pre>
</li>
<li>
<p>准备 dnt 脚本</p>
<pre><code class="language-shell">deno add @deno/dnt
</code></pre>
<p>参考 <a href="https://github.com/denoland/dnt?tab=readme-ov-file#setup">Setup</a>，因为我们需要构建多个 npm 包，所以创建 <code>scripts/npmBuilder.ts</code> 文件：</p>
<pre><code class="language-ts">import { build, BuildOptions, emptyDir } from "@deno/dnt";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const rootDir = import.meta.resolve("../");
const rootResolve = (path: string) => fileURLToPath(new URL(path, rootDir));
export const npmBuilder = async (config: {
  packageDir: string;
  version?: string;
  importMap?: string;
  options?: Partial&#x3C;BuildOptions>;
}) => {
  const { packageDir, version, importMap, options } = config;
  const packageResolve = (path: string) =>
    fileURLToPath(new URL(path, packageDir));
  const packageJson = JSON.parse(
    fs.readFileSync(packageResolve("./package.json"), "utf-8")
  );
  // remove some field which dnt will create. if you known how dnt work, you can keep them.
  delete packageJson.main;
  delete packageJson.module;
  delete packageJson.exports;

  console.log(`\nstart dnt: ${packageJson.name}`);

  const npmDir = rootResolve(`./npm/${packageJson.name.split("/").pop()}`);
  const npmResolve = (p: string) => path.resolve(npmDir, p);

  await emptyDir(npmDir);

  if (version) {
    Object.assign(packageJson, { version: version });
  }

  await build({
    entryPoints: [{ name: ".", path: packageResolve("./index.ts") }],
    outDir: npmDir,
    packageManager: "pnpm",
    shims: {
      deno: true,
    },
    // you should open it in actual
    test: false,
    importMap: importMap,
    package: packageJson,
    // custom by yourself
    compilerOptions: {
      lib: ["DOM", "ES2022"],
      target: "ES2022",
      emitDecoratorMetadata: true,
    },
    postBuild() {
      // steps to run after building and before running the tests
      Deno.copyFileSync(rootResolve("./LICENSE"), npmResolve("./LICENSE"));
      Deno.copyFileSync(
        packageResolve("./README.md"),
        npmResolve("./README.md")
      );
    },
    ...options,
  });
};
</code></pre>
</li>
</ol>
<h3>主要步骤</h3>
<ol>
<li>
<p>创建两个子文件夹，加入一些项目文件</p>
<pre><code class="language-shell"># start from root
mkdir packages/module-a
cd packages/module-a
echo "export const a = 1;" > index.ts
echo "# @dnt-mono/module-a" > README.md
npm init --scope @dnt-mono --yes # name : @dnt-mono/module-a
</code></pre>
<p>同样的步骤，创建 <code>module-b</code> 文件夹</p>
<pre><code class="language-shell"># start from root
mkdir packages/module-b
cd packages/module-b
echo "import { a } from \"@dnt-mono/module-a\";\nexport const b = a + 1;" > index.ts
echo "# @dnt-mono/module-b" > README.md
npm init --scope @dnt-mono --yes # name : @dnt-mono/module-b

pnpm add @dnt-mono/module-a --workspace # add module-a as dependencie
</code></pre>
</li>
<li>
<p>在这个事例中， <code>module-b</code> 依赖了 <code>module-a</code>，同时我们在代码中使用了 <code>@dnt-mono/module-a</code> 这个 specifier，所以我们为了让 deno 的语言服务器正确工作，还需要做一些配置。在 <code>deno.json</code> 的 <code>imports</code> 字段中加入这些配置：</p>
<pre><code class="language-jsonc"> "@dnt-mono/module-a": "./packages/module-a/index.ts", // in imports
 "@dnt-mono/module-b": "./packages/module-b/index.ts" // in imports
</code></pre>
</li>
<li>
<p>接着，我们创建构建脚本和配置文件</p>
<ol>
<li>
<p><code>scripts/build_npm.ts</code></p>
<pre><code class="language-ts">import { npmBuilder } from "./npmBuilder.ts";

const version = Deno.args[0];
await npmBuilder({
  packageDir: import.meta.resolve("../packages/module-a/"),
  importMap: import.meta.resolve("./import_map.npm.json"),
  version,
});
await npmBuilder({
  packageDir: import.meta.resolve("../packages/module-b/"),
  importMap: import.meta.resolve("./import_map.npm.json"),
  version,
});
</code></pre>
</li>
<li>
<p><code>scripts/import_map.npm.json</code></p>
<pre><code class="language-json">{
  "imports": {
    "@dnt-mono/module-a": "npm:@dnt-mono/module-a",
    "@dnt-mono/module-b": "npm:@dnt-mono/module-b"
  }
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>然后，在你的 <code>deno.json</code> 中配置 build 指令：</p>
<pre><code class="language-jsonc">"build": "deno run -A ./scripts/build_npm.ts" // in tasks
</code></pre>
</li>
<li>
<p>最后，尝试执行 build 指令，构建出 npm 目录</p>
<pre><code class="language-shell">deno task build
</code></pre>
<p>这时候，你可以看到 npm 目录下输出了 module-a 和 module-b 两个 npm 包文件夹。
现在你可以尝试发布这些 npm 包了：</p>
<pre><code class="language-shell">pnpm publish -r --no-git-checks --dry-run # you should remove --dry-run actual
</code></pre>
</li>
</ol>
<h3>工作原理</h3>
<ol>
<li>我们使用 deno 作为语言服务器，它很强大，很多体验经过定制化开发，已经超越 tsc 本身。</li>
<li>所以 package.json 在这里只是一个“模板文件”，而不是配置文件。在开发中，真正生效的配置文件只有 deno.json</li>
<li>因此，pnpm 在这里是一个面向 dnt 最终编译产出的工具，也就是只服务于 <code>npm/*</code> 的目录。这也是为什么 <code>pnpm-workspaces.yaml</code> 的配置是这样的</li>
<li>dnt 中使用的 <code>import_map.npm.json</code> 很重要，我们不能直接使用 <code>deno.json</code> 作为 <code>importMap</code>，因为<code>deno.json</code>配置给 deno 语言服务器，而 <code>import_map.npm.json</code> 是配置给 dnt/pnpm 使用的。在复杂的项目中，建议你用脚本自动生成并管理它。</li>
</ol>
<h3>进阶技巧</h3>
<p>在 deno 的开发中，我们的理念是面向文件而不是面向模块，因此如果有需要，你需要增加这样的配置在<code>deno.json</code>中：</p>
<pre><code class="language-jsonc">{
  // ...
  "imports": {
    // ...
    "@dnt-mono/module-a": "./packages/module-a/index.ts",
    "@dnt-mono/module-a/": "./packages/module-a/src/",
    "@dnt-mono/module-b": "./packages/module-b/index.ts",
    "@dnt-mono/module-b/": "./packages/module-b/src/"
    // ...
  }
}
</code></pre>
<p>我习惯将除了 <code>index.ts</code> 意外的文件放到 <code>src</code> 目录下，这会更加符合 node 项目的风格。</p>
<blockquote>
<p>但切记，不要把 index.ts 文件也挪到 <code>src</code> 目录下，否则会引发异常 <a href="https://github.com/denoland/dnt/issues/249">#249</a></p>
</blockquote>
<p>然后，就是 dnt 的配置，你需要遍历你所有的文件，并将它配置到 entryPoints 中：</p>
<pre><code class="language-ts">build({
  entryPoints: [
    // default entry
    { name: ".", path: packageResolve("./index.ts") },
    // src files
    ALL_SRC_TS_FILES.map((name) => ({
      name: `./${name}`,
      path: `./src/${name}`,
    })),
  ],
  // ...
});
</code></pre>
<p>现在，你就可以写这样的代码了：</p>
<pre><code class="language-ts">import { xxx } from "@dnt-mono/module-a/xxx.ts";
</code></pre>
<h3>注意事项</h3>
<ol>
<li>规划好你的项目结构，避免形成循环依赖。如果有需要，你需要自己配置 peerDependencies</li>
<li>不要在某个模块中做自引入。
<blockquote>
<p>语言服务器并不理解你最终要发布 npm 的意图，所以即便 deno 能正确工作，但你的目的是让 node 也能工作。</p>
</blockquote>
<pre><code class="language-ts">import { a } from "@dnt-mono/module-a"; // don't import module-a in module-a
</code></pre>
在正式的项目中，建议编写 lint 规则来避免这种错误的发生</li>
</ol>
<h3>优势</h3></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0046.Use-dnt-to-publish-your-deno-projects-in-the-monorepo-style"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0046.Use-dnt-to-publish-your-deno-projects-in-the-monorepo-style.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"使用 dnt 将你的 deno 项目发布成 monorepo 风格","date":"!Date:2024-04-27T04:40:46.724Z","updated":"!Date:2024-04-27T04:40:46.724Z"},"metadata":{"layout":"layouts/article.njk","title":"使用 dnt 将你的 deno 项目发布成 monorepo 风格","date":"!Date:2024-04-27T04:40:46.724Z","updated":"!Date:2024-04-27T04:40:46.724Z","id":"0046.Use-dnt-to-publish-your-deno-projects-in-the-monorepo-style","createdAt":"!Date:2024-04-27T04:40:46.724Z","updatedAt":"!Date:2024-04-27T04:40:46.724Z","tags":[]},"htmlContent":"\u003ch2>使用 dnt 将你的 deno 项目发布成 monorepo 风格\u003c/h2>\n\u003cblockquote>\n\u003cp>在提供理论指导之前，我们先看具体的实践如何做到，完成后，我再说明这种项目管理方案的优势在哪里。\u003c/p>\n\u003c/blockquote>\n\u003ch3>工具\u003c/h3>\n\u003col>\n\u003cli>\u003ca href=\"https://deno.com/\">deno\u003c/a>\u003c/li>\n\u003cli>\u003ca href=\"https://pnpm.io/installation\">pnpm\u003c/a>\u003c/li>\n\u003c/ol>\n\u003ch3>准备工作\u003c/h3>\n\u003col>\n\u003cli>\n\u003cp>创建你的项目：\u003c/p>\n\u003cpre>\u003ccode class=\"language-shell\">deno init dnt-mono\n# cd dnt-mono\n# code . # open in ide\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>初始化 git 仓库\u003c/p>\n\u003cpre>\u003ccode class=\"language-shell\">git init\necho \"npm\\nnode_modules\" > .gitignore # ignore the npm folder\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>初始化 package.json，以及一些 npm/pnpm 通常所需的文件\u003c/p>\n\u003cpre>\u003ccode class=\"language-shell\">npm init --yes --private # create a package.json file\necho \"MIT\" > LICENSE\necho \"# Hello Dnt ❤️ Monorepo\" > README.md\necho \"packages:\\n  - \\\"npm/*\\\"\" > pnpm-workspace.yaml\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>准备 dnt 脚本\u003c/p>\n\u003cpre>\u003ccode class=\"language-shell\">deno add @deno/dnt\n\u003c/code>\u003c/pre>\n\u003cp>参考 \u003ca href=\"https://github.com/denoland/dnt?tab=readme-ov-file#setup\">Setup\u003c/a>，因为我们需要构建多个 npm 包，所以创建 \u003ccode>scripts/npmBuilder.ts\u003c/code> 文件：\u003c/p>\n\u003cpre>\u003ccode class=\"language-ts\">import { build, BuildOptions, emptyDir } from \"@deno/dnt\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\n\nconst rootDir = import.meta.resolve(\"../\");\nconst rootResolve = (path: string) => fileURLToPath(new URL(path, rootDir));\nexport const npmBuilder = async (config: {\n  packageDir: string;\n  version?: string;\n  importMap?: string;\n  options?: Partial&#x3C;BuildOptions>;\n}) => {\n  const { packageDir, version, importMap, options } = config;\n  const packageResolve = (path: string) =>\n    fileURLToPath(new URL(path, packageDir));\n  const packageJson = JSON.parse(\n    fs.readFileSync(packageResolve(\"./package.json\"), \"utf-8\")\n  );\n  // remove some field which dnt will create. if you known how dnt work, you can keep them.\n  delete packageJson.main;\n  delete packageJson.module;\n  delete packageJson.exports;\n\n  console.log(`\\nstart dnt: ${packageJson.name}`);\n\n  const npmDir = rootResolve(`./npm/${packageJson.name.split(\"/\").pop()}`);\n  const npmResolve = (p: string) => path.resolve(npmDir, p);\n\n  await emptyDir(npmDir);\n\n  if (version) {\n    Object.assign(packageJson, { version: version });\n  }\n\n  await build({\n    entryPoints: [{ name: \".\", path: packageResolve(\"./index.ts\") }],\n    outDir: npmDir,\n    packageManager: \"pnpm\",\n    shims: {\n      deno: true,\n    },\n    // you should open it in actual\n    test: false,\n    importMap: importMap,\n    package: packageJson,\n    // custom by yourself\n    compilerOptions: {\n      lib: [\"DOM\", \"ES2022\"],\n      target: \"ES2022\",\n      emitDecoratorMetadata: true,\n    },\n    postBuild() {\n      // steps to run after building and before running the tests\n      Deno.copyFileSync(rootResolve(\"./LICENSE\"), npmResolve(\"./LICENSE\"));\n      Deno.copyFileSync(\n        packageResolve(\"./README.md\"),\n        npmResolve(\"./README.md\")\n      );\n    },\n    ...options,\n  });\n};\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003c/ol>\n\u003ch3>主要步骤\u003c/h3>\n\u003col>\n\u003cli>\n\u003cp>创建两个子文件夹，加入一些项目文件\u003c/p>\n\u003cpre>\u003ccode class=\"language-shell\"># start from root\nmkdir packages/module-a\ncd packages/module-a\necho \"export const a = 1;\" > index.ts\necho \"# @dnt-mono/module-a\" > README.md\nnpm init --scope @dnt-mono --yes # name : @dnt-mono/module-a\n\u003c/code>\u003c/pre>\n\u003cp>同样的步骤，创建 \u003ccode>module-b\u003c/code> 文件夹\u003c/p>\n\u003cpre>\u003ccode class=\"language-shell\"># start from root\nmkdir packages/module-b\ncd packages/module-b\necho \"import { a } from \\\"@dnt-mono/module-a\\\";\\nexport const b = a + 1;\" > index.ts\necho \"# @dnt-mono/module-b\" > README.md\nnpm init --scope @dnt-mono --yes # name : @dnt-mono/module-b\n\npnpm add @dnt-mono/module-a --workspace # add module-a as dependencie\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>在这个事例中， \u003ccode>module-b\u003c/code> 依赖了 \u003ccode>module-a\u003c/code>，同时我们在代码中使用了 \u003ccode>@dnt-mono/module-a\u003c/code> 这个 specifier，所以我们为了让 deno 的语言服务器正确工作，还需要做一些配置。在 \u003ccode>deno.json\u003c/code> 的 \u003ccode>imports\u003c/code> 字段中加入这些配置：\u003c/p>\n\u003cpre>\u003ccode class=\"language-jsonc\"> \"@dnt-mono/module-a\": \"./packages/module-a/index.ts\", // in imports\n \"@dnt-mono/module-b\": \"./packages/module-b/index.ts\" // in imports\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>接着，我们创建构建脚本和配置文件\u003c/p>\n\u003col>\n\u003cli>\n\u003cp>\u003ccode>scripts/build_npm.ts\u003c/code>\u003c/p>\n\u003cpre>\u003ccode class=\"language-ts\">import { npmBuilder } from \"./npmBuilder.ts\";\n\nconst version = Deno.args[0];\nawait npmBuilder({\n  packageDir: import.meta.resolve(\"../packages/module-a/\"),\n  importMap: import.meta.resolve(\"./import_map.npm.json\"),\n  version,\n});\nawait npmBuilder({\n  packageDir: import.meta.resolve(\"../packages/module-b/\"),\n  importMap: import.meta.resolve(\"./import_map.npm.json\"),\n  version,\n});\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003ccode>scripts/import_map.npm.json\u003c/code>\u003c/p>\n\u003cpre>\u003ccode class=\"language-json\">{\n  \"imports\": {\n    \"@dnt-mono/module-a\": \"npm:@dnt-mono/module-a\",\n    \"@dnt-mono/module-b\": \"npm:@dnt-mono/module-b\"\n  }\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003c/ol>\n\u003c/li>\n\u003cli>\n\u003cp>然后，在你的 \u003ccode>deno.json\u003c/code> 中配置 build 指令：\u003c/p>\n\u003cpre>\u003ccode class=\"language-jsonc\">\"build\": \"deno run -A ./scripts/build_npm.ts\" // in tasks\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>最后，尝试执行 build 指令，构建出 npm 目录\u003c/p>\n\u003cpre>\u003ccode class=\"language-shell\">deno task build\n\u003c/code>\u003c/pre>\n\u003cp>这时候，你可以看到 npm 目录下输出了 module-a 和 module-b 两个 npm 包文件夹。\n现在你可以尝试发布这些 npm 包了：\u003c/p>\n\u003cpre>\u003ccode class=\"language-shell\">pnpm publish -r --no-git-checks --dry-run # you should remove --dry-run actual\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003c/ol>\n\u003ch3>工作原理\u003c/h3>\n\u003col>\n\u003cli>我们使用 deno 作为语言服务器，它很强大，很多体验经过定制化开发，已经超越 tsc 本身。\u003c/li>\n\u003cli>所以 package.json 在这里只是一个“模板文件”，而不是配置文件。在开发中，真正生效的配置文件只有 deno.json\u003c/li>\n\u003cli>因此，pnpm 在这里是一个面向 dnt 最终编译产出的工具，也就是只服务于 \u003ccode>npm/*\u003c/code> 的目录。这也是为什么 \u003ccode>pnpm-workspaces.yaml\u003c/code> 的配置是这样的\u003c/li>\n\u003cli>dnt 中使用的 \u003ccode>import_map.npm.json\u003c/code> 很重要，我们不能直接使用 \u003ccode>deno.json\u003c/code> 作为 \u003ccode>importMap\u003c/code>，因为\u003ccode>deno.json\u003c/code>配置给 deno 语言服务器，而 \u003ccode>import_map.npm.json\u003c/code> 是配置给 dnt/pnpm 使用的。在复杂的项目中，建议你用脚本自动生成并管理它。\u003c/li>\n\u003c/ol>\n\u003ch3>进阶技巧\u003c/h3>\n\u003cp>在 deno 的开发中，我们的理念是面向文件而不是面向模块，因此如果有需要，你需要增加这样的配置在\u003ccode>deno.json\u003c/code>中：\u003c/p>\n\u003cpre>\u003ccode class=\"language-jsonc\">{\n  // ...\n  \"imports\": {\n    // ...\n    \"@dnt-mono/module-a\": \"./packages/module-a/index.ts\",\n    \"@dnt-mono/module-a/\": \"./packages/module-a/src/\",\n    \"@dnt-mono/module-b\": \"./packages/module-b/index.ts\",\n    \"@dnt-mono/module-b/\": \"./packages/module-b/src/\"\n    // ...\n  }\n}\n\u003c/code>\u003c/pre>\n\u003cp>我习惯将除了 \u003ccode>index.ts\u003c/code> 意外的文件放到 \u003ccode>src\u003c/code> 目录下，这会更加符合 node 项目的风格。\u003c/p>\n\u003cblockquote>\n\u003cp>但切记，不要把 index.ts 文件也挪到 \u003ccode>src\u003c/code> 目录下，否则会引发异常 \u003ca href=\"https://github.com/denoland/dnt/issues/249\">#249\u003c/a>\u003c/p>\n\u003c/blockquote>\n\u003cp>然后，就是 dnt 的配置，你需要遍历你所有的文件，并将它配置到 entryPoints 中：\u003c/p>\n\u003cpre>\u003ccode class=\"language-ts\">build({\n  entryPoints: [\n    // default entry\n    { name: \".\", path: packageResolve(\"./index.ts\") },\n    // src files\n    ALL_SRC_TS_FILES.map((name) => ({\n      name: `./${name}`,\n      path: `./src/${name}`,\n    })),\n  ],\n  // ...\n});\n\u003c/code>\u003c/pre>\n\u003cp>现在，你就可以写这样的代码了：\u003c/p>\n\u003cpre>\u003ccode class=\"language-ts\">import { xxx } from \"@dnt-mono/module-a/xxx.ts\";\n\u003c/code>\u003c/pre>\n\u003ch3>注意事项\u003c/h3>\n\u003col>\n\u003cli>规划好你的项目结构，避免形成循环依赖。如果有需要，你需要自己配置 peerDependencies\u003c/li>\n\u003cli>不要在某个模块中做自引入。\n\u003cblockquote>\n\u003cp>语言服务器并不理解你最终要发布 npm 的意图，所以即便 deno 能正确工作，但你的目的是让 node 也能工作。\u003c/p>\n\u003c/blockquote>\n\u003cpre>\u003ccode class=\"language-ts\">import { a } from \"@dnt-mono/module-a\"; // don't import module-a in module-a\n\u003c/code>\u003c/pre>\n在正式的项目中，建议编写 lint 规则来避免这种错误的发生\u003c/li>\n\u003c/ol>\n\u003ch3>优势\u003c/h3>","markdownContent":"\n## 使用 dnt 将你的 deno 项目发布成 monorepo 风格\n\n> 在提供理论指导之前，我们先看具体的实践如何做到，完成后，我再说明这种项目管理方案的优势在哪里。\n\n### 工具\n\n1. [deno](https://deno.com/)\n2. [pnpm](https://pnpm.io/installation)\n\n### 准备工作\n\n1. 创建你的项目：\n   ```shell\n   deno init dnt-mono\n   # cd dnt-mono\n   # code . # open in ide\n   ```\n1. 初始化 git 仓库\n   ```shell\n   git init\n   echo \"npm\\nnode_modules\" > .gitignore # ignore the npm folder\n   ```\n1. 初始化 package.json，以及一些 npm/pnpm 通常所需的文件\n   ```shell\n   npm init --yes --private # create a package.json file\n   echo \"MIT\" > LICENSE\n   echo \"# Hello Dnt ❤️ Monorepo\" > README.md\n   echo \"packages:\\n  - \\\"npm/*\\\"\" > pnpm-workspace.yaml\n   ```\n1. 准备 dnt 脚本\n\n   ```shell\n   deno add @deno/dnt\n   ```\n\n   参考 [Setup](https://github.com/denoland/dnt?tab=readme-ov-file#setup)，因为我们需要构建多个 npm 包，所以创建 `scripts/npmBuilder.ts` 文件：\n\n   ```ts\n   import { build, BuildOptions, emptyDir } from \"@deno/dnt\";\n   import fs from \"node:fs\";\n   import path from \"node:path\";\n   import { fileURLToPath } from \"node:url\";\n\n   const rootDir = import.meta.resolve(\"../\");\n   const rootResolve = (path: string) => fileURLToPath(new URL(path, rootDir));\n   export const npmBuilder = async (config: {\n     packageDir: string;\n     version?: string;\n     importMap?: string;\n     options?: Partial\u003cBuildOptions>;\n   }) => {\n     const { packageDir, version, importMap, options } = config;\n     const packageResolve = (path: string) =>\n       fileURLToPath(new URL(path, packageDir));\n     const packageJson = JSON.parse(\n       fs.readFileSync(packageResolve(\"./package.json\"), \"utf-8\")\n     );\n     // remove some field which dnt will create. if you known how dnt work, you can keep them.\n     delete packageJson.main;\n     delete packageJson.module;\n     delete packageJson.exports;\n\n     console.log(`\\nstart dnt: ${packageJson.name}`);\n\n     const npmDir = rootResolve(`./npm/${packageJson.name.split(\"/\").pop()}`);\n     const npmResolve = (p: string) => path.resolve(npmDir, p);\n\n     await emptyDir(npmDir);\n\n     if (version) {\n       Object.assign(packageJson, { version: version });\n     }\n\n     await build({\n       entryPoints: [{ name: \".\", path: packageResolve(\"./index.ts\") }],\n       outDir: npmDir,\n       packageManager: \"pnpm\",\n       shims: {\n         deno: true,\n       },\n       // you should open it in actual\n       test: false,\n       importMap: importMap,\n       package: packageJson,\n       // custom by yourself\n       compilerOptions: {\n         lib: [\"DOM\", \"ES2022\"],\n         target: \"ES2022\",\n         emitDecoratorMetadata: true,\n       },\n       postBuild() {\n         // steps to run after building and before running the tests\n         Deno.copyFileSync(rootResolve(\"./LICENSE\"), npmResolve(\"./LICENSE\"));\n         Deno.copyFileSync(\n           packageResolve(\"./README.md\"),\n           npmResolve(\"./README.md\")\n         );\n       },\n       ...options,\n     });\n   };\n   ```\n\n### 主要步骤\n\n1. 创建两个子文件夹，加入一些项目文件\n\n   ```shell\n   # start from root\n   mkdir packages/module-a\n   cd packages/module-a\n   echo \"export const a = 1;\" > index.ts\n   echo \"# @dnt-mono/module-a\" > README.md\n   npm init --scope @dnt-mono --yes # name : @dnt-mono/module-a\n   ```\n\n   同样的步骤，创建 `module-b` 文件夹\n\n   ```shell\n   # start from root\n   mkdir packages/module-b\n   cd packages/module-b\n   echo \"import { a } from \\\"@dnt-mono/module-a\\\";\\nexport const b = a + 1;\" > index.ts\n   echo \"# @dnt-mono/module-b\" > README.md\n   npm init --scope @dnt-mono --yes # name : @dnt-mono/module-b\n\n   pnpm add @dnt-mono/module-a --workspace # add module-a as dependencie\n   ```\n\n1. 在这个事例中， `module-b` 依赖了 `module-a`，同时我们在代码中使用了 `@dnt-mono/module-a` 这个 specifier，所以我们为了让 deno 的语言服务器正确工作，还需要做一些配置。在 `deno.json` 的 `imports` 字段中加入这些配置：\n\n   ```jsonc\n    \"@dnt-mono/module-a\": \"./packages/module-a/index.ts\", // in imports\n    \"@dnt-mono/module-b\": \"./packages/module-b/index.ts\" // in imports\n   ```\n\n1. 接着，我们创建构建脚本和配置文件\n\n   1. `scripts/build_npm.ts`\n\n      ```ts\n      import { npmBuilder } from \"./npmBuilder.ts\";\n\n      const version = Deno.args[0];\n      await npmBuilder({\n        packageDir: import.meta.resolve(\"../packages/module-a/\"),\n        importMap: import.meta.resolve(\"./import_map.npm.json\"),\n        version,\n      });\n      await npmBuilder({\n        packageDir: import.meta.resolve(\"../packages/module-b/\"),\n        importMap: import.meta.resolve(\"./import_map.npm.json\"),\n        version,\n      });\n      ```\n\n   1. `scripts/import_map.npm.json`\n\n      ```json\n      {\n        \"imports\": {\n          \"@dnt-mono/module-a\": \"npm:@dnt-mono/module-a\",\n          \"@dnt-mono/module-b\": \"npm:@dnt-mono/module-b\"\n        }\n      }\n      ```\n\n1. 然后，在你的 `deno.json` 中配置 build 指令：\n\n   ```jsonc\n   \"build\": \"deno run -A ./scripts/build_npm.ts\" // in tasks\n   ```\n\n1. 最后，尝试执行 build 指令，构建出 npm 目录\n   ```shell\n   deno task build\n   ```\n   这时候，你可以看到 npm 目录下输出了 module-a 和 module-b 两个 npm 包文件夹。\n   现在你可以尝试发布这些 npm 包了：\n   ```shell\n   pnpm publish -r --no-git-checks --dry-run # you should remove --dry-run actual\n   ```\n\n### 工作原理\n\n1. 我们使用 deno 作为语言服务器，它很强大，很多体验经过定制化开发，已经超越 tsc 本身。\n1. 所以 package.json 在这里只是一个“模板文件”，而不是配置文件。在开发中，真正生效的配置文件只有 deno.json\n1. 因此，pnpm 在这里是一个面向 dnt 最终编译产出的工具，也就是只服务于 `npm/*` 的目录。这也是为什么 `pnpm-workspaces.yaml` 的配置是这样的\n1. dnt 中使用的 `import_map.npm.json` 很重要，我们不能直接使用 `deno.json` 作为 `importMap`，因为`deno.json`配置给 deno 语言服务器，而 `import_map.npm.json` 是配置给 dnt/pnpm 使用的。在复杂的项目中，建议你用脚本自动生成并管理它。\n\n### 进阶技巧\n\n在 deno 的开发中，我们的理念是面向文件而不是面向模块，因此如果有需要，你需要增加这样的配置在`deno.json`中：\n\n```jsonc\n{\n  // ...\n  \"imports\": {\n    // ...\n    \"@dnt-mono/module-a\": \"./packages/module-a/index.ts\",\n    \"@dnt-mono/module-a/\": \"./packages/module-a/src/\",\n    \"@dnt-mono/module-b\": \"./packages/module-b/index.ts\",\n    \"@dnt-mono/module-b/\": \"./packages/module-b/src/\"\n    // ...\n  }\n}\n```\n\n我习惯将除了 `index.ts` 意外的文件放到 `src` 目录下，这会更加符合 node 项目的风格。\n\n> 但切记，不要把 index.ts 文件也挪到 `src` 目录下，否则会引发异常 [#249](https://github.com/denoland/dnt/issues/249)\n\n然后，就是 dnt 的配置，你需要遍历你所有的文件，并将它配置到 entryPoints 中：\n\n```ts\nbuild({\n  entryPoints: [\n    // default entry\n    { name: \".\", path: packageResolve(\"./index.ts\") },\n    // src files\n    ALL_SRC_TS_FILES.map((name) => ({\n      name: `./${name}`,\n      path: `./src/${name}`,\n    })),\n  ],\n  // ...\n});\n```\n\n现在，你就可以写这样的代码了：\n\n```ts\nimport { xxx } from \"@dnt-mono/module-a/xxx.ts\";\n```\n\n### 注意事项\n\n1. 规划好你的项目结构，避免形成循环依赖。如果有需要，你需要自己配置 peerDependencies\n1. 不要在某个模块中做自引入。\n   > 语言服务器并不理解你最终要发布 npm 的意图，所以即便 deno 能正确工作，但你的目的是让 node 也能工作。\n   ```ts\n   import { a } from \"@dnt-mono/module-a\"; // don't import module-a in module-a\n   ```\n   在正式的项目中，建议编写 lint 规则来避免这种错误的发生\n\n### 优势\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.Drxmn1Vl.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.Dy4hh5dO.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-BaTxRAW4.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-CZaZKh6Z.js" as="script" type="text/javascript">
      </body>
    </html>