{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0027.The-Mind-contract-of-js-IDE-Pact.js-is-a-simple-and-extremely-powerful-Key-Value-manager"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0027.The-Mind-contract-of-js-IDE-Pact.js-is-a-simple-and-extremely-powerful-Key-Value-manager.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"JS的心灵契约——Mide-Pact.js一个简洁又异常强大的Key-Value管理器","date":"!Date:2016-08-20T21:56:03.000Z","updated":"!Date:2016-10-29T09:24:39.000Z","tags":["javascript","tools"]},"metadata":{"layout":"layouts/article.njk","title":"JS的心灵契约——Mide-Pact.js一个简洁又异常强大的Key-Value管理器","date":"!Date:2016-08-20T21:56:03.000Z","updated":"!Date:2016-10-29T09:24:39.000Z","tags":["javascript","tools"],"id":"0027.The-Mind-contract-of-js-IDE-Pact.js-is-a-simple-and-extremely-powerful-Key-Value-manager","createdAt":"!Date:2016-08-20T21:56:03.000Z","updatedAt":"!Date:2016-10-29T09:24:39.000Z"},"htmlContent":"<h1>前言</h1>\n<p><a href=\"https://gist.github.com/Gaubee/e32b0001413d641b224c1f9c9d359161\">mind-pact.js</a>\n这个东西，以前做过，但是做得不够好，而且是整合在以前开发的MVVM框架里头，作为Model层。\n这两天整理了一下，凝练了核心的思想。</p>\n<p>这个库，是一个key-value管理器。简单的说就是：</p>\n<pre><code class=\"language-js\">model.set(\"a.b\",1);\nmodel.get(\"a\");//{ b:1 }\n</code></pre>\n<p><strong>最重要的特性：支持表达式</strong>：</p>\n<pre><code class=\"language-js\">model.get(\"a['b']\");//1\n</code></pre>\n<p>但我们知道JS的表达式里头是可以支持函数的定义等等的，这里做了一定的限制，但又不会失去灵活性，具体看如下API描述：</p>\n<h1>API 文档</h1>\n<h2>MP(basedata)</h2>\n<ul>\n<li><strong>basedata</strong> (<em>except Primitive values</em>) : 除了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Primitive_values\">Primitive values</a> 以外的任意对象</li>\n</ul>\n<h2>MP.prototype.set(paths, value, context)</h2>\n<ul>\n<li><strong>paths</strong> (<em>string</em>) : <del>懒得描述</del></li>\n<li><strong>value</strong> (<em>any</em>) : <del>懒得描述</del></li>\n<li><strong>context</strong> (<em>object | null</em>) : 表达式的上下文对象，具体怎么用后面描述</li>\n</ul>\n<h2>MP.prototype.get(paths, context)</h2>\n<ul>\n<li><strong>paths</strong> (<em>string</em>) : <del>懒得描述</del></li>\n<li><strong>context</strong> (<em>object | null</em>) : 表达式的上下文对象，具体怎么用后面描述</li>\n</ul>\n<p>这里说一下这个<strong>context</strong>对象的作用把。就是前面说到的“JS的表达式里头是可以支持函数的定义等等的，这里做了一定的限制，但又不会失去灵活性”的一个解决方案，比如说：</p>\n<pre><code class=\"language-js\">// 原始表达式\na+(function(){ return Math.random() })()+b;\n// 提取出function部分后变成：\na+foo()+b\n//context就是提取出来的对象：\ncontext = {\n  foo:function(){ return Math.random() }\n}\n</code></pre>\n<p>如何深入去用我就不多说了</p>\n<h2>MP.CustomType(getter [, setter])</h2>\n<blockquote>\n<p>自定义数据类型</p>\n</blockquote>\n<ul>\n<li><strong>getter</strong> (<em>string| [string,any] | function($cur_key, $pre_path_str, $full_path_str)</em>) : 支持三种格式：字符串表达式、字符串表达式+上下文，函数</li>\n<li><strong>setter</strong> (<em>string| [string,any] | function($cur_key, $new_value, $pre_path_str, $full_path_str)</em>) : <em>此参数可空</em></li>\n</ul>\n<p>自定义数据类型，为什么不直接使用JS内置的Getter、Setter呢？这个自定义类型的优势如下：</p>\n<ol>\n<li>支持字符串，而且是<strong>鸭子类型</strong>的数据，这就意味着可以序列化，使用JSON来传递这个动态数据的Getter、Setter。</li>\n<li>更为丰富的上下文信息，JS原始的setter、getter是只能知道自己的this对象，而CustomType在运行getter、setter可以知道自己所在的调用时的具体路径</li>\n</ol>\n<p>值得注意的是这里的表达式会比<code>MP.prototype.get/set</code>中的表达式更为强大，因为内置了一些关键字。这里统一讲一下关键字：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">关键字</th>\n<th align=\"center\">支持get/set</th>\n<th align=\"center\">支持CustomType的getter/setter</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">__vm</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\">model实例对象本身</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">__context</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\">上下文对象</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">__global</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\">全局对象</td>\n<td align=\"center\">浏览器环境中指向window</td>\n</tr>\n<tr>\n<td align=\"center\">$cur_key</td>\n<td align=\"center\">×/×</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\">当前对象所在this中的key</td>\n<td align=\"center\">a.b.c = CustomType( * , * )，这里指向的就是\"c\"</td>\n</tr>\n<tr>\n<td align=\"center\">$pre_path_str</td>\n<td align=\"center\">×/×</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\"><em>看备注</em></td>\n<td align=\"center\">上述条件，这里指向\"a.b\"</td>\n</tr>\n<tr>\n<td align=\"center\">$full_path_str</td>\n<td align=\"center\">×/×</td>\n<td align=\"center\">√/√</td>\n<td align=\"center\"><em>看备注</em></td>\n<td align=\"center\">上述条件，这里指向\"a.b.c\"</td>\n</tr>\n<tr>\n<td align=\"center\">$cur_value</td>\n<td align=\"center\">×/×</td>\n<td align=\"center\">√/×</td>\n<td align=\"center\">当前缓存值</td>\n<td align=\"center\">初始化是null，每运行一次getter都会被更新</td>\n</tr>\n<tr>\n<td align=\"center\">$new_value</td>\n<td align=\"center\">×/×</td>\n<td align=\"center\">×/√</td>\n<td align=\"center\">setter所要赋予的值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">$old_value</td>\n<td align=\"center\">×/×</td>\n<td align=\"center\">×/√</td>\n<td align=\"center\">当前缓存值</td>\n<td align=\"center\">同$cur_value，只是这里只能在setter中使用</td>\n</tr>\n</tbody>\n</table>\n<p>所以围绕这些关键字，来实现一个基础的CustomType对象，就是<code>fullName=firstName lastName</code>。\n实现代码如下：\n<strong>版本1</strong></p>\n<blockquote>\n<p>这个是单纯的getter，简单直观，但是问题在于\"me.\"这个写死在表达式中了，就意味着如果这个数据发生迁移或者复制到其它地方，就会运行出现问题。</p>\n</blockquote>\n<pre><code class=\"language-js\">m.set(\"me\", {\n    firstname: \"Gaubee\",\n    lastname: \"Bangeel\",\n    fullname: CustomType(\"me.firstname+' '+me.lastname\")\n});\n</code></pre>\n<p><strong>版本2</strong></p>\n<blockquote>\n<p>这里用到了<code>__vm</code>与<code>$pre_path_str</code>两个关键字，其中<code>$pre_path_str</code>用来替代版本1中的\"me.\"，然后由于使用了<code>$pre_path_str</code>关键字，解析就不会用<code>__vm.get(*)</code>自动包裹这个关键字，所以需要手动添加这段代码，结果如下：</p>\n</blockquote>\n<pre><code class=\"language-js\">m.set(\"me\", {\n    firstname: \"Gaubee\",\n    lastname: \"Bangeel\",\n    fullname: CustomType(\"__vm.get($pre_path_str+'.firstname')+' '+__vm.get($pre_path_str+'.lastname')\")\n});\n</code></pre>\n<p><strong>版本3</strong></p>\n<blockquote>\n<p>这里实现了Setter，要值得注意的是，setter的表达式里头，多个语句的分割是<code>,</code>而不是<code>;</code>，因为这个单个表达式，简而言之就是解析是把表达式处理成<code>return *</code>，所以如果使用<code>;</code>就会导致<code>;</code>后面的语句不运行（PS：<strong>不要利用这点来实现局部变量的定义，虽然var声明会自动前置，但是请使用context来声明局部变量，否则如果变量名不在context中，会被直接包裹成<code>__vm.get(key)</code>进行处理</strong>）。另外值得注意的是这里表达式最后返回是<code>null</code>，如果返回<code>null/undefined/false</code>，那么就意味着$new_value最后是存储到默认的缓存中；如果返回的不是空值，那么就会被当成是路径，直接将$new_value赋值到这个路径所指定的对象中。</p>\n</blockquote>\n<pre><code class=\"language-js\">m.set(\"me\", {\n    firstname: \"Gaubee\",\n    lastname: \"Bangeel\",\n    fullname: CustomType(\"__vm.get($pre_path_str+'.firstname')+' '+__vm.get($pre_path_str+'.lastname')\",\n        \"($new_value=$new_value.split(' ')),\\\n        __vm.set($pre_path_str+'.firstname',$new_value[0]),\\\n        __vm.set($pre_path_str+'.lastname',$new_value[1]),\\\n        null\")\n});\n</code></pre>\n<h1>技术实现细节</h1>\n<blockquote>\n<p>这部分是讲到一些效率优化、解析处理等实现细节。</p>\n</blockquote>\n<h2>1</h2>\n<p>因为不是以往的<code>a.b.c</code>这样耿直的用<code>.</code>来分割了，而MP涉及到表达式，即便用了缓存，如果遇到数组<code>a.1</code>~<code>a.1000</code>，那么缓存还有用么？\n这个是在开始做的时候一个难点，最后实现确实我用了缓存，但是不是耿直用。这里缓存的不是<code>路径:函数</code>，而是<code>模式:函数</code>。基于模式的缓存，比如说<code>a.1</code>与<code>a.1000</code>，这两者的模式是一样的，所以只用了同一个模式工厂函数，而后将<code>a.1/1000</code>传入模式工厂函数中，返回一个带着闭包的函数。怎么解释看下面这个实例：</p>\n<pre><code class=\"language-js\">MP.formatKey(\"a.b[A.B+C-D(E,F)].c\");\n/*[ 'a', 'b', \nfunction(__vm) {\n    return PLA(matchs[0], __vm, __context) +\n        PLA(matchs[1], __vm, __context) -\n        PLA(matchs[2], __vm, __context)(\n            PLA(matchs[3], __vm, __context),\n            PLA(matchs[4], __vm, __context)\n        )\n}\n, 'c']\n这里返回的数组中的第三个对象，就是模式工厂返回的函数，其中matchs、__context都是处于闭包中，\n所以同样模式的表达式（`@+@-@(@,@)`）可以公用这个模式工厂。\n*/\n</code></pre>\n<p>因为我认为在一个WebApp中，取值路径可能有上万个，但是模式不过那么几种——应用里头的字符串就那些。所以基于模式的匹配是很靠谱的一种解决方案，即便有动态的模式，使用context也能化繁为简，充分利用模式缓存。</p>\n<h2>2</h2>\n<p>另外，看上面那个formatKey返回的数组数据，可以发现其实<code>[ * ]</code>包裹起来的部分其实是会被解析成函数的，所以<code>[ * ]</code>内外是有性能区别的，也因此，能在外部写<code>a.1</code>这种违反JS语法的写法，正常JS写法是<code>a[1]</code>，而为了性能，我建议是使用<code>a.1</code>。上面说到模式，这里说道表达式，就不得不说一下解析：\n这里是提取<code>x.x.x</code>作为<strong>路径单元</strong>，<code>[ * ]</code>作为<strong>模式单元</strong>，所以上述例子里头<code>[A.B+C-D(E,F)]</code>开头的<code>A.B</code>是被会识别成<strong>路径单元</strong>，最后模式才<strong>不是</strong>：<code>@.@+@-@(@,@)</code></p>\n<h2>3</h2>\n<p>动态的赋值。如果一个路径是<code>a.b.c.d</code>，而<code>a</code>属性本身就是空的话，那么在<code>model.set('a.b.c.d',value)</code>的过程中，会动态创建值给<code>a b c d</code>，如果路径某一部分的key是整数，那么动态创建的就会是数组：</p>\n<pre><code class=\"language-js\">m.set(\"A.B.1.C\",\"ccc\");\nconsole.log(m.get(\"A\"));\n//{ B: [ , { C: 'ccc' } ] }\n</code></pre>\n<hr>\n<p>【<strong>8/21 6:08</strong>】 目前功能有限，但代码就不到400行，接下来会加入动态监听功能，有了这个MP才完整。</p>","markdownContent":"\n# 前言\n\n[mind-pact.js](https://gist.github.com/Gaubee/e32b0001413d641b224c1f9c9d359161)\n这个东西，以前做过，但是做得不够好，而且是整合在以前开发的MVVM框架里头，作为Model层。\n这两天整理了一下，凝练了核心的思想。\n\n这个库，是一个key-value管理器。简单的说就是：\n\n``` js\nmodel.set(\"a.b\",1);\nmodel.get(\"a\");//{ b:1 }\n```\n\n**最重要的特性：支持表达式**：\n\n``` js\nmodel.get(\"a['b']\");//1\n```\n\n但我们知道JS的表达式里头是可以支持函数的定义等等的，这里做了一定的限制，但又不会失去灵活性，具体看如下API描述：\n# API 文档\n## MP(basedata)\n- **basedata** (_except Primitive values_) : 除了[Primitive values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Primitive_values) 以外的任意对象\n## MP.prototype.set(paths, value, context)\n- **paths** (_string_) : ~~懒得描述~~\n- **value** (_any_) : ~~懒得描述~~\n- **context** (_object | null_) : 表达式的上下文对象，具体怎么用后面描述\n## MP.prototype.get(paths, context)\n- **paths** (_string_) : ~~懒得描述~~\n- **context** (_object | null_) : 表达式的上下文对象，具体怎么用后面描述\n\n这里说一下这个**context**对象的作用把。就是前面说到的“JS的表达式里头是可以支持函数的定义等等的，这里做了一定的限制，但又不会失去灵活性”的一个解决方案，比如说：\n\n``` js\n// 原始表达式\na+(function(){ return Math.random() })()+b;\n// 提取出function部分后变成：\na+foo()+b\n//context就是提取出来的对象：\ncontext = {\n  foo:function(){ return Math.random() }\n}\n```\n\n如何深入去用我就不多说了\n## MP.CustomType(getter [, setter])\n\n> 自定义数据类型\n- **getter** (_string| [string,any] | function($cur_key, $pre_path_str, $full_path_str)_) : 支持三种格式：字符串表达式、字符串表达式+上下文，函数\n- **setter** (_string| [string,any] | function($cur_key, $new_value, $pre_path_str, $full_path_str)_) : _此参数可空_\n\n自定义数据类型，为什么不直接使用JS内置的Getter、Setter呢？这个自定义类型的优势如下：\n1. 支持字符串，而且是**鸭子类型**的数据，这就意味着可以序列化，使用JSON来传递这个动态数据的Getter、Setter。\n2. 更为丰富的上下文信息，JS原始的setter、getter是只能知道自己的this对象，而CustomType在运行getter、setter可以知道自己所在的调用时的具体路径\n\n值得注意的是这里的表达式会比`MP.prototype.get/set`中的表达式更为强大，因为内置了一些关键字。这里统一讲一下关键字：\n\n| 关键字 | 支持get/set | 支持CustomType的getter/setter | 描述 | 备注 |\n| :-: | :-: | :-: | :-: | :-: |\n| __vm | √/√ | √/√ | model实例对象本身 |  |\n| __context | √/√ | √/√ | 上下文对象 |  |\n| __global | √/√ | √/√ | 全局对象 | 浏览器环境中指向window |\n| $cur_key | ×/× | √/√ | 当前对象所在this中的key | a.b.c = CustomType( \\* , \\* )，这里指向的就是\"c\" |\n| $pre_path_str | ×/× | √/√ | _看备注_ | 上述条件，这里指向\"a.b\" |\n| $full_path_str | ×/× | √/√ | _看备注_ | 上述条件，这里指向\"a.b.c\" |\n| $cur_value | ×/× | √/× | 当前缓存值 | 初始化是null，每运行一次getter都会被更新 |\n| $new_value | ×/× | ×/√ | setter所要赋予的值 |  |\n| $old_value | ×/× | ×/√ | 当前缓存值 | 同$cur_value，只是这里只能在setter中使用 |\n\n所以围绕这些关键字，来实现一个基础的CustomType对象，就是`fullName=firstName lastName`。\n实现代码如下：\n**版本1**\n\n> 这个是单纯的getter，简单直观，但是问题在于\"me.\"这个写死在表达式中了，就意味着如果这个数据发生迁移或者复制到其它地方，就会运行出现问题。\n\n``` js\nm.set(\"me\", {\n    firstname: \"Gaubee\",\n    lastname: \"Bangeel\",\n    fullname: CustomType(\"me.firstname+' '+me.lastname\")\n});\n```\n\n**版本2**\n\n> 这里用到了`__vm`与`$pre_path_str`两个关键字，其中`$pre_path_str`用来替代版本1中的\"me.\"，然后由于使用了`$pre_path_str`关键字，解析就不会用`__vm.get(*)`自动包裹这个关键字，所以需要手动添加这段代码，结果如下：\n\n``` js\nm.set(\"me\", {\n    firstname: \"Gaubee\",\n    lastname: \"Bangeel\",\n    fullname: CustomType(\"__vm.get($pre_path_str+'.firstname')+' '+__vm.get($pre_path_str+'.lastname')\")\n});\n```\n\n**版本3**\n\n> 这里实现了Setter，要值得注意的是，setter的表达式里头，多个语句的分割是`,`而不是`;`，因为这个单个表达式，简而言之就是解析是把表达式处理成`return *`，所以如果使用`;`就会导致`;`后面的语句不运行（PS：**不要利用这点来实现局部变量的定义，虽然var声明会自动前置，但是请使用context来声明局部变量，否则如果变量名不在context中，会被直接包裹成`__vm.get(key)`进行处理**）。另外值得注意的是这里表达式最后返回是`null`，如果返回`null/undefined/false`，那么就意味着$new_value最后是存储到默认的缓存中；如果返回的不是空值，那么就会被当成是路径，直接将$new_value赋值到这个路径所指定的对象中。\n\n``` js\nm.set(\"me\", {\n    firstname: \"Gaubee\",\n    lastname: \"Bangeel\",\n    fullname: CustomType(\"__vm.get($pre_path_str+'.firstname')+' '+__vm.get($pre_path_str+'.lastname')\",\n        \"($new_value=$new_value.split(' ')),\\\n        __vm.set($pre_path_str+'.firstname',$new_value[0]),\\\n        __vm.set($pre_path_str+'.lastname',$new_value[1]),\\\n        null\")\n});\n```\n# 技术实现细节\n\n> 这部分是讲到一些效率优化、解析处理等实现细节。\n## 1\n\n因为不是以往的`a.b.c`这样耿直的用`.`来分割了，而MP涉及到表达式，即便用了缓存，如果遇到数组`a.1`~`a.1000`，那么缓存还有用么？\n这个是在开始做的时候一个难点，最后实现确实我用了缓存，但是不是耿直用。这里缓存的不是`路径:函数`，而是`模式:函数`。基于模式的缓存，比如说`a.1`与`a.1000`，这两者的模式是一样的，所以只用了同一个模式工厂函数，而后将`a.1/1000`传入模式工厂函数中，返回一个带着闭包的函数。怎么解释看下面这个实例：\n\n``` js\nMP.formatKey(\"a.b[A.B+C-D(E,F)].c\");\n/*[ 'a', 'b', \nfunction(__vm) {\n    return PLA(matchs[0], __vm, __context) +\n        PLA(matchs[1], __vm, __context) -\n        PLA(matchs[2], __vm, __context)(\n            PLA(matchs[3], __vm, __context),\n            PLA(matchs[4], __vm, __context)\n        )\n}\n, 'c']\n这里返回的数组中的第三个对象，就是模式工厂返回的函数，其中matchs、__context都是处于闭包中，\n所以同样模式的表达式（`@+@-@(@,@)`）可以公用这个模式工厂。\n*/\n```\n\n因为我认为在一个WebApp中，取值路径可能有上万个，但是模式不过那么几种——应用里头的字符串就那些。所以基于模式的匹配是很靠谱的一种解决方案，即便有动态的模式，使用context也能化繁为简，充分利用模式缓存。\n## 2\n\n另外，看上面那个formatKey返回的数组数据，可以发现其实`[ * ]`包裹起来的部分其实是会被解析成函数的，所以`[ * ]`内外是有性能区别的，也因此，能在外部写`a.1`这种违反JS语法的写法，正常JS写法是`a[1]`，而为了性能，我建议是使用`a.1`。上面说到模式，这里说道表达式，就不得不说一下解析：\n这里是提取`x.x.x`作为**路径单元**，`[ * ]`作为**模式单元**，所以上述例子里头`[A.B+C-D(E,F)]`开头的`A.B`是被会识别成**路径单元**，最后模式才**不是**：`@.@+@-@(@,@)`\n## 3\n\n动态的赋值。如果一个路径是`a.b.c.d`，而`a`属性本身就是空的话，那么在`model.set('a.b.c.d',value)`的过程中，会动态创建值给`a b c d`，如果路径某一部分的key是整数，那么动态创建的就会是数组：\n\n``` js\nm.set(\"A.B.1.C\",\"ccc\");\nconsole.log(m.get(\"A\"));\n//{ B: [ , { C: 'ccc' } ] }\n```\n\n---\n\n【**8/21 6:08**】 目前功能有限，但代码就不到400行，接下来会加入动态监听功能，有了这个MP才完整。\n"}}}