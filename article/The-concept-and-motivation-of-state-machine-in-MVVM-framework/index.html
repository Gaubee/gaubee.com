<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.BzcesyCW.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          p {
            text-indent: "2em";
            line-height: 3;
          }
        </style><h1>MVVM框架中关于状态机的概念与实现动机</h1><main><p>状态机是目前库中所存在的一个高级的概念，它一定程度上是现有功能的一个组合，使用字符串指令针对状态机的操作，以下是其运作流程：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8" tabindex="0"><code class="language-text"><span class="line"><span>绑定一个事件</span></span>
<span class="line"><span>    -> 这个事件是一个命令，目前有四种基础命令：</span></span>
<span class="line"><span>       （赋值）=，（添加）+，（移除）-，（切换）?</span></span>
<span class="line"><span>            -> 事件触发，动态解析命令对状态机进行相应的操作</span></span>
<span class="line"><span>               （某种程度上就限制了效率的保证）</span></span></code></pre>
<p>这四个基础命令都是统一的格式：双目运算符的格式。
左边的参数是目标key，字符串类型，所以这是可动态的：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8" tabindex="0"><code class="language-text"><span class="line"><span>{{" {{key}} = {{"static value"}} "}}</span></span></code></pre>
<p>可以看到一个命令是一个字符串，而后两个参数都需要用<code>{{}}</code>进行包裹，其中第一个参数作为目标key，第二个参数是赋值内容，在源码不到白行的实现中也是很明了的知道其命令最终编译出来的代码是：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8" tabindex="0"><code class="language-text"><span class="line"><span>key = VI.get(key);</span></span>
<span class="line"><span>value = "static value";</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VI.set(key,value);</span></span></code></pre>
<p>再来一个例子：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8" tabindex="0"><code class="language-text"><span class="line"><span>{{" {{"key"}} = {{value}} "}}</span></span>
<span class="line"><span>//==></span></span>
<span class="line"><span>key = "key";</span></span>
<span class="line"><span>value = VI.get("value");</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VI.set(key,value);</span></span></code></pre>
<p>在状态机的操作中，两个参数都可以是动态的，就造就了状态机操作这个功能的灵巧与强大。比如一套操作中切换一个状态机，就可以把所有的操作换一个目标换一个效果。如果配合DOM的className进行使用能有什么效果，你懂的。</p>
<p>然而，状态机强化了View层的功能，我依然不建议把变化大的业务功能放到这块中，如果你不怕被团队的人吐槽的话（××的改个代码还要跑到View层改！！）</p>
<p>不过这个功能用来写Weight还是很方便的，毕竟Weight中变动的是数据而不是Weight自有的逻辑（好吧我最原始的目的暴露出来的……呵呵）</p>
</main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"The-concept-and-motivation-of-state-machine-in-MVVM-framework"},"data":{"article":{"metadata":{"layout":"layouts/article.njk","title":"MVVM框架中关于状态机的概念与实现动机","date":"!Date:2013-12-09T00:55:36.000Z","updated":"!Date:2013-12-10T02:58:15.000Z","id":"The-concept-and-motivation-of-state-machine-in-MVVM-framework","createdAt":"!Date:2013-12-09T00:55:36.000Z","updatedAt":"!Date:2013-12-10T02:58:15.000Z","tags":[]},"htmlContent":"\u003cp>状态机是目前库中所存在的一个高级的概念，它一定程度上是现有功能的一个组合，使用字符串指令针对状态机的操作，以下是其运作流程：\u003c/p>\n\u003cpre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\">\u003ccode class=\"language-text\">\u003cspan class=\"line\">\u003cspan>绑定一个事件\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>    -> 这个事件是一个命令，目前有四种基础命令：\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>       （赋值）=，（添加）+，（移除）-，（切换）?\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>            -> 事件触发，动态解析命令对状态机进行相应的操作\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>               （某种程度上就限制了效率的保证）\u003c/span>\u003c/span>\u003c/code>\u003c/pre>\n\u003cp>这四个基础命令都是统一的格式：双目运算符的格式。\n左边的参数是目标key，字符串类型，所以这是可动态的：\u003c/p>\n\u003cpre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\">\u003ccode class=\"language-text\">\u003cspan class=\"line\">\u003cspan>{{\" {{key}} = {{\"static value\"}} \"}}\u003c/span>\u003c/span>\u003c/code>\u003c/pre>\n\u003cp>可以看到一个命令是一个字符串，而后两个参数都需要用\u003ccode>{{}}\u003c/code>进行包裹，其中第一个参数作为目标key，第二个参数是赋值内容，在源码不到白行的实现中也是很明了的知道其命令最终编译出来的代码是：\u003c/p>\n\u003cpre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\">\u003ccode class=\"language-text\">\u003cspan class=\"line\">\u003cspan>key = VI.get(key);\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>value = \"static value\";\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>VI.set(key,value);\u003c/span>\u003c/span>\u003c/code>\u003c/pre>\n\u003cp>再来一个例子：\u003c/p>\n\u003cpre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\">\u003ccode class=\"language-text\">\u003cspan class=\"line\">\u003cspan>{{\" {{\"key\"}} = {{value}} \"}}\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>//==>\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>key = \"key\";\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>value = VI.get(\"value\");\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>VI.set(key,value);\u003c/span>\u003c/span>\u003c/code>\u003c/pre>\n\u003cp>在状态机的操作中，两个参数都可以是动态的，就造就了状态机操作这个功能的灵巧与强大。比如一套操作中切换一个状态机，就可以把所有的操作换一个目标换一个效果。如果配合DOM的className进行使用能有什么效果，你懂的。\u003c/p>\n\u003cp>然而，状态机强化了View层的功能，我依然不建议把变化大的业务功能放到这块中，如果你不怕被团队的人吐槽的话（××的改个代码还要跑到View层改！！）\u003c/p>\n\u003cp>不过这个功能用来写Weight还是很方便的，毕竟Weight中变动的是数据而不是Weight自有的逻辑（好吧我最原始的目的暴露出来的……呵呵）\u003c/p>\n","markdownContent":"\n状态机是目前库中所存在的一个高级的概念，它一定程度上是现有功能的一个组合，使用字符串指令针对状态机的操作，以下是其运作流程：\n\n```\n绑定一个事件\n    -> 这个事件是一个命令，目前有四种基础命令：\n       （赋值）=，（添加）+，（移除）-，（切换）?\n            -> 事件触发，动态解析命令对状态机进行相应的操作\n               （某种程度上就限制了效率的保证）\n```\n\n这四个基础命令都是统一的格式：双目运算符的格式。\n左边的参数是目标key，字符串类型，所以这是可动态的：\n\n```\n{{\" {{key}} = {{\"static value\"}} \"}}\n```\n\n可以看到一个命令是一个字符串，而后两个参数都需要用`{{}}`进行包裹，其中第一个参数作为目标key，第二个参数是赋值内容，在源码不到白行的实现中也是很明了的知道其命令最终编译出来的代码是：\n\n```\nkey = VI.get(key);\nvalue = \"static value\";\n\nVI.set(key,value);\n```\n\n再来一个例子：\n\n```\n{{\" {{\"key\"}} = {{value}} \"}}\n//==>\nkey = \"key\";\nvalue = VI.get(\"value\");\n\nVI.set(key,value);\n```\n\n在状态机的操作中，两个参数都可以是动态的，就造就了状态机操作这个功能的灵巧与强大。比如一套操作中切换一个状态机，就可以把所有的操作换一个目标换一个效果。如果配合DOM的className进行使用能有什么效果，你懂的。\n\n然而，状态机强化了View层的功能，我依然不建议把变化大的业务功能放到这块中，如果你不怕被团队的人吐槽的话（××的改个代码还要跑到View层改！！）\n\n不过这个功能用来写Weight还是很方便的，毕竟Weight中变动的是数据而不是Weight自有的逻辑（好吧我最原始的目的暴露出来的……呵呵）\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.BGuB9iqG.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.BCFv3ZOD.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-Z1L0Yy9g.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-DpeCXkLi.js" as="script" type="text/javascript">
      </body>
    </html>