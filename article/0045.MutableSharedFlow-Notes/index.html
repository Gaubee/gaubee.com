<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.-4-S6IZd.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }

          main > p > img {
            max-width: 100%;
            margin: 0 auto;
            display: block;
          }
        </style><h1>MutableSharedFlow 随记</h1><main><p>MutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。
因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。
举个例子：</p>
<pre><code class="language-kotlin">val sharedFlow = MutableSharedFlow&#x3C;Int>();
launch {
    sharedFlow.collect {
        println(it) // 这里通常不会有任何打印
    }
}
sharedFlow.emit(1)
</code></pre>
<p>因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。
这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。</p>
<hr>
<p>因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。</p>
<hr>
<p>最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。
但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。
这个方案唯一的好处就是代码量相对比较少。</p>
<hr>
<p>还有一种方案是使用 Channel：</p>
<pre><code class="language-kotlin">val channel = Channel&#x3C;Int>();
val sharedFlow = channel.consumeAsFlow().shareIn(currentCoroutineContext(), SharingStarted.Lazily)
launch {
    sharedFlow.collect {
        println(it) // 这里通常不会有任何打印
    }
}
channel.send(1)
</code></pre>
<p>这个方案其实是创建了一个 Channel，两个 Flow。
其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。
第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。</p>
<p>这个方案只能说勉勉强强达到我们的需求，但问题也很多：</p>
<ol>
<li>它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。</li>
<li>flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 <code>launch sharedFlow.collect</code> ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。
<blockquote>
<p>这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:</p>
<pre><code class="language-kotlin">val channel = Channel&#x3C;Int>()
val MAX = 5;
launch {
  /// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费
  delay(1000)
  println("start send")
  for (i in 1..MAX) {
    channel.send(i)
    println("send($i)")
  }
}
val flow = channel.receiveAsFlow().shareIn(this, SharingStarted.Lazily)
launch {
  flow.collect {
    println("collect1($it)")
    delay(1000)
  }
}
launch {
  delay(2000)
  flow.collect {
    println("collect2($it)")
  }
}
</code></pre>
</blockquote>
</li>
<li>这里用 consumeAsFlow 还是 receiveAsFlow 都一样</li>
</ol>
<hr>
<p>但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手：
试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。
其实标准做法是这样的：</p>
<pre><code class="language-kotlin">val sharedFlow = MutableSharedFlow&#x3C;Int>().onSubscription {
    sharedFlow.emit(1)
}
launch {
    sharedFlow.collect {
        println(it) // 这里通常不会有任何打印
    }
}
</code></pre>
<p>但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。</p>
<hr></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0045.MutableSharedFlow-Notes"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0045.MutableSharedFlow-Notes.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"MutableSharedFlow 随记","date":"!Date:2024-04-05T11:08:28.829Z","updated":"!Date:2024-04-05T11:08:28.829Z","tags":["Kotlin"]},"metadata":{"layout":"layouts/article.njk","title":"MutableSharedFlow 随记","date":"!Date:2024-04-05T11:08:28.829Z","updated":"!Date:2024-04-05T11:08:28.829Z","tags":["Kotlin"],"id":"0045.MutableSharedFlow-Notes","createdAt":"!Date:2024-04-05T11:08:28.829Z","updatedAt":"!Date:2024-04-05T11:08:28.829Z"},"htmlContent":"\u003cp>MutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。\n因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。\n举个例子：\u003c/p>\n\u003cpre>\u003ccode class=\"language-kotlin\">val sharedFlow = MutableSharedFlow&#x3C;Int>();\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nsharedFlow.emit(1)\n\u003c/code>\u003c/pre>\n\u003cp>因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。\n这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。\u003c/p>\n\u003chr>\n\u003cp>因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。\u003c/p>\n\u003chr>\n\u003cp>最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。\n但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。\n这个方案唯一的好处就是代码量相对比较少。\u003c/p>\n\u003chr>\n\u003cp>还有一种方案是使用 Channel：\u003c/p>\n\u003cpre>\u003ccode class=\"language-kotlin\">val channel = Channel&#x3C;Int>();\nval sharedFlow = channel.consumeAsFlow().shareIn(currentCoroutineContext(), SharingStarted.Lazily)\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nchannel.send(1)\n\u003c/code>\u003c/pre>\n\u003cp>这个方案其实是创建了一个 Channel，两个 Flow。\n其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。\n第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。\u003c/p>\n\u003cp>这个方案只能说勉勉强强达到我们的需求，但问题也很多：\u003c/p>\n\u003col>\n\u003cli>它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。\u003c/li>\n\u003cli>flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 \u003ccode>launch sharedFlow.collect\u003c/code> ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。\n\u003cblockquote>\n\u003cp>这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:\u003c/p>\n\u003cpre>\u003ccode class=\"language-kotlin\">val channel = Channel&#x3C;Int>()\nval MAX = 5;\nlaunch {\n  /// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费\n  delay(1000)\n  println(\"start send\")\n  for (i in 1..MAX) {\n    channel.send(i)\n    println(\"send($i)\")\n  }\n}\nval flow = channel.receiveAsFlow().shareIn(this, SharingStarted.Lazily)\nlaunch {\n  flow.collect {\n    println(\"collect1($it)\")\n    delay(1000)\n  }\n}\nlaunch {\n  delay(2000)\n  flow.collect {\n    println(\"collect2($it)\")\n  }\n}\n\u003c/code>\u003c/pre>\n\u003c/blockquote>\n\u003c/li>\n\u003cli>这里用 consumeAsFlow 还是 receiveAsFlow 都一样\u003c/li>\n\u003c/ol>\n\u003chr>\n\u003cp>但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手：\n试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。\n其实标准做法是这样的：\u003c/p>\n\u003cpre>\u003ccode class=\"language-kotlin\">val sharedFlow = MutableSharedFlow&#x3C;Int>().onSubscription {\n    sharedFlow.emit(1)\n}\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\n\u003c/code>\u003c/pre>\n\u003cp>但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。\u003c/p>\n\u003chr>","markdownContent":"\nMutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。\n因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。\n举个例子：\n\n```kotlin\nval sharedFlow = MutableSharedFlow\u003cInt>();\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nsharedFlow.emit(1)\n```\n\n因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。\n这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。\n\n---\n\n因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。\n\n---\n\n最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。\n但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。\n这个方案唯一的好处就是代码量相对比较少。\n\n---\n\n还有一种方案是使用 Channel：\n\n```kotlin\nval channel = Channel\u003cInt>();\nval sharedFlow = channel.consumeAsFlow().shareIn(currentCoroutineContext(), SharingStarted.Lazily)\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nchannel.send(1)\n```\n\n这个方案其实是创建了一个 Channel，两个 Flow。\n其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。\n第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。\n\n这个方案只能说勉勉强强达到我们的需求，但问题也很多：\n\n1. 它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。\n1. flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 `launch sharedFlow.collect` ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。\n   > 这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:\n   >\n   > ```kotlin\n   > val channel = Channel\u003cInt>()\n   > val MAX = 5;\n   > launch {\n   >   /// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费\n   >   delay(1000)\n   >   println(\"start send\")\n   >   for (i in 1..MAX) {\n   >     channel.send(i)\n   >     println(\"send($i)\")\n   >   }\n   > }\n   > val flow = channel.receiveAsFlow().shareIn(this, SharingStarted.Lazily)\n   > launch {\n   >   flow.collect {\n   >     println(\"collect1($it)\")\n   >     delay(1000)\n   >   }\n   > }\n   > launch {\n   >   delay(2000)\n   >   flow.collect {\n   >     println(\"collect2($it)\")\n   >   }\n   > }\n   > ```\n1. 这里用 consumeAsFlow 还是 receiveAsFlow 都一样\n\n---\n\n但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手：\n试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。\n其实标准做法是这样的：\n\n```kotlin\nval sharedFlow = MutableSharedFlow\u003cInt>().onSubscription {\n    sharedFlow.emit(1)\n}\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\n```\n\n但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。\n\n---\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.Drxmn1Vl.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.Dy4hh5dO.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-BaTxRAW4.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-CZaZKh6Z.js" as="script" type="text/javascript">
      </body>
    </html>