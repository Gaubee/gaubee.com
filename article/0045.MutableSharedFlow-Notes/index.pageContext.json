{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0045.MutableSharedFlow-Notes"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0045.MutableSharedFlow-Notes.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"MutableSharedFlow 随记","date":"!Date:2024-04-05T11:08:28.829Z","updated":"!Date:2024-04-05T11:08:28.829Z","tags":["Kotlin"]},"metadata":{"layout":"layouts/article.njk","title":"MutableSharedFlow 随记","date":"!Date:2024-04-05T11:08:28.829Z","updated":"!Date:2024-04-05T11:08:28.829Z","tags":["Kotlin"],"id":"0045.MutableSharedFlow-Notes","createdAt":"!Date:2024-04-05T11:08:28.829Z","updatedAt":"!Date:2024-04-05T11:08:28.829Z"},"htmlContent":"<p>MutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。\n因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。\n举个例子：</p>\n<pre><code class=\"language-kotlin\">val sharedFlow = MutableSharedFlow&#x3C;Int>();\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nsharedFlow.emit(1)\n</code></pre>\n<p>因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。\n这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。</p>\n<hr>\n<p>因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。</p>\n<hr>\n<p>最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。\n但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。\n这个方案唯一的好处就是代码量相对比较少。</p>\n<hr>\n<p>还有一种方案是使用 Channel：</p>\n<pre><code class=\"language-kotlin\">val channel = Channel&#x3C;Int>();\nval sharedFlow = channel.consumeAsFlow().shareIn(currentCoroutineContext(), SharingStarted.Lazily)\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nchannel.send(1)\n</code></pre>\n<p>这个方案其实是创建了一个 Channel，两个 Flow。\n其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。\n第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。</p>\n<p>这个方案只能说勉勉强强达到我们的需求，但问题也很多：</p>\n<ol>\n<li>它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。</li>\n<li>flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 <code>launch sharedFlow.collect</code> ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。\n<blockquote>\n<p>这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:</p>\n<pre><code class=\"language-kotlin\">val channel = Channel&#x3C;Int>()\nval MAX = 5;\nlaunch {\n  /// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费\n  delay(1000)\n  println(\"start send\")\n  for (i in 1..MAX) {\n    channel.send(i)\n    println(\"send($i)\")\n  }\n}\nval flow = channel.receiveAsFlow().shareIn(this, SharingStarted.Lazily)\nlaunch {\n  flow.collect {\n    println(\"collect1($it)\")\n    delay(1000)\n  }\n}\nlaunch {\n  delay(2000)\n  flow.collect {\n    println(\"collect2($it)\")\n  }\n}\n</code></pre>\n</blockquote>\n</li>\n<li>这里用 consumeAsFlow 还是 receiveAsFlow 都一样</li>\n</ol>\n<hr>\n<p>但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手：\n试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。\n其实标准做法是这样的：</p>\n<pre><code class=\"language-kotlin\">val sharedFlow = MutableSharedFlow&#x3C;Int>().onSubscription {\n    sharedFlow.emit(1)\n}\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\n</code></pre>\n<p>但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。</p>\n<hr>","markdownContent":"\nMutableSharedFlow 作为一个建立在 Flow 基础上的设计，它的 Shared 特性其实与 Flow 的 collect 有着设计上的冲突。\n因为 Shared 特性，它的 emit 与它的订阅者有关系，订阅者的消费速度决定着它的发射速度。然而如果没有消费者，就意味着它的 emit 会直接丢失，而没有被消费到。\n举个例子：\n\n```kotlin\nval sharedFlow = MutableSharedFlow<Int>();\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nsharedFlow.emit(1)\n```\n\n因为 launch 的执行需要时间，在这段时间里，emit 可能已经执行完毕了，从而导致发射的值没有被任何人消费从而丢失。\n这对于将 MutableSharedFlow 直接作为 EventEmitter 的替代者来说，会是一个很严重的设计缺陷。\n\n---\n\n因此，如果要使用 MutableSharedFlow 实现 EventEmitter，需要将 MutableSharedFlow 作为一个间接方案来使用。\n\n---\n\n最简单的方案就是将 MutableSharedFlow 的 extraBufferCapacity 参数拉得非常高，等于开一个缓冲区来缓冲，这也许能解决 99%的问题。\n但这种解决方式非常奇怪，就是明知道有问题，但是用暴力的方式来规避问题发生的概率。\n这个方案唯一的好处就是代码量相对比较少。\n\n---\n\n还有一种方案是使用 Channel：\n\n```kotlin\nval channel = Channel<Int>();\nval sharedFlow = channel.consumeAsFlow().shareIn(currentCoroutineContext(), SharingStarted.Lazily)\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\nchannel.send(1)\n```\n\n这个方案其实是创建了一个 Channel，两个 Flow。\n其中一个 Flow 就是用来接收 Channel 发射出来的所有值并缓存起来（注意这个 flow 不会阻塞 channel）。\n第二个 Flow 是通过 shareIn 创建出来的，它是 SharingStarted.Lazily，也就意味着只有在 sharedFlow.collect 执行的时候，上游的 flow 才会把值发射出来（注意，这里的发送是一次性全部发射出来）。\n\n这个方案只能说勉勉强强达到我们的需求，但问题也很多：\n\n1. 它的 channel.send 并没有阻塞，而是全部被一个 flow 瞬间消费了。\n1. flow 在将数据发射给 sharedFlow 的时候也不被 sharedFlow 的订阅者阻塞，也就是说如果你同时进行两次 `launch sharedFlow.collect` ，即便第一个 sharedFlow 是在慢慢地消费，但后面那 sharedFlow 因为晚起，所以会丢失所有的数据。\n   > 这个我也不理解它怎么会这样，大家可以自己做实验，这里贴出实验代码:\n   >\n   > ```kotlin\n   > val channel = Channel<Int>()\n   > val MAX = 5;\n   > launch {\n   >   /// 所有的send，并不会被 collect 阻塞，consumeAsFlow/receiveAsFlow 已经将它全部消费\n   >   delay(1000)\n   >   println(\"start send\")\n   >   for (i in 1..MAX) {\n   >     channel.send(i)\n   >     println(\"send($i)\")\n   >   }\n   > }\n   > val flow = channel.receiveAsFlow().shareIn(this, SharingStarted.Lazily)\n   > launch {\n   >   flow.collect {\n   >     println(\"collect1($it)\")\n   >     delay(1000)\n   >   }\n   > }\n   > launch {\n   >   delay(2000)\n   >   flow.collect {\n   >     println(\"collect2($it)\")\n   >   }\n   > }\n   > ```\n1. 这里用 consumeAsFlow 还是 receiveAsFlow 都一样\n\n---\n\n但其实我们的希望是，MutableSharedFlow 能够顺序地进行 collect 与 emit。但是 collect 本身是一个阻塞函数，所以尝试从 emit 上入手：\n试着在没有订阅者的时候，需要阻塞 emit 函数，直到有订阅者的时候才进入。\n其实标准做法是这样的：\n\n```kotlin\nval sharedFlow = MutableSharedFlow<Int>().onSubscription {\n    sharedFlow.emit(1)\n}\nlaunch {\n    sharedFlow.collect {\n        println(it) // 这里通常不会有任何打印\n    }\n}\n```\n\n但这其实就不是 EventEmitter 了，比方说我用它来实现一个 onStart，难不成要等到有人来订阅了才去触发 onStart？！并不是的，onStart 它本身是跟着上下文的需求该触发时就要触发。因此官方提供的 onSubscription 这个方案并不成立。\n\n---\n"}}}