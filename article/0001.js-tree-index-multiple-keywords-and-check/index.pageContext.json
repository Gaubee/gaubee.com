{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0001.js-tree-index-multiple-keywords-and-check"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0001.js-tree-index-multiple-keywords-and-check.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"js树形索引，多关键字并查","date":"!Date:2013-05-01T03:00:38.000Z","updated":"!Date:2013-10-17T07:06:44.000Z","tags":["javascript","efficiency"]},"metadata":{"layout":"layouts/article.njk","title":"js树形索引，多关键字并查","date":"!Date:2013-05-01T03:00:38.000Z","updated":"!Date:2013-10-17T07:06:44.000Z","tags":["javascript","efficiency"],"id":"0001.js-tree-index-multiple-keywords-and-check","createdAt":"!Date:2013-05-01T03:00:38.000Z","updatedAt":"!Date:2013-10-17T07:06:44.000Z"},"htmlContent":"<p>在博客园上看到<a href=\"http://www.cnblogs.com/index-html/\">EtherDream</a>的<a href=\"http://www.cnblogs.com/index-html/archive/2013/04/17/3025682.html\">JavaScript 上万关键字瞬间匹配</a>这篇文章，感觉不错。于是改了DEMO里面的代码（耦合度是在是太高了，几乎得重新一遍才行……）</p>\n<p>这种方法的有点就是：树形的结构擅长于同时匹配<strong>多个</strong>关键字。单个关键字来说，直接用indexOf来查询、切割字符串，速度更快。</p>\n<p>改动主要在两个方面：</p>\n<ul>\n<li>对语句规范化（<a href=\"http://www.jshint.com/\">JSHint</a>规范）;</li>\n<li>改写了一部分语句，核心的语句效率几乎是达到最大，比如 <code>if(match === true)</code> 比 <code>if(match)</code> 快，另外把得出的匹配结果可读化，这个有点耗资源，不过有它存在的必要性，在后期处理数据时更快。</li>\n</ul>\n<p><strong>核心代码：</strong></p>\n<pre><code class=\"language-javascript\">var treeSearch = {\n    makeTree: function(strKeys) {\n        \"use strict\";\n        var tblCur = {},\n            tblRoot,\n            key,\n            str_key,\n            Length,\n            j,\n            i\n            ;\n        tblRoot = tblCur;\n        for ( j = strKeys.length - 1; j >= 0; j -= 1) {\n            str_key = strKeys[j];\n            Length = str_key.length;\n            for ( i = 0; i &#x3C; Length; i += 1) {\n                key = str_key.charAt(i);\n                if (tblCur.hasOwnProperty(key)) { //生成子节点 \n                    tblCur = tblCur[key];\n                } else {\n                    tblCur = tblCur[key] = {};\n                }\n            }\n            tblCur.end = true; //最后一个关键字没有分割符\n            tblCur = tblRoot;\n        }\n        return tblRoot;\n    },\n    search: function(content, tblRoot) {\n        \"use strict\";\n        var tblCur,\n            p_star = 0,\n            n = content.length,\n            p_end,\n            match,  //是否找到匹配\n            match_key,\n            match_str,\n            arrMatch = [],  //存储结果\n            arrLength = 0   //arrMatch的长度索引\n            ;\n        while (p_star &#x3C; n) {\n            tblCur = tblRoot; //回溯至根部\n            p_end = p_star;\n            match_str = \"\";\n            match = false;\n            do {\n                match_key = content.charAt(p_end);\n                if (!(tblCur = tblCur[match_key])) { //本次匹配结束\n                    p_star += 1;\n                    break;\n                }else{\n                    match_str += match_key;\n                }\n                p_end += 1;\n                if (tblCur.end === true) //是否匹配到尾部  //找到匹配关键字\n                {\n                    match = true;\n                }\n            } while (true);\n            if (match === true) { //最大匹配\n                arrMatch[arrLength] = { //增强可读性\n                    key: match_str,\n                    begin: p_star - 1,\n                    end: p_end\n                };\n                arrLength += 1;\n                p_star = p_end;\n            }\n        }\n        return arrMatch;\n    }\n};\n</code></pre>\n<p><strong>使用实例：</strong></p>\n<pre><code class=\"language-javascript\">function test(strContent, strKeys) {\n    var arrMatch,\n        tblRoot = treeSearch.makeTree(strKeys);\n    console.time(\"treeSearch\");\n    arrMatch = treeSearch.search(strContent, tblRoot);\n    console.timeEnd(\"treeSearch\");\n    console.log(arrMatch);\n}\nvar s = (function() {\n    var Things = [' ', '\\n', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    var s = \"\";\n    for (var i = 1000000; i >= 0; i--) {\n        s += Things[parseInt(Math.random() * Things.length) % Things.length]\n    };\n    return s;\n})()\ntest(s, [\"abc\", \"efge\", \"fun\", \"tree\"]);\n</code></pre>\n<p><strong>2013/4/18 23:04:35</strong></p>","markdownContent":"\n在博客园上看到[EtherDream](http://www.cnblogs.com/index-html/)的[JavaScript 上万关键字瞬间匹配](http://www.cnblogs.com/index-html/archive/2013/04/17/3025682.html)这篇文章，感觉不错。于是改了DEMO里面的代码（耦合度是在是太高了，几乎得重新一遍才行……）\n\n这种方法的有点就是：树形的结构擅长于同时匹配**多个**关键字。单个关键字来说，直接用indexOf来查询、切割字符串，速度更快。\n\n改动主要在两个方面：\n- 对语句规范化（[JSHint](http://www.jshint.com/)规范）;\n- 改写了一部分语句，核心的语句效率几乎是达到最大，比如 `if(match === true)` 比 `if(match)` 快，另外把得出的匹配结果可读化，这个有点耗资源，不过有它存在的必要性，在后期处理数据时更快。\n\n**核心代码：**\n\n``` javascript\nvar treeSearch = {\n    makeTree: function(strKeys) {\n        \"use strict\";\n        var tblCur = {},\n            tblRoot,\n            key,\n            str_key,\n            Length,\n            j,\n            i\n            ;\n        tblRoot = tblCur;\n        for ( j = strKeys.length - 1; j >= 0; j -= 1) {\n            str_key = strKeys[j];\n            Length = str_key.length;\n            for ( i = 0; i < Length; i += 1) {\n                key = str_key.charAt(i);\n                if (tblCur.hasOwnProperty(key)) { //生成子节点 \n                    tblCur = tblCur[key];\n                } else {\n                    tblCur = tblCur[key] = {};\n                }\n            }\n            tblCur.end = true; //最后一个关键字没有分割符\n            tblCur = tblRoot;\n        }\n        return tblRoot;\n    },\n    search: function(content, tblRoot) {\n        \"use strict\";\n        var tblCur,\n            p_star = 0,\n            n = content.length,\n            p_end,\n            match,  //是否找到匹配\n            match_key,\n            match_str,\n            arrMatch = [],  //存储结果\n            arrLength = 0   //arrMatch的长度索引\n            ;\n        while (p_star < n) {\n            tblCur = tblRoot; //回溯至根部\n            p_end = p_star;\n            match_str = \"\";\n            match = false;\n            do {\n                match_key = content.charAt(p_end);\n                if (!(tblCur = tblCur[match_key])) { //本次匹配结束\n                    p_star += 1;\n                    break;\n                }else{\n                    match_str += match_key;\n                }\n                p_end += 1;\n                if (tblCur.end === true) //是否匹配到尾部  //找到匹配关键字\n                {\n                    match = true;\n                }\n            } while (true);\n            if (match === true) { //最大匹配\n                arrMatch[arrLength] = { //增强可读性\n                    key: match_str,\n                    begin: p_star - 1,\n                    end: p_end\n                };\n                arrLength += 1;\n                p_star = p_end;\n            }\n        }\n        return arrMatch;\n    }\n};\n```\n\n**使用实例：**\n\n``` javascript\nfunction test(strContent, strKeys) {\n    var arrMatch,\n        tblRoot = treeSearch.makeTree(strKeys);\n    console.time(\"treeSearch\");\n    arrMatch = treeSearch.search(strContent, tblRoot);\n    console.timeEnd(\"treeSearch\");\n    console.log(arrMatch);\n}\nvar s = (function() {\n    var Things = [' ', '\\n', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    var s = \"\";\n    for (var i = 1000000; i >= 0; i--) {\n        s += Things[parseInt(Math.random() * Things.length) % Things.length]\n    };\n    return s;\n})()\ntest(s, [\"abc\", \"efge\", \"fun\", \"tree\"]);\n```\n\n**2013/4/18 23:04:35**\n"}}}