<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.B0ujMgz2.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }
        </style><h1>js树形索引，多关键字并查</h1><main><p>在博客园上看到<a href="http://www.cnblogs.com/index-html/">EtherDream</a>的<a href="http://www.cnblogs.com/index-html/archive/2013/04/17/3025682.html">JavaScript 上万关键字瞬间匹配</a>这篇文章，感觉不错。于是改了DEMO里面的代码（耦合度是在是太高了，几乎得重新一遍才行……）</p>
<p>这种方法的有点就是：树形的结构擅长于同时匹配<strong>多个</strong>关键字。单个关键字来说，直接用indexOf来查询、切割字符串，速度更快。</p>
<p>改动主要在两个方面：</p>
<ul>
<li>对语句规范化（<a href="http://www.jshint.com/">JSHint</a>规范）;</li>
<li>改写了一部分语句，核心的语句效率几乎是达到最大，比如 <code>if(match === true)</code> 比 <code>if(match)</code> 快，另外把得出的匹配结果可读化，这个有点耗资源，不过有它存在的必要性，在后期处理数据时更快。</li>
</ul>
<p><strong>核心代码：</strong></p>
<pre><code class="language-javascript">var treeSearch = {
    makeTree: function(strKeys) {
        "use strict";
        var tblCur = {},
            tblRoot,
            key,
            str_key,
            Length,
            j,
            i
            ;
        tblRoot = tblCur;
        for ( j = strKeys.length - 1; j >= 0; j -= 1) {
            str_key = strKeys[j];
            Length = str_key.length;
            for ( i = 0; i &#x3C; Length; i += 1) {
                key = str_key.charAt(i);
                if (tblCur.hasOwnProperty(key)) { //生成子节点 
                    tblCur = tblCur[key];
                } else {
                    tblCur = tblCur[key] = {};
                }
            }
            tblCur.end = true; //最后一个关键字没有分割符
            tblCur = tblRoot;
        }
        return tblRoot;
    },
    search: function(content, tblRoot) {
        "use strict";
        var tblCur,
            p_star = 0,
            n = content.length,
            p_end,
            match,  //是否找到匹配
            match_key,
            match_str,
            arrMatch = [],  //存储结果
            arrLength = 0   //arrMatch的长度索引
            ;
        while (p_star &#x3C; n) {
            tblCur = tblRoot; //回溯至根部
            p_end = p_star;
            match_str = "";
            match = false;
            do {
                match_key = content.charAt(p_end);
                if (!(tblCur = tblCur[match_key])) { //本次匹配结束
                    p_star += 1;
                    break;
                }else{
                    match_str += match_key;
                }
                p_end += 1;
                if (tblCur.end === true) //是否匹配到尾部  //找到匹配关键字
                {
                    match = true;
                }
            } while (true);
            if (match === true) { //最大匹配
                arrMatch[arrLength] = { //增强可读性
                    key: match_str,
                    begin: p_star - 1,
                    end: p_end
                };
                arrLength += 1;
                p_star = p_end;
            }
        }
        return arrMatch;
    }
};
</code></pre>
<p><strong>使用实例：</strong></p>
<pre><code class="language-javascript">function test(strContent, strKeys) {
    var arrMatch,
        tblRoot = treeSearch.makeTree(strKeys);
    console.time("treeSearch");
    arrMatch = treeSearch.search(strContent, tblRoot);
    console.timeEnd("treeSearch");
    console.log(arrMatch);
}
var s = (function() {
    var Things = [' ', '\n', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
    var s = "";
    for (var i = 1000000; i >= 0; i--) {
        s += Things[parseInt(Math.random() * Things.length) % Things.length]
    };
    return s;
})()
test(s, ["abc", "efge", "fun", "tree"]);
</code></pre>
<p><strong>2013/4/18 23:04:35</strong></p></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0001.js-tree-index-multiple-keywords-and-check"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0001.js-tree-index-multiple-keywords-and-check.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"js树形索引，多关键字并查","date":"!Date:2013-05-01T03:00:38.000Z","updated":"!Date:2013-10-17T07:06:44.000Z","tags":["javascript","efficiency"]},"metadata":{"layout":"layouts/article.njk","title":"js树形索引，多关键字并查","date":"!Date:2013-05-01T03:00:38.000Z","updated":"!Date:2013-10-17T07:06:44.000Z","tags":["javascript","efficiency"],"id":"0001.js-tree-index-multiple-keywords-and-check","createdAt":"!Date:2013-05-01T03:00:38.000Z","updatedAt":"!Date:2013-10-17T07:06:44.000Z"},"htmlContent":"\u003cp>在博客园上看到\u003ca href=\"http://www.cnblogs.com/index-html/\">EtherDream\u003c/a>的\u003ca href=\"http://www.cnblogs.com/index-html/archive/2013/04/17/3025682.html\">JavaScript 上万关键字瞬间匹配\u003c/a>这篇文章，感觉不错。于是改了DEMO里面的代码（耦合度是在是太高了，几乎得重新一遍才行……）\u003c/p>\n\u003cp>这种方法的有点就是：树形的结构擅长于同时匹配\u003cstrong>多个\u003c/strong>关键字。单个关键字来说，直接用indexOf来查询、切割字符串，速度更快。\u003c/p>\n\u003cp>改动主要在两个方面：\u003c/p>\n\u003cul>\n\u003cli>对语句规范化（\u003ca href=\"http://www.jshint.com/\">JSHint\u003c/a>规范）;\u003c/li>\n\u003cli>改写了一部分语句，核心的语句效率几乎是达到最大，比如 \u003ccode>if(match === true)\u003c/code> 比 \u003ccode>if(match)\u003c/code> 快，另外把得出的匹配结果可读化，这个有点耗资源，不过有它存在的必要性，在后期处理数据时更快。\u003c/li>\n\u003c/ul>\n\u003cp>\u003cstrong>核心代码：\u003c/strong>\u003c/p>\n\u003cpre>\u003ccode class=\"language-javascript\">var treeSearch = {\n    makeTree: function(strKeys) {\n        \"use strict\";\n        var tblCur = {},\n            tblRoot,\n            key,\n            str_key,\n            Length,\n            j,\n            i\n            ;\n        tblRoot = tblCur;\n        for ( j = strKeys.length - 1; j >= 0; j -= 1) {\n            str_key = strKeys[j];\n            Length = str_key.length;\n            for ( i = 0; i &#x3C; Length; i += 1) {\n                key = str_key.charAt(i);\n                if (tblCur.hasOwnProperty(key)) { //生成子节点 \n                    tblCur = tblCur[key];\n                } else {\n                    tblCur = tblCur[key] = {};\n                }\n            }\n            tblCur.end = true; //最后一个关键字没有分割符\n            tblCur = tblRoot;\n        }\n        return tblRoot;\n    },\n    search: function(content, tblRoot) {\n        \"use strict\";\n        var tblCur,\n            p_star = 0,\n            n = content.length,\n            p_end,\n            match,  //是否找到匹配\n            match_key,\n            match_str,\n            arrMatch = [],  //存储结果\n            arrLength = 0   //arrMatch的长度索引\n            ;\n        while (p_star &#x3C; n) {\n            tblCur = tblRoot; //回溯至根部\n            p_end = p_star;\n            match_str = \"\";\n            match = false;\n            do {\n                match_key = content.charAt(p_end);\n                if (!(tblCur = tblCur[match_key])) { //本次匹配结束\n                    p_star += 1;\n                    break;\n                }else{\n                    match_str += match_key;\n                }\n                p_end += 1;\n                if (tblCur.end === true) //是否匹配到尾部  //找到匹配关键字\n                {\n                    match = true;\n                }\n            } while (true);\n            if (match === true) { //最大匹配\n                arrMatch[arrLength] = { //增强可读性\n                    key: match_str,\n                    begin: p_star - 1,\n                    end: p_end\n                };\n                arrLength += 1;\n                p_star = p_end;\n            }\n        }\n        return arrMatch;\n    }\n};\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>使用实例：\u003c/strong>\u003c/p>\n\u003cpre>\u003ccode class=\"language-javascript\">function test(strContent, strKeys) {\n    var arrMatch,\n        tblRoot = treeSearch.makeTree(strKeys);\n    console.time(\"treeSearch\");\n    arrMatch = treeSearch.search(strContent, tblRoot);\n    console.timeEnd(\"treeSearch\");\n    console.log(arrMatch);\n}\nvar s = (function() {\n    var Things = [' ', '\\n', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    var s = \"\";\n    for (var i = 1000000; i >= 0; i--) {\n        s += Things[parseInt(Math.random() * Things.length) % Things.length]\n    };\n    return s;\n})()\ntest(s, [\"abc\", \"efge\", \"fun\", \"tree\"]);\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>2013/4/18 23:04:35\u003c/strong>\u003c/p>","markdownContent":"\n在博客园上看到[EtherDream](http://www.cnblogs.com/index-html/)的[JavaScript 上万关键字瞬间匹配](http://www.cnblogs.com/index-html/archive/2013/04/17/3025682.html)这篇文章，感觉不错。于是改了DEMO里面的代码（耦合度是在是太高了，几乎得重新一遍才行……）\n\n这种方法的有点就是：树形的结构擅长于同时匹配**多个**关键字。单个关键字来说，直接用indexOf来查询、切割字符串，速度更快。\n\n改动主要在两个方面：\n- 对语句规范化（[JSHint](http://www.jshint.com/)规范）;\n- 改写了一部分语句，核心的语句效率几乎是达到最大，比如 `if(match === true)` 比 `if(match)` 快，另外把得出的匹配结果可读化，这个有点耗资源，不过有它存在的必要性，在后期处理数据时更快。\n\n**核心代码：**\n\n``` javascript\nvar treeSearch = {\n    makeTree: function(strKeys) {\n        \"use strict\";\n        var tblCur = {},\n            tblRoot,\n            key,\n            str_key,\n            Length,\n            j,\n            i\n            ;\n        tblRoot = tblCur;\n        for ( j = strKeys.length - 1; j >= 0; j -= 1) {\n            str_key = strKeys[j];\n            Length = str_key.length;\n            for ( i = 0; i \u003c Length; i += 1) {\n                key = str_key.charAt(i);\n                if (tblCur.hasOwnProperty(key)) { //生成子节点 \n                    tblCur = tblCur[key];\n                } else {\n                    tblCur = tblCur[key] = {};\n                }\n            }\n            tblCur.end = true; //最后一个关键字没有分割符\n            tblCur = tblRoot;\n        }\n        return tblRoot;\n    },\n    search: function(content, tblRoot) {\n        \"use strict\";\n        var tblCur,\n            p_star = 0,\n            n = content.length,\n            p_end,\n            match,  //是否找到匹配\n            match_key,\n            match_str,\n            arrMatch = [],  //存储结果\n            arrLength = 0   //arrMatch的长度索引\n            ;\n        while (p_star \u003c n) {\n            tblCur = tblRoot; //回溯至根部\n            p_end = p_star;\n            match_str = \"\";\n            match = false;\n            do {\n                match_key = content.charAt(p_end);\n                if (!(tblCur = tblCur[match_key])) { //本次匹配结束\n                    p_star += 1;\n                    break;\n                }else{\n                    match_str += match_key;\n                }\n                p_end += 1;\n                if (tblCur.end === true) //是否匹配到尾部  //找到匹配关键字\n                {\n                    match = true;\n                }\n            } while (true);\n            if (match === true) { //最大匹配\n                arrMatch[arrLength] = { //增强可读性\n                    key: match_str,\n                    begin: p_star - 1,\n                    end: p_end\n                };\n                arrLength += 1;\n                p_star = p_end;\n            }\n        }\n        return arrMatch;\n    }\n};\n```\n\n**使用实例：**\n\n``` javascript\nfunction test(strContent, strKeys) {\n    var arrMatch,\n        tblRoot = treeSearch.makeTree(strKeys);\n    console.time(\"treeSearch\");\n    arrMatch = treeSearch.search(strContent, tblRoot);\n    console.timeEnd(\"treeSearch\");\n    console.log(arrMatch);\n}\nvar s = (function() {\n    var Things = [' ', '\\n', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    var s = \"\";\n    for (var i = 1000000; i >= 0; i--) {\n        s += Things[parseInt(Math.random() * Things.length) % Things.length]\n    };\n    return s;\n})()\ntest(s, [\"abc\", \"efge\", \"fun\", \"tree\"]);\n```\n\n**2013/4/18 23:04:35**\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.D4VBVy3c.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.h5JipGsp.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-vy2czm8u.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-0HRAW6Xj.js" as="script" type="text/javascript">
      </body>
    </html>