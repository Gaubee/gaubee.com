{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"Promise.race-can-cause-memory-leaks"},"data":{"article":{"metadata":{"layout":"layouts/article.njk","title":"Promise.race会带来内存泄露","date":"!Date:2020-04-23T01:00:08.000Z","updated":"!Date:2020-04-23T01:02:06.000Z","id":"Promise.race-can-cause-memory-leaks","createdAt":"!Date:2020-04-23T01:00:08.000Z","updatedAt":"!Date:2020-04-23T01:02:06.000Z","tags":[]},"htmlContent":"<p>假若有两个promise: a, b，现在它们都<code>Promise.race([a,b])</code>所包裹。\n此时，如果a先完成了resolve，race也就有了返回值。\n然而，b却迟迟没有被resolve或者reject……\n结果会带来隐式的内存问题，就是a看上去被释放了，但其实没有。\nv8论坛上有类似的bug提交：https://bugs.chromium.org/p/v8/issues/detail?id=9858</p>\n<p>简单地模拟一下实现：</p>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-js\"><span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">function</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> race</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">...</span><span style=\"color:#E36209;--shiki-dark:#FFAB70\">promises</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">  return</span><span style=\"color:#D73A49;--shiki-dark:#F97583\"> new</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\"> Promise</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">((</span><span style=\"color:#E36209;--shiki-dark:#FFAB70\">resolve</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">, </span><span style=\"color:#E36209;--shiki-dark:#FFAB70\">reject</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">)</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=></span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">    for</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">const</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\"> p</span><span style=\"color:#D73A49;--shiki-dark:#F97583\"> of</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> promises){</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">      p.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">then</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(resolve, reject)</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">  })</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">}</span></span></code></pre>\n<p>我实际测试了一下，一些不同版本的v8似乎会有不同的表现，但终归是内存泄漏了，只是好像v12的是直接泄漏了捕捉不到，v13是能在内存堆栈里头看到。\n我在工作的时候发现这个问题也是靠async_hooks的异步资源监控下才看到这个问题的存在。</p>\n<p>解决方案其实也不难，核心问题就是消除引用：</p>\n<ol>\n<li>首先我们需要一个<code>Promise.prototype.safeThen</code>的实现，因为<code>Promise.prototype.then</code>是会返回出一个新的promise的。做法其实就是只使用一次then来代理实现。其返回值就是<code>thened: { resolves: Set&lt;Function&gt;, rejects: Set&lt;Function&gt;, isFinished: boolean }</code></li>\n<li>接着我们基于<code>safeThen</code>来实现<code>Promise.safePromiseRace</code>，重点在于收集thened对象，并主动进行释放：</li>\n</ol>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-text\"><span class=\"line\"><span>function safePromiseRace(...promises){</span></span>\n<span class=\"line\"><span>  return new Promise((resolve, reject)=>{</span></span>\n<span class=\"line\"><span>    const thenedList = []</span></span>\n<span class=\"line\"><span>    const finished = ()=>{</span></span>\n<span class=\"line\"><span>      thenedList.forEach(thened=>{</span></span>\n<span class=\"line\"><span>        thened.resolves.delete(safeResolve);</span></span>\n<span class=\"line\"><span>        thened.rejects.delete(safeReject);</span></span>\n<span class=\"line\"><span>      })</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span>    const safeResolve = (v)=>{resolve(v); finished();}</span></span>\n<span class=\"line\"><span>    const safeReject = (v)=>{reject(v); finished();}</span></span>\n<span class=\"line\"><span>    for(const p of promises){</span></span>\n<span class=\"line\"><span>      thenedList.push(p.safeThen(safeResolve, safeReject))</span></span>\n<span class=\"line\"><span>    }</span></span>\n<span class=\"line\"><span>  })</span></span>\n<span class=\"line\"><span>}</span></span></code></pre>\n","markdownContent":"\n假若有两个promise: a, b，现在它们都`Promise.race([a,b])`所包裹。\n此时，如果a先完成了resolve，race也就有了返回值。\n然而，b却迟迟没有被resolve或者reject……\n结果会带来隐式的内存问题，就是a看上去被释放了，但其实没有。\nv8论坛上有类似的bug提交：https://bugs.chromium.org/p/v8/issues/detail?id=9858\n\n简单地模拟一下实现：\n```js\nfunction race(...promises){\n  return new Promise((resolve, reject)=>{\n    for(const p of promises){\n      p.then(resolve, reject)\n    }\n  })\n}\n```\n\n我实际测试了一下，一些不同版本的v8似乎会有不同的表现，但终归是内存泄漏了，只是好像v12的是直接泄漏了捕捉不到，v13是能在内存堆栈里头看到。\n我在工作的时候发现这个问题也是靠async_hooks的异步资源监控下才看到这个问题的存在。\n\n解决方案其实也不难，核心问题就是消除引用：\n1. 首先我们需要一个`Promise.prototype.safeThen`的实现，因为`Promise.prototype.then`是会返回出一个新的promise的。做法其实就是只使用一次then来代理实现。其返回值就是`thened: { resolves: Set<Function>, rejects: Set<Function>, isFinished: boolean }`\n2. 接着我们基于`safeThen`来实现`Promise.safePromiseRace`，重点在于收集thened对象，并主动进行释放：\n```\nfunction safePromiseRace(...promises){\n  return new Promise((resolve, reject)=>{\n    const thenedList = []\n    const finished = ()=>{\n      thenedList.forEach(thened=>{\n        thened.resolves.delete(safeResolve);\n        thened.rejects.delete(safeReject);\n      })\n    }\n    const safeResolve = (v)=>{resolve(v); finished();}\n    const safeReject = (v)=>{reject(v); finished();}\n    for(const p of promises){\n      thenedList.push(p.safeThen(safeResolve, safeReject))\n    }\n  })\n}\n```\n\n\n"}}}