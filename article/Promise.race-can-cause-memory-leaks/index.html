<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.BzcesyCW.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          p {
            text-indent: "2em";
            line-height: 3;
          }
        </style><h1>Promise.race会带来内存泄露</h1><main><p>假若有两个promise: a, b，现在它们都<code>Promise.race([a,b])</code>所包裹。
此时，如果a先完成了resolve，race也就有了返回值。
然而，b却迟迟没有被resolve或者reject……
结果会带来隐式的内存问题，就是a看上去被释放了，但其实没有。
v8论坛上有类似的bug提交：https://bugs.chromium.org/p/v8/issues/detail?id=9858</p>
<p>简单地模拟一下实现：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8" tabindex="0"><code class="language-js"><span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0"> race</span><span style="color:#24292E;--shiki-dark:#E1E4E8">(</span><span style="color:#D73A49;--shiki-dark:#F97583">...</span><span style="color:#E36209;--shiki-dark:#FFAB70">promises</span><span style="color:#24292E;--shiki-dark:#E1E4E8">){</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">  return</span><span style="color:#D73A49;--shiki-dark:#F97583"> new</span><span style="color:#005CC5;--shiki-dark:#79B8FF"> Promise</span><span style="color:#24292E;--shiki-dark:#E1E4E8">((</span><span style="color:#E36209;--shiki-dark:#FFAB70">resolve</span><span style="color:#24292E;--shiki-dark:#E1E4E8">, </span><span style="color:#E36209;--shiki-dark:#FFAB70">reject</span><span style="color:#24292E;--shiki-dark:#E1E4E8">)</span><span style="color:#D73A49;--shiki-dark:#F97583">=></span><span style="color:#24292E;--shiki-dark:#E1E4E8">{</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">    for</span><span style="color:#24292E;--shiki-dark:#E1E4E8">(</span><span style="color:#D73A49;--shiki-dark:#F97583">const</span><span style="color:#005CC5;--shiki-dark:#79B8FF"> p</span><span style="color:#D73A49;--shiki-dark:#F97583"> of</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> promises){</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8">      p.</span><span style="color:#6F42C1;--shiki-dark:#B392F0">then</span><span style="color:#24292E;--shiki-dark:#E1E4E8">(resolve, reject)</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8">  })</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8">}</span></span></code></pre>
<p>我实际测试了一下，一些不同版本的v8似乎会有不同的表现，但终归是内存泄漏了，只是好像v12的是直接泄漏了捕捉不到，v13是能在内存堆栈里头看到。
我在工作的时候发现这个问题也是靠async_hooks的异步资源监控下才看到这个问题的存在。</p>
<p>解决方案其实也不难，核心问题就是消除引用：</p>
<ol>
<li>首先我们需要一个<code>Promise.prototype.safeThen</code>的实现，因为<code>Promise.prototype.then</code>是会返回出一个新的promise的。做法其实就是只使用一次then来代理实现。其返回值就是<code>thened: { resolves: Set&lt;Function&gt;, rejects: Set&lt;Function&gt;, isFinished: boolean }</code></li>
<li>接着我们基于<code>safeThen</code>来实现<code>Promise.safePromiseRace</code>，重点在于收集thened对象，并主动进行释放：</li>
</ol>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8" tabindex="0"><code class="language-text"><span class="line"><span>function safePromiseRace(...promises){</span></span>
<span class="line"><span>  return new Promise((resolve, reject)=>{</span></span>
<span class="line"><span>    const thenedList = []</span></span>
<span class="line"><span>    const finished = ()=>{</span></span>
<span class="line"><span>      thenedList.forEach(thened=>{</span></span>
<span class="line"><span>        thened.resolves.delete(safeResolve);</span></span>
<span class="line"><span>        thened.rejects.delete(safeReject);</span></span>
<span class="line"><span>      })</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    const safeResolve = (v)=>{resolve(v); finished();}</span></span>
<span class="line"><span>    const safeReject = (v)=>{reject(v); finished();}</span></span>
<span class="line"><span>    for(const p of promises){</span></span>
<span class="line"><span>      thenedList.push(p.safeThen(safeResolve, safeReject))</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  })</span></span>
<span class="line"><span>}</span></span></code></pre>
</main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"Promise.race-can-cause-memory-leaks"},"data":{"article":{"metadata":{"layout":"layouts/article.njk","title":"Promise.race会带来内存泄露","date":"!Date:2020-04-23T01:00:08.000Z","updated":"!Date:2020-04-23T01:02:06.000Z","id":"Promise.race-can-cause-memory-leaks","createdAt":"!Date:2020-04-23T01:00:08.000Z","updatedAt":"!Date:2020-04-23T01:02:06.000Z","tags":[]},"htmlContent":"\u003cp>假若有两个promise: a, b，现在它们都\u003ccode>Promise.race([a,b])\u003c/code>所包裹。\n此时，如果a先完成了resolve，race也就有了返回值。\n然而，b却迟迟没有被resolve或者reject……\n结果会带来隐式的内存问题，就是a看上去被释放了，但其实没有。\nv8论坛上有类似的bug提交：https://bugs.chromium.org/p/v8/issues/detail?id=9858\u003c/p>\n\u003cp>简单地模拟一下实现：\u003c/p>\n\u003cpre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\">\u003ccode class=\"language-js\">\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">function\u003c/span>\u003cspan style=\"color:#6F42C1;--shiki-dark:#B392F0\"> race\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">(\u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">...\u003c/span>\u003cspan style=\"color:#E36209;--shiki-dark:#FFAB70\">promises\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">){\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">  return\u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\"> new\u003c/span>\u003cspan style=\"color:#005CC5;--shiki-dark:#79B8FF\"> Promise\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">((\u003c/span>\u003cspan style=\"color:#E36209;--shiki-dark:#FFAB70\">resolve\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">, \u003c/span>\u003cspan style=\"color:#E36209;--shiki-dark:#FFAB70\">reject\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">)\u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">=>\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">{\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">    for\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">(\u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">const\u003c/span>\u003cspan style=\"color:#005CC5;--shiki-dark:#79B8FF\"> p\u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\"> of\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> promises){\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">      p.\u003c/span>\u003cspan style=\"color:#6F42C1;--shiki-dark:#B392F0\">then\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">(resolve, reject)\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">    }\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">  })\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">}\u003c/span>\u003c/span>\u003c/code>\u003c/pre>\n\u003cp>我实际测试了一下，一些不同版本的v8似乎会有不同的表现，但终归是内存泄漏了，只是好像v12的是直接泄漏了捕捉不到，v13是能在内存堆栈里头看到。\n我在工作的时候发现这个问题也是靠async_hooks的异步资源监控下才看到这个问题的存在。\u003c/p>\n\u003cp>解决方案其实也不难，核心问题就是消除引用：\u003c/p>\n\u003col>\n\u003cli>首先我们需要一个\u003ccode>Promise.prototype.safeThen\u003c/code>的实现，因为\u003ccode>Promise.prototype.then\u003c/code>是会返回出一个新的promise的。做法其实就是只使用一次then来代理实现。其返回值就是\u003ccode>thened: { resolves: Set&lt;Function&gt;, rejects: Set&lt;Function&gt;, isFinished: boolean }\u003c/code>\u003c/li>\n\u003cli>接着我们基于\u003ccode>safeThen\u003c/code>来实现\u003ccode>Promise.safePromiseRace\u003c/code>，重点在于收集thened对象，并主动进行释放：\u003c/li>\n\u003c/ol>\n\u003cpre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\">\u003ccode class=\"language-text\">\u003cspan class=\"line\">\u003cspan>function safePromiseRace(...promises){\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>  return new Promise((resolve, reject)=>{\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>    const thenedList = []\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>    const finished = ()=>{\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>      thenedList.forEach(thened=>{\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>        thened.resolves.delete(safeResolve);\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>        thened.rejects.delete(safeReject);\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>      })\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>    }\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>    const safeResolve = (v)=>{resolve(v); finished();}\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>    const safeReject = (v)=>{reject(v); finished();}\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>    for(const p of promises){\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>      thenedList.push(p.safeThen(safeResolve, safeReject))\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>    }\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>  })\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan>}\u003c/span>\u003c/span>\u003c/code>\u003c/pre>\n","markdownContent":"\n假若有两个promise: a, b，现在它们都`Promise.race([a,b])`所包裹。\n此时，如果a先完成了resolve，race也就有了返回值。\n然而，b却迟迟没有被resolve或者reject……\n结果会带来隐式的内存问题，就是a看上去被释放了，但其实没有。\nv8论坛上有类似的bug提交：https://bugs.chromium.org/p/v8/issues/detail?id=9858\n\n简单地模拟一下实现：\n```js\nfunction race(...promises){\n  return new Promise((resolve, reject)=>{\n    for(const p of promises){\n      p.then(resolve, reject)\n    }\n  })\n}\n```\n\n我实际测试了一下，一些不同版本的v8似乎会有不同的表现，但终归是内存泄漏了，只是好像v12的是直接泄漏了捕捉不到，v13是能在内存堆栈里头看到。\n我在工作的时候发现这个问题也是靠async_hooks的异步资源监控下才看到这个问题的存在。\n\n解决方案其实也不难，核心问题就是消除引用：\n1. 首先我们需要一个`Promise.prototype.safeThen`的实现，因为`Promise.prototype.then`是会返回出一个新的promise的。做法其实就是只使用一次then来代理实现。其返回值就是`thened: { resolves: Set\u003cFunction>, rejects: Set\u003cFunction>, isFinished: boolean }`\n2. 接着我们基于`safeThen`来实现`Promise.safePromiseRace`，重点在于收集thened对象，并主动进行释放：\n```\nfunction safePromiseRace(...promises){\n  return new Promise((resolve, reject)=>{\n    const thenedList = []\n    const finished = ()=>{\n      thenedList.forEach(thened=>{\n        thened.resolves.delete(safeResolve);\n        thened.rejects.delete(safeReject);\n      })\n    }\n    const safeResolve = (v)=>{resolve(v); finished();}\n    const safeReject = (v)=>{reject(v); finished();}\n    for(const p of promises){\n      thenedList.push(p.safeThen(safeResolve, safeReject))\n    }\n  })\n}\n```\n\n\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.BGuB9iqG.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.BCFv3ZOD.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-Z1L0Yy9g.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-DpeCXkLi.js" as="script" type="text/javascript">
      </body>
    </html>