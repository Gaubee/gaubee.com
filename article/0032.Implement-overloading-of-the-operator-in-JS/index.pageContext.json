{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0032.Implement-overloading-of-the-operator-in-JS"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0032.Implement-overloading-of-the-operator-in-JS.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"在JS中实现+=/-=操作符的重载","date":"!Date:2017-10-29T02:36:22.000Z","updated":"!Date:2017-11-09T03:25:43.000Z"},"metadata":{"layout":"layouts/article.njk","title":"在JS中实现+=/-=操作符的重载","date":"!Date:2017-10-29T02:36:22.000Z","updated":"!Date:2017-11-09T03:25:43.000Z","id":"0032.Implement-overloading-of-the-operator-in-JS","createdAt":"!Date:2017-10-29T02:36:22.000Z","updatedAt":"!Date:2017-11-09T03:25:43.000Z","tags":[]},"htmlContent":"<h2>运用场景</h2>\n<p>这是一个语法糖，只是为了简化一些API的写法，比如：</p>\n<pre><code class=\"language-js\">this.list += item // array push\nthis.list -= item // array remove\n</code></pre>\n<pre><code class=\"language-js\">this.on('click').events += cb; // add event\nthis.on('click').events -= cb; // remove event\n</code></pre>\n<h2>如何实现</h2>\n<p>JS原生支持<code>=</code>操作符号的重载，即getter/setter：</p>\n<pre><code class=\"language-js\">const a = {\n  get z(){ return 666; }\n}\n</code></pre>\n<p>而+=操作符号，是针对于string、number这两种类型来做拼接与累加操作的。\n如果只是单纯实现+=，我建议使用string来做实现，因为js对于number类型的操作有一些精度问题，所以还是要小心规避，我没去关注不同浏览器在精度方面的差异。\n但因为要操作-=，这就无法规避number类型了。所以我统一使用number来实现。</p>\n<p>因为+=/-=后面接受的都是一个数字或者能转换成数字的对象，才能避免出现NaN。\n下面我以实现一个PromisePool来作为实现的例子：</p>\n<pre><code class=\"language-js\">class PromisePool extends Array {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\t// 使用小数来作为ID标识\n\t\tObject.defineProperty(this, \"_base\", {\n\t\t\tvalue: 0.4572015816549748\n\t\t});\n\t\t// -= 的时候使用\n\t\tObject.defineProperty(this, \"_base_res\", {\n\t\t\tvalue: 1 - this._base\n\t\t});\n\t}\n\tget pool() {\n\t\treturn this._base;\n\t}\n\tset pool(v) {\n\t\tvar cv = \"0.\" + v.toString().split(\".\")[1];\n\t\t// 从缓存取获取对象\n\t\tconst obj = global.__op_temp__;\n\t\t// console.log(obj)\n\t\tif (cv == this._base) {\n\t\t\t// 使用了+=运算符\n\t\t\tthis.push(obj);\n\t\t} else if (cv == this._base_res) {\n\t\t\t// 使用了-=运算符\n\t\t\tvar index = this.indexOf(obj);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis.splice(index, 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// 忽略，或者抛出异常\n\t\t\tconsole.error(cv, this._base);\n\t\t}\n\t}\n}\npp = new PromisePool();\nglobal.__op_temp__ = { name: \"test\" };\npp.pool += 1;\nconsole.log(pp.length, pp[0]);\nconsole.log(\"-------------\");\npp.pool -= 1;\nconsole.log(pp.length, pp[0]);\n</code></pre>\n<p>这段DEMO的<strong>重点</strong>是：</p>\n<ol>\n<li>使用一个固有小数作为ID标识</li>\n<li>+= -= 只接受自然数，避免和ID冲突</li>\n<li>使用一个全局变量<code>__op_temp__</code>来存储要传入的对象\n输出结果为：</li>\n</ol>\n<pre><code>1 { name: 'test' }\n-------------\n0 undefined\n</code></pre>\n<p>接下来要解决的就是如何把一个非Number对象传入PromisePool里头了，以及如果规避使用<code>__op_temp__</code>带来的内存隐患。\n其实现的核心方法是：在执行+=或者-=算术运算的时候，js引擎会去调用一个对象的valueOf方法，所以我们要重载这个方法。</p>\n<pre><code class=\"language-js\">Object.defineProperty(Promise, \"__OP_VAL__\", { value: 0 });\nPromise.prototype.valueOf = function() {\n\tglobal.__op_temp__ = this;\n\treturn Promise.__OP_VAL__;\n};\n\nvar pitem = Promise.resolve(666);\npp.pool += pitem;\nconsole.log(pp.length, pp[0]);\nconsole.log(\"-------------\");\npp.pool -= pitem;\nconsole.log(pp.length, pp[0]);\n</code></pre>\n<p>以上代码中，我重写了Promise原型链中的valueOf方法，我使用<code>0</code>值来作为返回值，这个返回值不能乱来，我建议就是直接用0，否则会直接引发精度问题。</p>\n<p>这些代码基本就已经实现了我们要的效果了。接下来就是补充内存管理的问题了，就是<code>__op_temp__</code>这个对象一直缓存着最后一个Promise对象，怎么给它释放掉？\n很简单，在我们运行<code>pp.pool+=pitem</code>的时候，这时候的js引擎执行的就是<code>valueOf( set op_temp ) => setter( get op_temp )</code>。也就是说<code>__op_temp__</code>在赋值后，只执行了一次“取值”就没用了。我们可以在这个取值之后直接释放掉引用。</p>\n<pre><code class=\"language-js\">// __op_temp_null_: 说明缓存取中没有东西\nObject.defineProperty(global, \"__op_temp_null_\", {\n\tvalue: Symbol(\"Operators Object NULL\")\n});\nconst op_temp_key = Symbol(\"Operators Object TEMP\");\nObject.defineProperty(global, \"__op_temp__\", {\n\tget() {\n\t\tconst res = this[op_temp_key];\n\t\t// 取值后马上移除引用关系\n\t\tthis[op_temp_key] = global.__op_temp_null_;\n\t\treturn res;\n\t},\n\tset(v) {\n\t\tthis[op_temp_key] = v;\n\t}\n});\n</code></pre>\n<p>如此内存方面的隐患就解决了。</p>\n<hr>\n<p>以上源码位于：<a href=\"https://gist.github.com/Gaubee/91b34fc56f3890bdbad681d4a8f47424\">https://gist.github.com/Gaubee/91b34fc56f3890bdbad681d4a8f47424</a></p>","markdownContent":"\n## 运用场景\n这是一个语法糖，只是为了简化一些API的写法，比如：\n```js\nthis.list += item // array push\nthis.list -= item // array remove\n```\n```js\nthis.on('click').events += cb; // add event\nthis.on('click').events -= cb; // remove event\n```\n## 如何实现\n\nJS原生支持`=`操作符号的重载，即getter/setter：\n```js\nconst a = {\n  get z(){ return 666; }\n}\n```\n而+=操作符号，是针对于string、number这两种类型来做拼接与累加操作的。\n如果只是单纯实现+=，我建议使用string来做实现，因为js对于number类型的操作有一些精度问题，所以还是要小心规避，我没去关注不同浏览器在精度方面的差异。\n但因为要操作-=，这就无法规避number类型了。所以我统一使用number来实现。\n\n因为+=/-=后面接受的都是一个数字或者能转换成数字的对象，才能避免出现NaN。\n下面我以实现一个PromisePool来作为实现的例子：\n```js\nclass PromisePool extends Array {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\t// 使用小数来作为ID标识\n\t\tObject.defineProperty(this, \"_base\", {\n\t\t\tvalue: 0.4572015816549748\n\t\t});\n\t\t// -= 的时候使用\n\t\tObject.defineProperty(this, \"_base_res\", {\n\t\t\tvalue: 1 - this._base\n\t\t});\n\t}\n\tget pool() {\n\t\treturn this._base;\n\t}\n\tset pool(v) {\n\t\tvar cv = \"0.\" + v.toString().split(\".\")[1];\n\t\t// 从缓存取获取对象\n\t\tconst obj = global.__op_temp__;\n\t\t// console.log(obj)\n\t\tif (cv == this._base) {\n\t\t\t// 使用了+=运算符\n\t\t\tthis.push(obj);\n\t\t} else if (cv == this._base_res) {\n\t\t\t// 使用了-=运算符\n\t\t\tvar index = this.indexOf(obj);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis.splice(index, 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// 忽略，或者抛出异常\n\t\t\tconsole.error(cv, this._base);\n\t\t}\n\t}\n}\npp = new PromisePool();\nglobal.__op_temp__ = { name: \"test\" };\npp.pool += 1;\nconsole.log(pp.length, pp[0]);\nconsole.log(\"-------------\");\npp.pool -= 1;\nconsole.log(pp.length, pp[0]);\n```\n这段DEMO的**重点**是：\n1. 使用一个固有小数作为ID标识\n2. += -= 只接受自然数，避免和ID冲突\n3. 使用一个全局变量`__op_temp__`来存储要传入的对象\n输出结果为：\n```\n1 { name: 'test' }\n-------------\n0 undefined\n```\n\n接下来要解决的就是如何把一个非Number对象传入PromisePool里头了，以及如果规避使用`__op_temp__`带来的内存隐患。\n其实现的核心方法是：在执行+=或者-=算术运算的时候，js引擎会去调用一个对象的valueOf方法，所以我们要重载这个方法。\n```js\nObject.defineProperty(Promise, \"__OP_VAL__\", { value: 0 });\nPromise.prototype.valueOf = function() {\n\tglobal.__op_temp__ = this;\n\treturn Promise.__OP_VAL__;\n};\n\nvar pitem = Promise.resolve(666);\npp.pool += pitem;\nconsole.log(pp.length, pp[0]);\nconsole.log(\"-------------\");\npp.pool -= pitem;\nconsole.log(pp.length, pp[0]);\n```\n以上代码中，我重写了Promise原型链中的valueOf方法，我使用`0`值来作为返回值，这个返回值不能乱来，我建议就是直接用0，否则会直接引发精度问题。\n\n这些代码基本就已经实现了我们要的效果了。接下来就是补充内存管理的问题了，就是`__op_temp__`这个对象一直缓存着最后一个Promise对象，怎么给它释放掉？\n很简单，在我们运行`pp.pool+=pitem`的时候，这时候的js引擎执行的就是`valueOf( set op_temp ) => setter( get op_temp )`。也就是说`__op_temp__`在赋值后，只执行了一次“取值”就没用了。我们可以在这个取值之后直接释放掉引用。\n```js\n// __op_temp_null_: 说明缓存取中没有东西\nObject.defineProperty(global, \"__op_temp_null_\", {\n\tvalue: Symbol(\"Operators Object NULL\")\n});\nconst op_temp_key = Symbol(\"Operators Object TEMP\");\nObject.defineProperty(global, \"__op_temp__\", {\n\tget() {\n\t\tconst res = this[op_temp_key];\n\t\t// 取值后马上移除引用关系\n\t\tthis[op_temp_key] = global.__op_temp_null_;\n\t\treturn res;\n\t},\n\tset(v) {\n\t\tthis[op_temp_key] = v;\n\t}\n});\n```\n如此内存方面的隐患就解决了。\n\n--------\n\n以上源码位于：https://gist.github.com/Gaubee/91b34fc56f3890bdbad681d4a8f47424\n"}}}