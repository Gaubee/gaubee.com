<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.B0ujMgz2.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }

          main > p > img {
            max-width: 100%;
            margin: 0 auto;
            display: block;
          }
        </style><h1>在JS中实现+=/-=操作符的重载</h1><main><h2>运用场景</h2>
<p>这是一个语法糖，只是为了简化一些API的写法，比如：</p>
<pre><code class="language-js">this.list += item // array push
this.list -= item // array remove
</code></pre>
<pre><code class="language-js">this.on('click').events += cb; // add event
this.on('click').events -= cb; // remove event
</code></pre>
<h2>如何实现</h2>
<p>JS原生支持<code>=</code>操作符号的重载，即getter/setter：</p>
<pre><code class="language-js">const a = {
  get z(){ return 666; }
}
</code></pre>
<p>而+=操作符号，是针对于string、number这两种类型来做拼接与累加操作的。
如果只是单纯实现+=，我建议使用string来做实现，因为js对于number类型的操作有一些精度问题，所以还是要小心规避，我没去关注不同浏览器在精度方面的差异。
但因为要操作-=，这就无法规避number类型了。所以我统一使用number来实现。</p>
<p>因为+=/-=后面接受的都是一个数字或者能转换成数字的对象，才能避免出现NaN。
下面我以实现一个PromisePool来作为实现的例子：</p>
<pre><code class="language-js">class PromisePool extends Array {
	constructor(...args) {
		super(...args);
		// 使用小数来作为ID标识
		Object.defineProperty(this, "_base", {
			value: 0.4572015816549748
		});
		// -= 的时候使用
		Object.defineProperty(this, "_base_res", {
			value: 1 - this._base
		});
	}
	get pool() {
		return this._base;
	}
	set pool(v) {
		var cv = "0." + v.toString().split(".")[1];
		// 从缓存取获取对象
		const obj = global.__op_temp__;
		// console.log(obj)
		if (cv == this._base) {
			// 使用了+=运算符
			this.push(obj);
		} else if (cv == this._base_res) {
			// 使用了-=运算符
			var index = this.indexOf(obj);
			if (index >= 0) {
				this.splice(index, 1);
			}
		} else {
			// 忽略，或者抛出异常
			console.error(cv, this._base);
		}
	}
}
pp = new PromisePool();
global.__op_temp__ = { name: "test" };
pp.pool += 1;
console.log(pp.length, pp[0]);
console.log("-------------");
pp.pool -= 1;
console.log(pp.length, pp[0]);
</code></pre>
<p>这段DEMO的<strong>重点</strong>是：</p>
<ol>
<li>使用一个固有小数作为ID标识</li>
<li>+= -= 只接受自然数，避免和ID冲突</li>
<li>使用一个全局变量<code>__op_temp__</code>来存储要传入的对象
输出结果为：</li>
</ol>
<pre><code>1 { name: 'test' }
-------------
0 undefined
</code></pre>
<p>接下来要解决的就是如何把一个非Number对象传入PromisePool里头了，以及如果规避使用<code>__op_temp__</code>带来的内存隐患。
其实现的核心方法是：在执行+=或者-=算术运算的时候，js引擎会去调用一个对象的valueOf方法，所以我们要重载这个方法。</p>
<pre><code class="language-js">Object.defineProperty(Promise, "__OP_VAL__", { value: 0 });
Promise.prototype.valueOf = function() {
	global.__op_temp__ = this;
	return Promise.__OP_VAL__;
};

var pitem = Promise.resolve(666);
pp.pool += pitem;
console.log(pp.length, pp[0]);
console.log("-------------");
pp.pool -= pitem;
console.log(pp.length, pp[0]);
</code></pre>
<p>以上代码中，我重写了Promise原型链中的valueOf方法，我使用<code>0</code>值来作为返回值，这个返回值不能乱来，我建议就是直接用0，否则会直接引发精度问题。</p>
<p>这些代码基本就已经实现了我们要的效果了。接下来就是补充内存管理的问题了，就是<code>__op_temp__</code>这个对象一直缓存着最后一个Promise对象，怎么给它释放掉？
很简单，在我们运行<code>pp.pool+=pitem</code>的时候，这时候的js引擎执行的就是<code>valueOf( set op_temp ) => setter( get op_temp )</code>。也就是说<code>__op_temp__</code>在赋值后，只执行了一次“取值”就没用了。我们可以在这个取值之后直接释放掉引用。</p>
<pre><code class="language-js">// __op_temp_null_: 说明缓存取中没有东西
Object.defineProperty(global, "__op_temp_null_", {
	value: Symbol("Operators Object NULL")
});
const op_temp_key = Symbol("Operators Object TEMP");
Object.defineProperty(global, "__op_temp__", {
	get() {
		const res = this[op_temp_key];
		// 取值后马上移除引用关系
		this[op_temp_key] = global.__op_temp_null_;
		return res;
	},
	set(v) {
		this[op_temp_key] = v;
	}
});
</code></pre>
<p>如此内存方面的隐患就解决了。</p>
<hr>
<p>以上源码位于：<a href="https://gist.github.com/Gaubee/91b34fc56f3890bdbad681d4a8f47424">https://gist.github.com/Gaubee/91b34fc56f3890bdbad681d4a8f47424</a></p></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0032.Implement-overloading-of-the-operator-in-JS"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0032.Implement-overloading-of-the-operator-in-JS.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"在JS中实现+=/-=操作符的重载","date":"!Date:2017-10-29T02:36:22.000Z","updated":"!Date:2017-11-09T03:25:43.000Z"},"metadata":{"layout":"layouts/article.njk","title":"在JS中实现+=/-=操作符的重载","date":"!Date:2017-10-29T02:36:22.000Z","updated":"!Date:2017-11-09T03:25:43.000Z","id":"0032.Implement-overloading-of-the-operator-in-JS","createdAt":"!Date:2017-10-29T02:36:22.000Z","updatedAt":"!Date:2017-11-09T03:25:43.000Z","tags":[]},"htmlContent":"\u003ch2>运用场景\u003c/h2>\n\u003cp>这是一个语法糖，只是为了简化一些API的写法，比如：\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">this.list += item // array push\nthis.list -= item // array remove\n\u003c/code>\u003c/pre>\n\u003cpre>\u003ccode class=\"language-js\">this.on('click').events += cb; // add event\nthis.on('click').events -= cb; // remove event\n\u003c/code>\u003c/pre>\n\u003ch2>如何实现\u003c/h2>\n\u003cp>JS原生支持\u003ccode>=\u003c/code>操作符号的重载，即getter/setter：\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">const a = {\n  get z(){ return 666; }\n}\n\u003c/code>\u003c/pre>\n\u003cp>而+=操作符号，是针对于string、number这两种类型来做拼接与累加操作的。\n如果只是单纯实现+=，我建议使用string来做实现，因为js对于number类型的操作有一些精度问题，所以还是要小心规避，我没去关注不同浏览器在精度方面的差异。\n但因为要操作-=，这就无法规避number类型了。所以我统一使用number来实现。\u003c/p>\n\u003cp>因为+=/-=后面接受的都是一个数字或者能转换成数字的对象，才能避免出现NaN。\n下面我以实现一个PromisePool来作为实现的例子：\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">class PromisePool extends Array {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\t// 使用小数来作为ID标识\n\t\tObject.defineProperty(this, \"_base\", {\n\t\t\tvalue: 0.4572015816549748\n\t\t});\n\t\t// -= 的时候使用\n\t\tObject.defineProperty(this, \"_base_res\", {\n\t\t\tvalue: 1 - this._base\n\t\t});\n\t}\n\tget pool() {\n\t\treturn this._base;\n\t}\n\tset pool(v) {\n\t\tvar cv = \"0.\" + v.toString().split(\".\")[1];\n\t\t// 从缓存取获取对象\n\t\tconst obj = global.__op_temp__;\n\t\t// console.log(obj)\n\t\tif (cv == this._base) {\n\t\t\t// 使用了+=运算符\n\t\t\tthis.push(obj);\n\t\t} else if (cv == this._base_res) {\n\t\t\t// 使用了-=运算符\n\t\t\tvar index = this.indexOf(obj);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis.splice(index, 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// 忽略，或者抛出异常\n\t\t\tconsole.error(cv, this._base);\n\t\t}\n\t}\n}\npp = new PromisePool();\nglobal.__op_temp__ = { name: \"test\" };\npp.pool += 1;\nconsole.log(pp.length, pp[0]);\nconsole.log(\"-------------\");\npp.pool -= 1;\nconsole.log(pp.length, pp[0]);\n\u003c/code>\u003c/pre>\n\u003cp>这段DEMO的\u003cstrong>重点\u003c/strong>是：\u003c/p>\n\u003col>\n\u003cli>使用一个固有小数作为ID标识\u003c/li>\n\u003cli>+= -= 只接受自然数，避免和ID冲突\u003c/li>\n\u003cli>使用一个全局变量\u003ccode>__op_temp__\u003c/code>来存储要传入的对象\n输出结果为：\u003c/li>\n\u003c/ol>\n\u003cpre>\u003ccode>1 { name: 'test' }\n-------------\n0 undefined\n\u003c/code>\u003c/pre>\n\u003cp>接下来要解决的就是如何把一个非Number对象传入PromisePool里头了，以及如果规避使用\u003ccode>__op_temp__\u003c/code>带来的内存隐患。\n其实现的核心方法是：在执行+=或者-=算术运算的时候，js引擎会去调用一个对象的valueOf方法，所以我们要重载这个方法。\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">Object.defineProperty(Promise, \"__OP_VAL__\", { value: 0 });\nPromise.prototype.valueOf = function() {\n\tglobal.__op_temp__ = this;\n\treturn Promise.__OP_VAL__;\n};\n\nvar pitem = Promise.resolve(666);\npp.pool += pitem;\nconsole.log(pp.length, pp[0]);\nconsole.log(\"-------------\");\npp.pool -= pitem;\nconsole.log(pp.length, pp[0]);\n\u003c/code>\u003c/pre>\n\u003cp>以上代码中，我重写了Promise原型链中的valueOf方法，我使用\u003ccode>0\u003c/code>值来作为返回值，这个返回值不能乱来，我建议就是直接用0，否则会直接引发精度问题。\u003c/p>\n\u003cp>这些代码基本就已经实现了我们要的效果了。接下来就是补充内存管理的问题了，就是\u003ccode>__op_temp__\u003c/code>这个对象一直缓存着最后一个Promise对象，怎么给它释放掉？\n很简单，在我们运行\u003ccode>pp.pool+=pitem\u003c/code>的时候，这时候的js引擎执行的就是\u003ccode>valueOf( set op_temp ) => setter( get op_temp )\u003c/code>。也就是说\u003ccode>__op_temp__\u003c/code>在赋值后，只执行了一次“取值”就没用了。我们可以在这个取值之后直接释放掉引用。\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">// __op_temp_null_: 说明缓存取中没有东西\nObject.defineProperty(global, \"__op_temp_null_\", {\n\tvalue: Symbol(\"Operators Object NULL\")\n});\nconst op_temp_key = Symbol(\"Operators Object TEMP\");\nObject.defineProperty(global, \"__op_temp__\", {\n\tget() {\n\t\tconst res = this[op_temp_key];\n\t\t// 取值后马上移除引用关系\n\t\tthis[op_temp_key] = global.__op_temp_null_;\n\t\treturn res;\n\t},\n\tset(v) {\n\t\tthis[op_temp_key] = v;\n\t}\n});\n\u003c/code>\u003c/pre>\n\u003cp>如此内存方面的隐患就解决了。\u003c/p>\n\u003chr>\n\u003cp>以上源码位于：\u003ca href=\"https://gist.github.com/Gaubee/91b34fc56f3890bdbad681d4a8f47424\">https://gist.github.com/Gaubee/91b34fc56f3890bdbad681d4a8f47424\u003c/a>\u003c/p>","markdownContent":"\n## 运用场景\n这是一个语法糖，只是为了简化一些API的写法，比如：\n```js\nthis.list += item // array push\nthis.list -= item // array remove\n```\n```js\nthis.on('click').events += cb; // add event\nthis.on('click').events -= cb; // remove event\n```\n## 如何实现\n\nJS原生支持`=`操作符号的重载，即getter/setter：\n```js\nconst a = {\n  get z(){ return 666; }\n}\n```\n而+=操作符号，是针对于string、number这两种类型来做拼接与累加操作的。\n如果只是单纯实现+=，我建议使用string来做实现，因为js对于number类型的操作有一些精度问题，所以还是要小心规避，我没去关注不同浏览器在精度方面的差异。\n但因为要操作-=，这就无法规避number类型了。所以我统一使用number来实现。\n\n因为+=/-=后面接受的都是一个数字或者能转换成数字的对象，才能避免出现NaN。\n下面我以实现一个PromisePool来作为实现的例子：\n```js\nclass PromisePool extends Array {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\t// 使用小数来作为ID标识\n\t\tObject.defineProperty(this, \"_base\", {\n\t\t\tvalue: 0.4572015816549748\n\t\t});\n\t\t// -= 的时候使用\n\t\tObject.defineProperty(this, \"_base_res\", {\n\t\t\tvalue: 1 - this._base\n\t\t});\n\t}\n\tget pool() {\n\t\treturn this._base;\n\t}\n\tset pool(v) {\n\t\tvar cv = \"0.\" + v.toString().split(\".\")[1];\n\t\t// 从缓存取获取对象\n\t\tconst obj = global.__op_temp__;\n\t\t// console.log(obj)\n\t\tif (cv == this._base) {\n\t\t\t// 使用了+=运算符\n\t\t\tthis.push(obj);\n\t\t} else if (cv == this._base_res) {\n\t\t\t// 使用了-=运算符\n\t\t\tvar index = this.indexOf(obj);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis.splice(index, 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// 忽略，或者抛出异常\n\t\t\tconsole.error(cv, this._base);\n\t\t}\n\t}\n}\npp = new PromisePool();\nglobal.__op_temp__ = { name: \"test\" };\npp.pool += 1;\nconsole.log(pp.length, pp[0]);\nconsole.log(\"-------------\");\npp.pool -= 1;\nconsole.log(pp.length, pp[0]);\n```\n这段DEMO的**重点**是：\n1. 使用一个固有小数作为ID标识\n2. += -= 只接受自然数，避免和ID冲突\n3. 使用一个全局变量`__op_temp__`来存储要传入的对象\n输出结果为：\n```\n1 { name: 'test' }\n-------------\n0 undefined\n```\n\n接下来要解决的就是如何把一个非Number对象传入PromisePool里头了，以及如果规避使用`__op_temp__`带来的内存隐患。\n其实现的核心方法是：在执行+=或者-=算术运算的时候，js引擎会去调用一个对象的valueOf方法，所以我们要重载这个方法。\n```js\nObject.defineProperty(Promise, \"__OP_VAL__\", { value: 0 });\nPromise.prototype.valueOf = function() {\n\tglobal.__op_temp__ = this;\n\treturn Promise.__OP_VAL__;\n};\n\nvar pitem = Promise.resolve(666);\npp.pool += pitem;\nconsole.log(pp.length, pp[0]);\nconsole.log(\"-------------\");\npp.pool -= pitem;\nconsole.log(pp.length, pp[0]);\n```\n以上代码中，我重写了Promise原型链中的valueOf方法，我使用`0`值来作为返回值，这个返回值不能乱来，我建议就是直接用0，否则会直接引发精度问题。\n\n这些代码基本就已经实现了我们要的效果了。接下来就是补充内存管理的问题了，就是`__op_temp__`这个对象一直缓存着最后一个Promise对象，怎么给它释放掉？\n很简单，在我们运行`pp.pool+=pitem`的时候，这时候的js引擎执行的就是`valueOf( set op_temp ) => setter( get op_temp )`。也就是说`__op_temp__`在赋值后，只执行了一次“取值”就没用了。我们可以在这个取值之后直接释放掉引用。\n```js\n// __op_temp_null_: 说明缓存取中没有东西\nObject.defineProperty(global, \"__op_temp_null_\", {\n\tvalue: Symbol(\"Operators Object NULL\")\n});\nconst op_temp_key = Symbol(\"Operators Object TEMP\");\nObject.defineProperty(global, \"__op_temp__\", {\n\tget() {\n\t\tconst res = this[op_temp_key];\n\t\t// 取值后马上移除引用关系\n\t\tthis[op_temp_key] = global.__op_temp_null_;\n\t\treturn res;\n\t},\n\tset(v) {\n\t\tthis[op_temp_key] = v;\n\t}\n});\n```\n如此内存方面的隐患就解决了。\n\n--------\n\n以上源码位于：https://gist.github.com/Gaubee/91b34fc56f3890bdbad681d4a8f47424\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.XrIATmm0.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.IQG_6ZON.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-vy2czm8u.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-0HRAW6Xj.js" as="script" type="text/javascript">
      </body>
    </html>