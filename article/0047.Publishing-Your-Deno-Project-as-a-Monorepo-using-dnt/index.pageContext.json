{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0047.Publishing-Your-Deno-Project-as-a-Monorepo-using-dnt"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0047.Publishing-Your-Deno-Project-as-a-Monorepo-using-dnt.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"Publishing Your Deno Project as a Monorepo using dnt","date":"!Date:2024-04-27T04:40:46.724Z","updated":"!Date:2024-04-27T04:40:46.724Z"},"metadata":{"layout":"layouts/article.njk","title":"Publishing Your Deno Project as a Monorepo using dnt","date":"!Date:2024-04-27T04:40:46.724Z","updated":"!Date:2024-04-27T04:40:46.724Z","id":"0047.Publishing-Your-Deno-Project-as-a-Monorepo-using-dnt","createdAt":"!Date:2024-04-27T04:40:46.724Z","updatedAt":"!Date:2024-04-27T04:40:46.724Z","tags":[]},"htmlContent":"<h2>Publishing Your Deno Project as a Monorepo using dnt</h2>\n<blockquote>\n<p>Before providing theoretical guidance, let's look at how to achieve this in practice. After completion, I will explain the advantages of this project management solution.</p>\n</blockquote>\n<h3>Tools</h3>\n<ol>\n<li><a href=\"https://deno.com/\">deno</a></li>\n<li><a href=\"https://pnpm.io/installation\">pnpm</a></li>\n</ol>\n<h3>Preparation</h3>\n<ol>\n<li>\n<p>Create your project:</p>\n<pre><code class=\"language-shell\">deno init dnt-mono\n# cd dnt-mono\n# code . # open in ide\n</code></pre>\n</li>\n<li>\n<p>Initialize a git repository</p>\n<pre><code class=\"language-shell\">git init\necho \"npm\\nnode_modules\" > .gitignore # ignore the npm folder\n</code></pre>\n</li>\n<li>\n<p>Initialize package.json, and other files typically required by npm/pnpm</p>\n<pre><code class=\"language-shell\">npm init --yes --private # create a package.json file\necho \"MIT\" > LICENSE\necho \"# Hello Dnt ❤️ Monorepo\" > README.md\necho \"packages:\\n  - \\\"npm/*\\\"\" > pnpm-workspace.yaml\n</code></pre>\n</li>\n<li>\n<p>Prepare the dnt script</p>\n<pre><code class=\"language-shell\">deno add @deno/dnt\n</code></pre>\n<p>Refer to <a href=\"https://github.com/denoland/dnt?tab=readme-ov-file#setup\">Setup</a>, as we need to build multiple npm packages, create the <code>scripts/npmBuilder.ts</code> file:</p>\n<pre><code class=\"language-ts\">import { build, BuildOptions, emptyDir } from \"@deno/dnt\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\n\nconst rootDir = import.meta.resolve(\"../\");\nconst rootResolve = (path: string) => fileURLToPath(new URL(path, rootDir));\nexport const npmBuilder = async (config: {\n  packageDir: string;\n  version?: string;\n  importMap?: string;\n  options?: Partial&#x3C;BuildOptions>;\n}) => {\n  const { packageDir, version, importMap, options } = config;\n  const packageResolve = (path: string) =>\n    fileURLToPath(new URL(path, packageDir));\n  const packageJson = JSON.parse(\n    fs.readFileSync(packageResolve(\"./package.json\"), \"utf-8\")\n  );\n  // remove some field which dnt will create. if you known how dnt work, you can keep them.\n  delete packageJson.main;\n  delete packageJson.module;\n  delete packageJson.exports;\n\n  console.log(`\\nstart dnt: ${packageJson.name}`);\n\n  const npmDir = rootResolve(`./npm/${packageJson.name.split(\"/\").pop()}`);\n  const npmResolve = (p: string) => path.resolve(npmDir, p);\n\n  await emptyDir(npmDir);\n\n  if (version) {\n    Object.assign(packageJson, { version: version });\n  }\n\n  await build({\n    entryPoints: [{ name: \".\", path: packageResolve(\"./index.ts\") }],\n    outDir: npmDir,\n    packageManager: \"pnpm\",\n    shims: {\n      deno: true,\n    },\n    // you should open it in actual\n    test: false,\n    importMap: importMap,\n    package: packageJson,\n    // custom by yourself\n    compilerOptions: {\n      lib: [\"DOM\", \"ES2022\"],\n      target: \"ES2022\",\n      emitDecoratorMetadata: true,\n    },\n    postBuild() {\n      // steps to run after building and before running the tests\n      Deno.copyFileSync(rootResolve(\"./LICENSE\"), npmResolve(\"./LICENSE\"));\n      Deno.copyFileSync(\n        packageResolve(\"./README.md\"),\n        npmResolve(\"./README.md\")\n      );\n    },\n    ...options,\n  });\n};\n</code></pre>\n</li>\n</ol>\n<h3>Main Steps</h3>\n<ol>\n<li>\n<p>Create two subfolders and add some project files</p>\n<pre><code class=\"language-shell\"># start from root\nmkdir packages/module-a\ncd packages/module-a\necho \"export const a = 1;\" > index.ts\necho \"# @dnt-mono/module-a\" > README.md\nnpm init --scope @dnt-mono --yes # name: @dnt-mono/module-a\n</code></pre>\n<p>Repeat the steps to create a <code>module-b</code> folder</p>\n<pre><code class=\"language-shell\"># start from root\nmkdir packages/module-b\ncd packages/module-b\necho \"import { a } from \\\"@dnt-mono/module-a\\\";\\nexport const b = a + 1;\" > index.ts\necho \"# @dnt-mono/module-b\" > README.md\nnpm init --scope @dnt-mono --yes # name: @dnt-mono/module-b\n\npnpm add @dnt-mono/module-a --workspace # add module-a as a dependency\n</code></pre>\n</li>\n<li>\n<p>In this example, <code>module-b</code> depends on <code>module-a</code>, and we used the specifier <code>@dnt-mono/module-a</code> in the code, so we need some configurations to make the deno language server work correctly. In the <code>imports</code> field of <code>deno.json</code>, add these configurations:</p>\n<pre><code class=\"language-jsonc\"> \"@dnt-mono/module-a\": \"./packages/module-a/index.ts\", // in imports\n \"@dnt-mono/module-b\": \"./packages/module-b/index.ts\" // in imports\n</code></pre>\n</li>\n<li>\n<p>Next, create the build script and configuration files</p>\n<ol>\n<li>\n<p><code>scripts/build_npm.ts</code></p>\n<pre><code class=\"language-ts\">import { npmBuilder } from \"./npmBuilder.ts\";\n\nconst version = Deno.args[0];\nawait npmBuilder({\n  packageDir: import.meta.resolve(\"../packages/module-a/\"),\n  importMap: import.meta.resolve(\"./import_map.npm.json\"),\n  version,\n});\nawait npmBuilder({\n  packageDir: import.meta.resolve(\"../packages/module-b/\"),\n  importMap: import.meta.resolve(\"./import_map.npm.json\"),\n  version,\n});\n</code></pre>\n</li>\n<li>\n<p><code>scripts/import_map.npm.json</code></p>\n<pre><code class=\"language-json\">{\n  \"imports\": {\n    \"@dnt-mono/module-a\": \"npm:@dnt-mono/module-a\",\n    \"@dnt-mono/module-b\": \"npm:@dnt-mono/module-b\"\n  }\n}\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>Then, in your <code>deno.json</code>, configure the build command:</p>\n<pre><code class=\"language-jsonc\">\"build\": \"deno run -A ./scripts/build_npm.ts\" // in tasks\n</code></pre>\n</li>\n<li>\n<p>Finally, try executing the build command to create the npm directory</p>\n<pre><code class=\"language-shell\">deno task build\n</code></pre>\n<p>Now, you should see the npm directory has been populated with the module-a and module-b folders ready for npm publishing.\nYou can try to publish these npm packages:</p>\n<pre><code class=\"language-shell\">pnpm publish -r --no-git-checks --dry-run # you should remove --dry-run for an actual run\n</code></pre>\n</li>\n</ol>\n<h3>How It Works</h3>\n<ol>\n<li>We use deno as the language server, which is quite powerful, vastly improved from tsc itself through customized development.</li>\n<li>So here, the package.json is just a \"template file\" and not a configuration file. The only configuration file that goes into effect during development is deno.json.</li>\n<li>Hence, pnpm is just a tool for the final output built by dnt, meaning it only serves the <code>npm/*</code> directory. This is also why <code>pnpm-workspaces.yaml</code> is configured as it is.</li>\n<li>The <code>import_map.npm.json</code> used in dnt is essential. We can't use <code>deno.json</code> directly as <code>importMap</code> because <code>deno.json</code> is configured for the deno language server, while <code>import_map.npm.json</code> is for dnt/pnpm use. In complex projects, it's advisable to manage it automatically with a script.</li>\n</ol>\n<h3>Advanced Tips</h3>\n<p>In deno development, our philosophy is file-oriented rather than module-oriented. Therefore, if needed, you may want to add this kind of configuration in <code>deno.json</code>:</p>\n<pre><code class=\"language-jsonc\">{\n  // ...\n  \"imports\": {\n    // ...\n    \"@dnt-mono/module-a\": \"./packages/module-a/index.ts\",\n    \"@dnt-mono/module-a/\": \"./packages/module-a/src/\",\n    \"@dnt-mono/module-b\": \"./packages/module-b/index.ts\",\n    \"@dnt-mono/module-b/\": \"./packages/module-b/src/\"\n    // ...\n  }\n}\n</code></pre>\n<p>I prefer to put files other than <code>index.ts</code> into a <code>src</code> directory, which aligns more with the style of node projects.</p>\n<blockquote>\n<p>However, remember not to move the <code>index.ts</code> file to the <code>src</code> directory as well, as it could cause exceptions <a href=\"https://github.com/denoland/dnt/issues/249\">#249</a>.</p>\n</blockquote>\n<p>Then, it's about the dnt configuration, where you need to iterate over all your files and configure them in the entryPoints:</p>\n<pre><code class=\"language-ts\">build({\n  entryPoints: [\n    // default entry\n    { name: \".\", path: packageResolve(\"./index.ts\") },\n    // src files\n    ALL_SRC_TS_FILES.map((name) => ({\n      name: `./${name}`,\n      path: `./src/${name}`,\n    })),\n  ],\n  // ...\n});\n</code></pre>\n<p>Now, you can write code like this:</p>\n<pre><code class=\"language-ts\">import { xxx } from \"@dnt-mono/module-a/xxx.ts\";\n</code></pre>\n<h3>Points to Note</h3>\n<ol>\n<li>Plan your project structure well to avoid cyclic dependencies. If needed, you should configure peerDependencies yourself.</li>\n<li>Don't self-import within a module.\n<blockquote>\n<p>The language server doesn't understand that you intend to publish to npm, so even if deno works correctly, your goal is to make it work with node as well.</p>\n</blockquote>\n<pre><code class=\"language-ts\">import { a } from \"@dnt-mono/module-a\"; // don't import module-a in module-a\n</code></pre>\nIt is advisable to write lint rules to avoid these mistakes in actual projects.</li>\n</ol>","markdownContent":"\n## Publishing Your Deno Project as a Monorepo using dnt\n\n> Before providing theoretical guidance, let's look at how to achieve this in practice. After completion, I will explain the advantages of this project management solution.\n\n### Tools\n\n1. [deno](https://deno.com/)\n2. [pnpm](https://pnpm.io/installation)\n\n### Preparation\n\n1. Create your project:\n   ```shell\n   deno init dnt-mono\n   # cd dnt-mono\n   # code . # open in ide\n   ```\n2. Initialize a git repository\n   ```shell\n   git init\n   echo \"npm\\nnode_modules\" > .gitignore # ignore the npm folder\n   ```\n3. Initialize package.json, and other files typically required by npm/pnpm\n   ```shell\n   npm init --yes --private # create a package.json file\n   echo \"MIT\" > LICENSE\n   echo \"# Hello Dnt ❤️ Monorepo\" > README.md\n   echo \"packages:\\n  - \\\"npm/*\\\"\" > pnpm-workspace.yaml\n   ```\n4. Prepare the dnt script\n\n   ```shell\n   deno add @deno/dnt\n   ```\n\n   Refer to [Setup](https://github.com/denoland/dnt?tab=readme-ov-file#setup), as we need to build multiple npm packages, create the `scripts/npmBuilder.ts` file:\n\n   ```ts\n   import { build, BuildOptions, emptyDir } from \"@deno/dnt\";\n   import fs from \"node:fs\";\n   import path from \"node:path\";\n   import { fileURLToPath } from \"node:url\";\n\n   const rootDir = import.meta.resolve(\"../\");\n   const rootResolve = (path: string) => fileURLToPath(new URL(path, rootDir));\n   export const npmBuilder = async (config: {\n     packageDir: string;\n     version?: string;\n     importMap?: string;\n     options?: Partial<BuildOptions>;\n   }) => {\n     const { packageDir, version, importMap, options } = config;\n     const packageResolve = (path: string) =>\n       fileURLToPath(new URL(path, packageDir));\n     const packageJson = JSON.parse(\n       fs.readFileSync(packageResolve(\"./package.json\"), \"utf-8\")\n     );\n     // remove some field which dnt will create. if you known how dnt work, you can keep them.\n     delete packageJson.main;\n     delete packageJson.module;\n     delete packageJson.exports;\n\n     console.log(`\\nstart dnt: ${packageJson.name}`);\n\n     const npmDir = rootResolve(`./npm/${packageJson.name.split(\"/\").pop()}`);\n     const npmResolve = (p: string) => path.resolve(npmDir, p);\n\n     await emptyDir(npmDir);\n\n     if (version) {\n       Object.assign(packageJson, { version: version });\n     }\n\n     await build({\n       entryPoints: [{ name: \".\", path: packageResolve(\"./index.ts\") }],\n       outDir: npmDir,\n       packageManager: \"pnpm\",\n       shims: {\n         deno: true,\n       },\n       // you should open it in actual\n       test: false,\n       importMap: importMap,\n       package: packageJson,\n       // custom by yourself\n       compilerOptions: {\n         lib: [\"DOM\", \"ES2022\"],\n         target: \"ES2022\",\n         emitDecoratorMetadata: true,\n       },\n       postBuild() {\n         // steps to run after building and before running the tests\n         Deno.copyFileSync(rootResolve(\"./LICENSE\"), npmResolve(\"./LICENSE\"));\n         Deno.copyFileSync(\n           packageResolve(\"./README.md\"),\n           npmResolve(\"./README.md\")\n         );\n       },\n       ...options,\n     });\n   };\n   ```\n\n### Main Steps\n\n1. Create two subfolders and add some project files\n\n   ```shell\n   # start from root\n   mkdir packages/module-a\n   cd packages/module-a\n   echo \"export const a = 1;\" > index.ts\n   echo \"# @dnt-mono/module-a\" > README.md\n   npm init --scope @dnt-mono --yes # name: @dnt-mono/module-a\n   ```\n\n   Repeat the steps to create a `module-b` folder\n\n   ```shell\n   # start from root\n   mkdir packages/module-b\n   cd packages/module-b\n   echo \"import { a } from \\\"@dnt-mono/module-a\\\";\\nexport const b = a + 1;\" > index.ts\n   echo \"# @dnt-mono/module-b\" > README.md\n   npm init --scope @dnt-mono --yes # name: @dnt-mono/module-b\n\n   pnpm add @dnt-mono/module-a --workspace # add module-a as a dependency\n   ```\n\n2. In this example, `module-b` depends on `module-a`, and we used the specifier `@dnt-mono/module-a` in the code, so we need some configurations to make the deno language server work correctly. In the `imports` field of `deno.json`, add these configurations:\n\n   ```jsonc\n    \"@dnt-mono/module-a\": \"./packages/module-a/index.ts\", // in imports\n    \"@dnt-mono/module-b\": \"./packages/module-b/index.ts\" // in imports\n   ```\n\n3. Next, create the build script and configuration files\n\n   1. `scripts/build_npm.ts`\n\n      ```ts\n      import { npmBuilder } from \"./npmBuilder.ts\";\n\n      const version = Deno.args[0];\n      await npmBuilder({\n        packageDir: import.meta.resolve(\"../packages/module-a/\"),\n        importMap: import.meta.resolve(\"./import_map.npm.json\"),\n        version,\n      });\n      await npmBuilder({\n        packageDir: import.meta.resolve(\"../packages/module-b/\"),\n        importMap: import.meta.resolve(\"./import_map.npm.json\"),\n        version,\n      });\n      ```\n\n   2. `scripts/import_map.npm.json`\n\n      ```json\n      {\n        \"imports\": {\n          \"@dnt-mono/module-a\": \"npm:@dnt-mono/module-a\",\n          \"@dnt-mono/module-b\": \"npm:@dnt-mono/module-b\"\n        }\n      }\n      ```\n\n4. Then, in your `deno.json`, configure the build command:\n\n   ```jsonc\n   \"build\": \"deno run -A ./scripts/build_npm.ts\" // in tasks\n   ```\n\n5. Finally, try executing the build command to create the npm directory\n   ```shell\n   deno task build\n   ```\n   Now, you should see the npm directory has been populated with the module-a and module-b folders ready for npm publishing.\n   You can try to publish these npm packages:\n   ```shell\n   pnpm publish -r --no-git-checks --dry-run # you should remove --dry-run for an actual run\n   ```\n\n### How It Works\n\n1. We use deno as the language server, which is quite powerful, vastly improved from tsc itself through customized development.\n2. So here, the package.json is just a \"template file\" and not a configuration file. The only configuration file that goes into effect during development is deno.json.\n3. Hence, pnpm is just a tool for the final output built by dnt, meaning it only serves the `npm/*` directory. This is also why `pnpm-workspaces.yaml` is configured as it is.\n4. The `import_map.npm.json` used in dnt is essential. We can't use `deno.json` directly as `importMap` because `deno.json` is configured for the deno language server, while `import_map.npm.json` is for dnt/pnpm use. In complex projects, it's advisable to manage it automatically with a script.\n\n### Advanced Tips\n\nIn deno development, our philosophy is file-oriented rather than module-oriented. Therefore, if needed, you may want to add this kind of configuration in `deno.json`:\n\n```jsonc\n{\n  // ...\n  \"imports\": {\n    // ...\n    \"@dnt-mono/module-a\": \"./packages/module-a/index.ts\",\n    \"@dnt-mono/module-a/\": \"./packages/module-a/src/\",\n    \"@dnt-mono/module-b\": \"./packages/module-b/index.ts\",\n    \"@dnt-mono/module-b/\": \"./packages/module-b/src/\"\n    // ...\n  }\n}\n```\n\nI prefer to put files other than `index.ts` into a `src` directory, which aligns more with the style of node projects.\n\n> However, remember not to move the `index.ts` file to the `src` directory as well, as it could cause exceptions [#249](https://github.com/denoland/dnt/issues/249).\n\nThen, it's about the dnt configuration, where you need to iterate over all your files and configure them in the entryPoints:\n\n```ts\nbuild({\n  entryPoints: [\n    // default entry\n    { name: \".\", path: packageResolve(\"./index.ts\") },\n    // src files\n    ALL_SRC_TS_FILES.map((name) => ({\n      name: `./${name}`,\n      path: `./src/${name}`,\n    })),\n  ],\n  // ...\n});\n```\n\nNow, you can write code like this:\n\n```ts\nimport { xxx } from \"@dnt-mono/module-a/xxx.ts\";\n```\n\n### Points to Note\n\n1. Plan your project structure well to avoid cyclic dependencies. If needed, you should configure peerDependencies yourself.\n2. Don't self-import within a module.\n   > The language server doesn't understand that you intend to publish to npm, so even if deno works correctly, your goal is to make it work with node as well.\n   ```ts\n   import { a } from \"@dnt-mono/module-a\"; // don't import module-a in module-a\n   ```\n   It is advisable to write lint rules to avoid these mistakes in actual projects.\n"}}}