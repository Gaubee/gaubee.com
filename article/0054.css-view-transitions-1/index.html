<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.B0ujMgz2.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }

          main > p > img {
            max-width: 100%;
            margin: 0 auto;
            display: block;
          }
        </style><h1>View Transitions API (Level-1 single-document)</h1><main><p>今天咱们来聊一个前端圈儿里越来越火的新玩意儿——CSS View Transitions。这东西就好比给你的网页换场加了个丝滑的电影转场特效，告别过去那种生硬的“啪嗒”一下切换页面的体验。</p>
<p>W3C 的大佬们捣鼓出的这个 <a href="https://www.w3.org/TR/css-view-transitions-1/">CSS View Transitions Module Level 1</a> 规范，目前已经是 CR（Candidate Recommendation）阶段，说明离咱们大规模用上不远了。咱们的目标是彻底搞懂它，从“这啥玩意儿？”到“哦豁，有点意思”再到“爷青回，这动画我自己写！”。</p>
<h2>一、告别刀耕火种：View Transitions 要解决啥蛋疼问题？</h2>
<p>想想以前，尤其是在 SPA（单页应用）里搞页面切换动画，那叫一个折腾：</p>
<ol>
<li><strong>DOM 大乱炖</strong>：为了让新旧两个状态能同时存在并产生动画效果（比如旧的淡出，新的淡入），你可能得手动控制 DOM，让两个页面的内容在某个时间段内都挂在页面上。这 DOM 结构，简直是为了动画效果“牺牲色相”，乱七八糟。</li>
<li><strong>JS 胶水代码</strong>：得写一堆 JavaScript 来协调 DOM 的增删、CSS class 的切换、动画的开始结束监听。逻辑复杂，还容易出 bug。</li>
<li><strong>性能与体验</strong>：DOM 结构复杂了，性能可能受影响；动画过程中，焦点管理、可访问性（ARIA）也容易出问题，用户体验可能打折。比如动画过程中，屏幕阅读器是读旧的还是新的？按钮能点吗？</li>
</ol>
<p><strong>核心痛点</strong>：<strong>视觉过渡效果</strong> 和 <strong>DOM 状态更新</strong> 这两件事，在过去是紧密耦合、互相掣肘的。为了视觉效果，我们不得不扭曲 DOM 结构和更新逻辑。</p>
<h2>二、View Transitions 的核心思想与哲学：解耦！分离！</h2>
<p>W3C 的大佬们说：“不行，这太 low 了！咱们得想个办法把这两件事分开！”</p>
<p>于是，View Transitions 的核心哲学诞生了：</p>
<p><strong>将视觉层面的过渡动画 与 DOM 结构和数据的更新彻底分离。</strong></p>
<p>怎么分离呢？想象一下：</p>
<ol>
<li><strong>DOM 更新？瞬间完成！</strong> 你该怎么更新 DOM 还怎么更新，别管动画的事儿。调用 API 后，你的更新代码（比如 React 的 <code>setState</code>，Vue 的数据修改，或者原生 JS 操作）会立即或异步执行，DOM 状态瞬间变成新的。</li>
<li><strong>视觉过渡？交给浏览器！</strong> 在你更新 DOM 的前后，浏览器会像个摄影师，“咔嚓”给旧状态拍张照，“咔嚓”给新状态拍张照（这里的“照片”是渲染层面的快照，不是真的图片文件）。</li>
<li><strong>幕后动画师</strong>：浏览器拿到这两张“照片”后，在一个特殊的、凌驾于普通内容之上的图层里，基于这两张快照玩起了动画。默认是简单的交叉淡入淡出（cross-fade）。旧“照片”慢慢消失，新“照片”慢慢显现。</li>
<li><strong>动画结束，收工！</strong> 动画播完，这个特殊的图层和里面的“照片”就被清理掉了，用户看到的就是真实的新 DOM 状态。</li>
</ol>
<p><strong>好处显而易见：</strong></p>
<ul>
<li><strong>DOM 干净</strong>：你的 DOM 结构永远反映真实的应用状态，不用为了动画而妥协。</li>
<li><strong>关注点分离</strong>：JS 只管数据和 DOM 更新，CSS/Web Animations API 只管动画表现。清爽！</li>
<li><strong>体验更佳</strong>：因为 DOM 更新是（逻辑上）瞬时的，底层的状态切换更快，可访问性问题也更容易处理。动画只是一个视觉增强层。</li>
<li><strong>渐进增强</strong>：如果浏览器不支持 View Transitions，或者因为某些原因（如用户设置了减弱动态效果）动画无法执行，你的 DOM 更新逻辑依然会照常运行，页面还是能正常切换，只是没动画而已。完美符合渐进增强的理念。</li>
</ul>
<h2>三、上手初体验：<code>document.startViewTransition</code> 登场！</h2>
<p>说了半天理论，上代码！最最核心的入口就是 <code>document</code> 对象上的新方法 <code>startViewTransition()</code>。</p>
<pre><code class="language-javascript">// 假设你原来是这么更新内容的
function updateContent(data) {
  // ... 一顿操作猛如虎，更新 DOM ...
  console.log("DOM 更新完毕！");
}

// 现在想加上过渡动画？改成这样：
function navigate(data) {
  // 判断浏览器是否支持
  if (!document.startViewTransition) {
    console.log("浏览器不支持 View Transitions，直接更新");
    updateContent(data);
    return;
  }

  // 调用 startViewTransition ！
  const transition = document.startViewTransition(() => {
    // 这个回调函数里，放你原来的 DOM 更新逻辑
    updateContent(data);
    // 这个回调函数可以是同步的，也可以返回一个 Promise
    // 如果返回 Promise，浏览器会等 Promise resolve 后再拍“新照片”
    // return new Promise(resolve => setTimeout(resolve, 1000));
  });

  // transition 对象后面会讲，它包含一些有用的 Promise
  transition.finished.then(() => {
    console.log("过渡动画播放完毕！");
  });
}

// 触发导航
navigate({ content: "新的页面内容" });
</code></pre>
<p><strong>发生了什么？</strong></p>
<ol>
<li>调用 <code>startViewTransition()</code>，浏览器：“收到！准备拍旧照片！”</li>
<li>浏览器拍下当前页面的<strong>旧状态快照</strong>。</li>
<li>浏览器执行你传入的那个回调函数 <code>() => updateContent(data)</code>。</li>
<li>你的 <code>updateContent</code> 函数执行，DOM 瞬间变成了新状态。</li>
<li>（如果回调返回 Promise，浏览器会等它 resolve）浏览器：“OK，DOM 更新完了，拍新照片！”</li>
<li>浏览器拍下当前页面的<strong>新状态快照</strong>。</li>
<li>浏览器在幕后创建一个特殊的<strong>伪元素树</strong>（后面细讲），把旧快照和新快照放进去。</li>
<li>浏览器应用默认的 CSS 动画（交叉淡入淡出）到这些伪元素上。</li>
<li>动画开始播放。用户看到旧内容淡出，新内容淡入。</li>
<li>动画结束。</li>
<li>浏览器清理掉伪元素树。</li>
<li><code>transition.finished</code> Promise resolve。</li>
</ol>
<p>就这么简单，一个基础的页面交叉淡入淡出效果就有了！你几乎没改动原来的 DOM 更新逻辑，只是把它包了一层 <code>startViewTransition</code>。</p>
<p><strong><code>ViewTransition</code> 对象：你的动画小助手</strong></p>
<p><code>startViewTransition</code> 返回一个 <code>ViewTransition</code> 对象，它有几个重要的属性（都是 Promise）：</p>
<ul>
<li><code>updateCallbackDone</code>: 当你传入的回调函数执行完毕（如果是 Promise，则 resolve）时，这个 Promise 就 resolve。表示 DOM 更新逻辑本身已经跑完了。</li>
<li><code>ready</code>: 当浏览器准备好新旧快照，并且创建了用于动画的伪元素、即将开始动画时，这个 Promise 就 resolve。如果你想用 JavaScript (Web Animations API) 来控制更复杂的动画，这是最佳时机。</li>
<li><code>finished</code>: 当整个过渡动画播放完毕，并且伪元素被清理后，这个 Promise 就 resolve。表示一切都结束了，用户看到的是最终的新状态。</li>
</ul>
<p>还有一个方法：</p>
<ul>
<li><code>skipTransition()</code>: 调用这个方法可以立即跳过动画，直接显示最终状态。这在某些情况下（比如用户快速连续点击）可能有用。</li>
</ul>
<h2>四、深入幕后：揭秘伪元素树</h2>
<p>前面提到，浏览器在幕后创建了一个“伪元素树”来承载动画。这棵树长啥样？</p>
<pre><code>::view-transition                    (根节点，覆盖整个视口)
└─ ::view-transition-group(name)     (每个独立过渡元素的“分组”)
   └─ ::view-transition-image-pair(name) (新旧快照的“容器对”)
      ├─ ::view-transition-old(name)   (旧状态快照的“图片”)
      └─ ::view-transition-new(name)   (新状态快照的“图片”)
</code></pre>
<ul>
<li><code>::view-transition</code>: 整个过渡效果的根容器，通常固定定位，覆盖整个快照区域（Snapshot Containing Block，一般是整个视口）。</li>
<li><code>::view-transition-group(name)</code>: 代表一个<strong>独立进行过渡的视觉区域</strong>。默认情况下，整个页面是一个匿名的 <code>root</code> 分组。如果你给某个元素指定了 <code>view-transition-name</code>，那么这个元素就会拥有自己的具名分组。这个 group 负责模拟原始元素的大小和位置，并且默认会在这两个状态之间进行动画。</li>
<li><code>::view-transition-image-pair(name)</code>: 包裹新旧两个快照的容器。它的主要作用是提供一个隔离环境（<code>isolation: isolate</code>），确保新旧快照的混合模式（blend mode）只影响它们俩，不影响外部。</li>
<li><code>::view-transition-old(name)</code>: 承载旧状态快照的伪元素。你可以把它想象成一个 <code>&#x3C;img></code> 标签，内容是旧页面的样子。</li>
<li><code>::view-transition-new(name)</code>: 承载新状态快照的伪元素。同上，内容是新页面的样子。</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>name</code> 通常是 <code>root</code>（代表整个页面），或者是你通过 CSS 的 <code>view-transition-name</code> 属性给元素指定的名字。</li>
<li>默认情况下，只有 <code>::view-transition-group(root)</code> 这一个分组。</li>
<li>浏览器提供了一套<strong>用户代理样式表 (UA Stylesheet)</strong>，给这些伪元素加上了默认样式和动画，实现了那个默认的交叉淡入淡出效果。</li>
<li><code>::view-transition-old(root)</code> 代表着 startViewTransition 开始之前的页面快照（截图）</li>
<li><code>::view-transition-new(root)</code> 代表着当前 document.documentElement 元素，它被当成快照使用。在这个期间，你实时去续改 dom 的样式，就是直接反应在 <code>::view-transition-new(root)</code> 这个快照上。
<ul>
<li>也就是说，其实你的整个 document.documentElement 已经变成一个快照元素了，如果你隐藏了 <code>::view-transition</code>（opacity:0），你会发现整个 document.documentElement 都不见了，其实是灯下黑，它其实就是挂载在 <code>::view-transition-new(root)</code> 里头。同时因为处于快照模式，DOM 的交互实现现在完全无法响应。</li>
</ul>
</li>
<li>如果你通过<code>view-transition-name: name</code> 去定义一个 Element，那么等同于这个元素被剥离出来，独立成一个图层来渲染。
<ul>
<li>如果这个 name 在<code>::view-transition-new(root)</code>中存在，那么它会获取其最终的样式，否则那么就默认使用<code>::view-transition-old(name)</code>复制成<code>::view-transition-new(name)</code></li>
<li>也就是说，这时候有两个层叠在一起的元素<code>::view-transition-old(name)</code>和<code>::view-transition-new(name)</code>，默认情况下，前者会做淡出动画，后者会做淡入动画。因此你可以拿着这两个元素分别搞事情。</li>
<li>以上同时二者被包含在 <code>::view-transition-image-pair(name)</code> 下面，同时 <code>::view-transition-image-pair(name)</code> 被包含在<code>::view-transition-group(name)</code>下面。目前 group 下面只有一个 image-pair 对象，之所以要设计成两层。是因为 image-pair 负责提供 <code>isolation: isolate</code>，然后 group 负责提供几何变 —— 即位置（transform）、尺寸（width, height）从旧状态到新状态的动画。</li>
<li>这里是因为 <code>isolation: isolate</code> 局限性，导致不得不分成两层。首先对于其作用，这里不展开细说，目的就是为了更好的前后过渡的混合效果</li>
<li>然后是如果将 image-pair 和 group 合并成一个行不行？大概行，但有些需求就不好做。假设如果分开，你可以在 group 上做背景色，而不会被 image-pair 所影响。因为<code>new</code>和<code>old</code>的 mix-blend-mode 只会干扰到 image-pair 就终止了。如果合成一个，那么背景色就会被参与到混合中去。</li>
<li>这里给一个例子 <a href="https://appn.deweb.com/examples/kitchen-sink/isolation-isolate/">Isolation Demo</a></li>
</ul>
</li>
</ul>
<h2>五、定制你的专属转场：CSS 大显身手</h2>
<p>默认的淡入淡出太普通？没问题！既然是伪元素，我们就可以用 CSS 来定制它们的样式和动画！</p>
<p><strong>1. 改变默认动画时长或效果 (针对整个页面 root)</strong></p>
<pre><code class="language-css">/* 让默认的交叉淡入淡出变慢一点 */
::view-transition-old(root),
::view-transition-new(root) {
  animation-duration: 0.5s;
}

/* 自定义动画：比如，旧的向左滑出并淡出，新的从右滑入并淡入 */
@keyframes slide-to-left {
  to {
    transform: translateX(-30px);
    opacity: 0;
  }
}

@keyframes slide-from-right {
  from {
    transform: translateX(30px);
    opacity: 0;
  }
}

::view-transition-old(root) {
  animation: 300ms cubic-bezier(0.4, 0, 1, 1) both slide-to-left;
}

::view-transition-new(root) {
  animation: 300ms cubic-bezier(0, 0, 0.2, 1) 90ms both slide-from-right; /* 延迟一点出现 */
}
</code></pre>
<p><strong>2. 让特定元素动起来：<code>view-transition-name</code></strong></p>
<p>想让页面上的某个卡片、头像、标题单独动起来？给它一个名字！</p>
<pre><code class="language-css">/* HTML 里有个卡片 */
/* &#x3C;div class="card detailed-card">...&#x3C;/div> */

/* CSS 里给它命名 */
.detailed-card {
  view-transition-name: detailed-card; /* 起个名字，必须唯一！ */
  contain: layout; /* 建议加上 contain，帮助浏览器优化 */
}
</code></pre>
<p>一旦你给元素加了 <code>view-transition-name</code>：</p>
<ul>
<li>浏览器会为这个 <code>detailed-card</code> 创建<strong>单独的</strong> <code>::view-transition-group(detailed-card)</code>、<code>::view-transition-image-pair(detailed-card)</code> 等伪元素。</li>
<li>这个元素在旧状态和新状态的快照会被单独截取。</li>
<li><code>::view-transition-group(detailed-card)</code> 会自动从旧元素的位置/大小<strong>动画过渡</strong>到新元素的位置/大小。</li>
<li><code>::view-transition-old(detailed-card)</code> 和 <code>::view-transition-new(detailed-card)</code> 默认还是会进行<strong>交叉淡入淡出</strong>。</li>
</ul>
<p>你可以像上面修改 <code>root</code> 一样，针对 <code>detailed-card</code> 这个名字来定制动画：</p>
<pre><code class="language-css">::view-transition-group(detailed-card) {
  /* 可以改变 group 的动画，比如弹跳效果 */
  animation-timing-function: cubic-bezier(0.5, 1.5, 0.5, 1.5);
}

::view-transition-old(detailed-card) {
  /* 比如让旧卡片直接消失，不淡出 */
  animation: none;
  opacity: 0;
}

::view-transition-new(detailed-card) {
  /* 比如让新卡片从下面飞入 */
  animation: 300ms ease-out both slide-from-bottom;
}

@keyframes slide-from-bottom {
  from {
    transform: translateY(50px);
    opacity: 0;
  }
}
</code></pre>
<p><strong>重要提示</strong>：<code>view-transition-name</code> 的值在<strong>同一时刻</strong>必须是唯一的。如果在拍快照时发现有两个元素用了同一个名字，整个 View Transition 过程会失败（但 DOM 更新还是会执行）。</p>
<p><strong>3. 处理进入和离开动画 (使用 <code>:only-child</code>)</strong></p>
<p>有时候，某个元素只在新状态或旧状态存在（比如一个侧边栏导航只在某些页面有）。这时 <code>::view-transition-image-pair</code> 里就只有一个孩子 (<code>::view-transition-old</code> 或 <code>::view-transition-new</code>)。我们可以利用 CSS 的 <code>:only-child</code> 伪类来专门处理这种情况：</p>
<pre><code class="language-css">.sidebar {
  view-transition-name: sidebar;
}

/* 侧边栏进入动画 (新状态有，旧状态没有) */
::view-transition-new(sidebar):only-child {
  animation: slide-in 300ms ease-out;
}

/* 侧边栏离开动画 (旧状态有，新状态没有) */
::view-transition-old(sidebar):only-child {
  animation: slide-out 300ms ease-in;
}

/* 如果新旧状态都有侧边栏，默认的 group 位置/大小动画 + image-pair 淡入淡出可能就够了， */
/* 或者你也可以单独为这种情况写动画 (不加 :only-child) */
</code></pre>
<h2>六、更骚的操作：JavaScript 动画 (Web Animations API)</h2>
<p>CSS 动画很方便，但对于某些交互性强、需要动态计算的动画（比如规范里的那个鼠标点击位置圆形展开的例子），JavaScript 就派上用场了。</p>
<p>最佳时机是等待 <code>transition.ready</code> Promise resolve 之后：</p>
<pre><code class="language-javascript">function navigateWithCircularReveal(data, clickEvent) {
  if (!document.startViewTransition) {
    updateContent(data);
    return;
  }

  // 获取点击位置
  const x = clickEvent?.clientX ?? window.innerWidth / 2;
  const y = clickEvent?.clientY ?? window.innerHeight / 2;
  // 计算到最远角的距离作为最终半径
  const endRadius = Math.hypot(
    Math.max(x, window.innerWidth - x),
    Math.max(y, window.innerHeight - y)
  );

  const transition = document.startViewTransition(() => updateContent(data));

  // 等待伪元素准备好
  transition.ready.then(() => {
    // 使用 Web Animations API
    document.documentElement.animate(
      {
        // 动画目标：从点击位置的小圆变成覆盖全屏的大圆
        clipPath: [
          `circle(0px at ${x}px ${y}px)`,
          `circle(${endRadius}px at ${x}px ${y}px)`,
        ],
      },
      {
        duration: 500,
        easing: "ease-in",
        // 关键：指定动画作用在哪个伪元素上！
        pseudoElement: "::view-transition-new(root)", // 让新内容以圆形揭示出来
      }
    );
  });
}
</code></pre>
<p>在这个例子里，我们还需要修改一下 CSS，阻止默认的淡入淡出，并让新旧内容直接叠加：</p>
<pre><code class="language-css">/* 禁用默认动画 */
::view-transition-old(root),
::view-transition-new(root) {
  animation: none;
}

/* 让新旧内容直接叠加，由 clip-path 控制谁可见 */
::view-transition-image-pair(root) {
  isolation: auto; /* 如果不需要混合模式，可以设为 auto */
}

::view-transition-new(root) {
  mix-blend-mode: normal; /* 确保 JS 动画时混合模式正常 */
  z-index: 1; /* 确保新内容在上面，被 clip-path 控制 */
}

::view-transition-old(root) {
  mix-blend-mode: normal;
  z-index: 0;
}
</code></pre>
<h2>七、注意事项与最佳实践</h2>
<ol>
<li><strong><code>view-transition-name</code> 唯一性</strong>：再强调一次，非常重要！</li>
<li><strong><code>contain: layout</code> / <code>content-visibility: hidden</code></strong>：对于指定了 <code>view-transition-name</code> 的元素，加上 <code>contain: layout;</code> 或类似的 CSS（如 <code>contain: strict;</code> 或 <code>content-visibility: hidden;</code> 如果适用）可以帮助浏览器更好地隔离该元素的布局和渲染，提升性能。浏览器只需要知道这个元素的大小和位置，内部细节在快照时再处理。</li>
<li><strong>过渡是增强</strong>：时刻记住 View Transitions 是锦上添花。即使动画失败或被跳过，核心功能（DOM 更新）也应该能正常工作。</li>
<li><strong>性能考量</strong>：虽然浏览器会做优化，但截取快照、创建伪元素、运行动画还是有成本的。对于非常复杂的页面或大量的独立过渡元素，要注意测试性能。避免给太多小元素指定 <code>view-transition-name</code>。</li>
<li><strong>快照内容</strong>：快照是渲染结果，包括 CSS 绘制的背景、伪元素内容等。但不包括 <code>&#x3C;iframe></code> 内部的内容（除非同源）或某些插件内容。</li>
<li><strong>调试</strong>：现代浏览器的开发者工具（如 Chrome DevTools）已经开始支持调试 View Transitions，可以检查伪元素树、查看应用的动画等。</li>
</ol>
<h2>八、总结</h2>
<p>CSS View Transitions 绝对是近年来 Web 平台最令人兴奋的新特性之一。它精准地抓住了前端开发中关于页面切换动画的痛点，提供了一种优雅、高效且符合渐进增强理念的解决方案。</p>
<p>其核心在于<strong>分离 DOM 更新与视觉过渡</strong>，通过<strong>快照</strong>和<strong>伪元素树</strong>，让浏览器接管了繁琐的过渡动画协调工作，开发者只需要：</p>
<ol>
<li>用 <code>document.startViewTransition</code> 包裹你的 DOM 更新逻辑。</li>
<li>（可选）用 <code>view-transition-name</code> 标记需要独立动画的元素。</li>
<li>（可选）用 CSS 或 JavaScript (Web Animations API) 定制伪元素的动画效果。</li>
</ol>
<p>从此，打造原生 App 般丝滑的页面转场不再是难事。赶紧去试试吧，让你的网页也“纵享丝滑”！</p>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.w3.org/TR/css-view-transitions-1/">W3C CSS View Transitions Module Level 1 Spec</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API">MDN 文档: View Transitions API</a></li>
<li><a href="https://developer.chrome.com/docs/web-platform/view-transitions/same-document">Same-document view transitions for single-page applications</a></li>
<li><a href="https://github.com/demarketed/view-transitions-polyfill">github.com/demarketed/view-transitions-polyfill</a></li>
<li><a href="https://caniuse.com/view-transitions"><code>caniuse View Transitions API (single-document)</code></a>
<ul>
<li>chrome 111+</li>
<li>safari 18.0+</li>
</ul>
</li>
</ul></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0054.css-view-transitions-1"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0054.css-view-transitions-1.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"title":"View Transitions API (Level-1 single-document)","date":"!Date:2025-04-07T10:14:19.053Z","updated":"!Date:2025-04-07T10:14:19.053Z"},"metadata":{"title":"View Transitions API (Level-1 single-document)","date":"!Date:2025-04-07T10:14:19.053Z","updated":"!Date:2025-04-07T10:14:19.053Z","id":"0054.css-view-transitions-1","createdAt":"!Date:2025-04-07T10:14:19.053Z","updatedAt":"!Date:2025-04-07T10:14:19.053Z","tags":[]},"htmlContent":"\u003cp>今天咱们来聊一个前端圈儿里越来越火的新玩意儿——CSS View Transitions。这东西就好比给你的网页换场加了个丝滑的电影转场特效，告别过去那种生硬的“啪嗒”一下切换页面的体验。\u003c/p>\n\u003cp>W3C 的大佬们捣鼓出的这个 \u003ca href=\"https://www.w3.org/TR/css-view-transitions-1/\">CSS View Transitions Module Level 1\u003c/a> 规范，目前已经是 CR（Candidate Recommendation）阶段，说明离咱们大规模用上不远了。咱们的目标是彻底搞懂它，从“这啥玩意儿？”到“哦豁，有点意思”再到“爷青回，这动画我自己写！”。\u003c/p>\n\u003ch2>一、告别刀耕火种：View Transitions 要解决啥蛋疼问题？\u003c/h2>\n\u003cp>想想以前，尤其是在 SPA（单页应用）里搞页面切换动画，那叫一个折腾：\u003c/p>\n\u003col>\n\u003cli>\u003cstrong>DOM 大乱炖\u003c/strong>：为了让新旧两个状态能同时存在并产生动画效果（比如旧的淡出，新的淡入），你可能得手动控制 DOM，让两个页面的内容在某个时间段内都挂在页面上。这 DOM 结构，简直是为了动画效果“牺牲色相”，乱七八糟。\u003c/li>\n\u003cli>\u003cstrong>JS 胶水代码\u003c/strong>：得写一堆 JavaScript 来协调 DOM 的增删、CSS class 的切换、动画的开始结束监听。逻辑复杂，还容易出 bug。\u003c/li>\n\u003cli>\u003cstrong>性能与体验\u003c/strong>：DOM 结构复杂了，性能可能受影响；动画过程中，焦点管理、可访问性（ARIA）也容易出问题，用户体验可能打折。比如动画过程中，屏幕阅读器是读旧的还是新的？按钮能点吗？\u003c/li>\n\u003c/ol>\n\u003cp>\u003cstrong>核心痛点\u003c/strong>：\u003cstrong>视觉过渡效果\u003c/strong> 和 \u003cstrong>DOM 状态更新\u003c/strong> 这两件事，在过去是紧密耦合、互相掣肘的。为了视觉效果，我们不得不扭曲 DOM 结构和更新逻辑。\u003c/p>\n\u003ch2>二、View Transitions 的核心思想与哲学：解耦！分离！\u003c/h2>\n\u003cp>W3C 的大佬们说：“不行，这太 low 了！咱们得想个办法把这两件事分开！”\u003c/p>\n\u003cp>于是，View Transitions 的核心哲学诞生了：\u003c/p>\n\u003cp>\u003cstrong>将视觉层面的过渡动画 与 DOM 结构和数据的更新彻底分离。\u003c/strong>\u003c/p>\n\u003cp>怎么分离呢？想象一下：\u003c/p>\n\u003col>\n\u003cli>\u003cstrong>DOM 更新？瞬间完成！\u003c/strong> 你该怎么更新 DOM 还怎么更新，别管动画的事儿。调用 API 后，你的更新代码（比如 React 的 \u003ccode>setState\u003c/code>，Vue 的数据修改，或者原生 JS 操作）会立即或异步执行，DOM 状态瞬间变成新的。\u003c/li>\n\u003cli>\u003cstrong>视觉过渡？交给浏览器！\u003c/strong> 在你更新 DOM 的前后，浏览器会像个摄影师，“咔嚓”给旧状态拍张照，“咔嚓”给新状态拍张照（这里的“照片”是渲染层面的快照，不是真的图片文件）。\u003c/li>\n\u003cli>\u003cstrong>幕后动画师\u003c/strong>：浏览器拿到这两张“照片”后，在一个特殊的、凌驾于普通内容之上的图层里，基于这两张快照玩起了动画。默认是简单的交叉淡入淡出（cross-fade）。旧“照片”慢慢消失，新“照片”慢慢显现。\u003c/li>\n\u003cli>\u003cstrong>动画结束，收工！\u003c/strong> 动画播完，这个特殊的图层和里面的“照片”就被清理掉了，用户看到的就是真实的新 DOM 状态。\u003c/li>\n\u003c/ol>\n\u003cp>\u003cstrong>好处显而易见：\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\u003cstrong>DOM 干净\u003c/strong>：你的 DOM 结构永远反映真实的应用状态，不用为了动画而妥协。\u003c/li>\n\u003cli>\u003cstrong>关注点分离\u003c/strong>：JS 只管数据和 DOM 更新，CSS/Web Animations API 只管动画表现。清爽！\u003c/li>\n\u003cli>\u003cstrong>体验更佳\u003c/strong>：因为 DOM 更新是（逻辑上）瞬时的，底层的状态切换更快，可访问性问题也更容易处理。动画只是一个视觉增强层。\u003c/li>\n\u003cli>\u003cstrong>渐进增强\u003c/strong>：如果浏览器不支持 View Transitions，或者因为某些原因（如用户设置了减弱动态效果）动画无法执行，你的 DOM 更新逻辑依然会照常运行，页面还是能正常切换，只是没动画而已。完美符合渐进增强的理念。\u003c/li>\n\u003c/ul>\n\u003ch2>三、上手初体验：\u003ccode>document.startViewTransition\u003c/code> 登场！\u003c/h2>\n\u003cp>说了半天理论，上代码！最最核心的入口就是 \u003ccode>document\u003c/code> 对象上的新方法 \u003ccode>startViewTransition()\u003c/code>。\u003c/p>\n\u003cpre>\u003ccode class=\"language-javascript\">// 假设你原来是这么更新内容的\nfunction updateContent(data) {\n  // ... 一顿操作猛如虎，更新 DOM ...\n  console.log(\"DOM 更新完毕！\");\n}\n\n// 现在想加上过渡动画？改成这样：\nfunction navigate(data) {\n  // 判断浏览器是否支持\n  if (!document.startViewTransition) {\n    console.log(\"浏览器不支持 View Transitions，直接更新\");\n    updateContent(data);\n    return;\n  }\n\n  // 调用 startViewTransition ！\n  const transition = document.startViewTransition(() => {\n    // 这个回调函数里，放你原来的 DOM 更新逻辑\n    updateContent(data);\n    // 这个回调函数可以是同步的，也可以返回一个 Promise\n    // 如果返回 Promise，浏览器会等 Promise resolve 后再拍“新照片”\n    // return new Promise(resolve => setTimeout(resolve, 1000));\n  });\n\n  // transition 对象后面会讲，它包含一些有用的 Promise\n  transition.finished.then(() => {\n    console.log(\"过渡动画播放完毕！\");\n  });\n}\n\n// 触发导航\nnavigate({ content: \"新的页面内容\" });\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>发生了什么？\u003c/strong>\u003c/p>\n\u003col>\n\u003cli>调用 \u003ccode>startViewTransition()\u003c/code>，浏览器：“收到！准备拍旧照片！”\u003c/li>\n\u003cli>浏览器拍下当前页面的\u003cstrong>旧状态快照\u003c/strong>。\u003c/li>\n\u003cli>浏览器执行你传入的那个回调函数 \u003ccode>() => updateContent(data)\u003c/code>。\u003c/li>\n\u003cli>你的 \u003ccode>updateContent\u003c/code> 函数执行，DOM 瞬间变成了新状态。\u003c/li>\n\u003cli>（如果回调返回 Promise，浏览器会等它 resolve）浏览器：“OK，DOM 更新完了，拍新照片！”\u003c/li>\n\u003cli>浏览器拍下当前页面的\u003cstrong>新状态快照\u003c/strong>。\u003c/li>\n\u003cli>浏览器在幕后创建一个特殊的\u003cstrong>伪元素树\u003c/strong>（后面细讲），把旧快照和新快照放进去。\u003c/li>\n\u003cli>浏览器应用默认的 CSS 动画（交叉淡入淡出）到这些伪元素上。\u003c/li>\n\u003cli>动画开始播放。用户看到旧内容淡出，新内容淡入。\u003c/li>\n\u003cli>动画结束。\u003c/li>\n\u003cli>浏览器清理掉伪元素树。\u003c/li>\n\u003cli>\u003ccode>transition.finished\u003c/code> Promise resolve。\u003c/li>\n\u003c/ol>\n\u003cp>就这么简单，一个基础的页面交叉淡入淡出效果就有了！你几乎没改动原来的 DOM 更新逻辑，只是把它包了一层 \u003ccode>startViewTransition\u003c/code>。\u003c/p>\n\u003cp>\u003cstrong>\u003ccode>ViewTransition\u003c/code> 对象：你的动画小助手\u003c/strong>\u003c/p>\n\u003cp>\u003ccode>startViewTransition\u003c/code> 返回一个 \u003ccode>ViewTransition\u003c/code> 对象，它有几个重要的属性（都是 Promise）：\u003c/p>\n\u003cul>\n\u003cli>\u003ccode>updateCallbackDone\u003c/code>: 当你传入的回调函数执行完毕（如果是 Promise，则 resolve）时，这个 Promise 就 resolve。表示 DOM 更新逻辑本身已经跑完了。\u003c/li>\n\u003cli>\u003ccode>ready\u003c/code>: 当浏览器准备好新旧快照，并且创建了用于动画的伪元素、即将开始动画时，这个 Promise 就 resolve。如果你想用 JavaScript (Web Animations API) 来控制更复杂的动画，这是最佳时机。\u003c/li>\n\u003cli>\u003ccode>finished\u003c/code>: 当整个过渡动画播放完毕，并且伪元素被清理后，这个 Promise 就 resolve。表示一切都结束了，用户看到的是最终的新状态。\u003c/li>\n\u003c/ul>\n\u003cp>还有一个方法：\u003c/p>\n\u003cul>\n\u003cli>\u003ccode>skipTransition()\u003c/code>: 调用这个方法可以立即跳过动画，直接显示最终状态。这在某些情况下（比如用户快速连续点击）可能有用。\u003c/li>\n\u003c/ul>\n\u003ch2>四、深入幕后：揭秘伪元素树\u003c/h2>\n\u003cp>前面提到，浏览器在幕后创建了一个“伪元素树”来承载动画。这棵树长啥样？\u003c/p>\n\u003cpre>\u003ccode>::view-transition                    (根节点，覆盖整个视口)\n└─ ::view-transition-group(name)     (每个独立过渡元素的“分组”)\n   └─ ::view-transition-image-pair(name) (新旧快照的“容器对”)\n      ├─ ::view-transition-old(name)   (旧状态快照的“图片”)\n      └─ ::view-transition-new(name)   (新状态快照的“图片”)\n\u003c/code>\u003c/pre>\n\u003cul>\n\u003cli>\u003ccode>::view-transition\u003c/code>: 整个过渡效果的根容器，通常固定定位，覆盖整个快照区域（Snapshot Containing Block，一般是整个视口）。\u003c/li>\n\u003cli>\u003ccode>::view-transition-group(name)\u003c/code>: 代表一个\u003cstrong>独立进行过渡的视觉区域\u003c/strong>。默认情况下，整个页面是一个匿名的 \u003ccode>root\u003c/code> 分组。如果你给某个元素指定了 \u003ccode>view-transition-name\u003c/code>，那么这个元素就会拥有自己的具名分组。这个 group 负责模拟原始元素的大小和位置，并且默认会在这两个状态之间进行动画。\u003c/li>\n\u003cli>\u003ccode>::view-transition-image-pair(name)\u003c/code>: 包裹新旧两个快照的容器。它的主要作用是提供一个隔离环境（\u003ccode>isolation: isolate\u003c/code>），确保新旧快照的混合模式（blend mode）只影响它们俩，不影响外部。\u003c/li>\n\u003cli>\u003ccode>::view-transition-old(name)\u003c/code>: 承载旧状态快照的伪元素。你可以把它想象成一个 \u003ccode>&#x3C;img>\u003c/code> 标签，内容是旧页面的样子。\u003c/li>\n\u003cli>\u003ccode>::view-transition-new(name)\u003c/code>: 承载新状态快照的伪元素。同上，内容是新页面的样子。\u003c/li>\n\u003c/ul>\n\u003cp>\u003cstrong>关键点\u003c/strong>：\u003c/p>\n\u003cul>\n\u003cli>\u003ccode>name\u003c/code> 通常是 \u003ccode>root\u003c/code>（代表整个页面），或者是你通过 CSS 的 \u003ccode>view-transition-name\u003c/code> 属性给元素指定的名字。\u003c/li>\n\u003cli>默认情况下，只有 \u003ccode>::view-transition-group(root)\u003c/code> 这一个分组。\u003c/li>\n\u003cli>浏览器提供了一套\u003cstrong>用户代理样式表 (UA Stylesheet)\u003c/strong>，给这些伪元素加上了默认样式和动画，实现了那个默认的交叉淡入淡出效果。\u003c/li>\n\u003cli>\u003ccode>::view-transition-old(root)\u003c/code> 代表着 startViewTransition 开始之前的页面快照（截图）\u003c/li>\n\u003cli>\u003ccode>::view-transition-new(root)\u003c/code> 代表着当前 document.documentElement 元素，它被当成快照使用。在这个期间，你实时去续改 dom 的样式，就是直接反应在 \u003ccode>::view-transition-new(root)\u003c/code> 这个快照上。\n\u003cul>\n\u003cli>也就是说，其实你的整个 document.documentElement 已经变成一个快照元素了，如果你隐藏了 \u003ccode>::view-transition\u003c/code>（opacity:0），你会发现整个 document.documentElement 都不见了，其实是灯下黑，它其实就是挂载在 \u003ccode>::view-transition-new(root)\u003c/code> 里头。同时因为处于快照模式，DOM 的交互实现现在完全无法响应。\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003cli>如果你通过\u003ccode>view-transition-name: name\u003c/code> 去定义一个 Element，那么等同于这个元素被剥离出来，独立成一个图层来渲染。\n\u003cul>\n\u003cli>如果这个 name 在\u003ccode>::view-transition-new(root)\u003c/code>中存在，那么它会获取其最终的样式，否则那么就默认使用\u003ccode>::view-transition-old(name)\u003c/code>复制成\u003ccode>::view-transition-new(name)\u003c/code>\u003c/li>\n\u003cli>也就是说，这时候有两个层叠在一起的元素\u003ccode>::view-transition-old(name)\u003c/code>和\u003ccode>::view-transition-new(name)\u003c/code>，默认情况下，前者会做淡出动画，后者会做淡入动画。因此你可以拿着这两个元素分别搞事情。\u003c/li>\n\u003cli>以上同时二者被包含在 \u003ccode>::view-transition-image-pair(name)\u003c/code> 下面，同时 \u003ccode>::view-transition-image-pair(name)\u003c/code> 被包含在\u003ccode>::view-transition-group(name)\u003c/code>下面。目前 group 下面只有一个 image-pair 对象，之所以要设计成两层。是因为 image-pair 负责提供 \u003ccode>isolation: isolate\u003c/code>，然后 group 负责提供几何变 —— 即位置（transform）、尺寸（width, height）从旧状态到新状态的动画。\u003c/li>\n\u003cli>这里是因为 \u003ccode>isolation: isolate\u003c/code> 局限性，导致不得不分成两层。首先对于其作用，这里不展开细说，目的就是为了更好的前后过渡的混合效果\u003c/li>\n\u003cli>然后是如果将 image-pair 和 group 合并成一个行不行？大概行，但有些需求就不好做。假设如果分开，你可以在 group 上做背景色，而不会被 image-pair 所影响。因为\u003ccode>new\u003c/code>和\u003ccode>old\u003c/code>的 mix-blend-mode 只会干扰到 image-pair 就终止了。如果合成一个，那么背景色就会被参与到混合中去。\u003c/li>\n\u003cli>这里给一个例子 \u003ca href=\"https://appn.deweb.com/examples/kitchen-sink/isolation-isolate/\">Isolation Demo\u003c/a>\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003c/ul>\n\u003ch2>五、定制你的专属转场：CSS 大显身手\u003c/h2>\n\u003cp>默认的淡入淡出太普通？没问题！既然是伪元素，我们就可以用 CSS 来定制它们的样式和动画！\u003c/p>\n\u003cp>\u003cstrong>1. 改变默认动画时长或效果 (针对整个页面 root)\u003c/strong>\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">/* 让默认的交叉淡入淡出变慢一点 */\n::view-transition-old(root),\n::view-transition-new(root) {\n  animation-duration: 0.5s;\n}\n\n/* 自定义动画：比如，旧的向左滑出并淡出，新的从右滑入并淡入 */\n@keyframes slide-to-left {\n  to {\n    transform: translateX(-30px);\n    opacity: 0;\n  }\n}\n\n@keyframes slide-from-right {\n  from {\n    transform: translateX(30px);\n    opacity: 0;\n  }\n}\n\n::view-transition-old(root) {\n  animation: 300ms cubic-bezier(0.4, 0, 1, 1) both slide-to-left;\n}\n\n::view-transition-new(root) {\n  animation: 300ms cubic-bezier(0, 0, 0.2, 1) 90ms both slide-from-right; /* 延迟一点出现 */\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>2. 让特定元素动起来：\u003ccode>view-transition-name\u003c/code>\u003c/strong>\u003c/p>\n\u003cp>想让页面上的某个卡片、头像、标题单独动起来？给它一个名字！\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">/* HTML 里有个卡片 */\n/* &#x3C;div class=\"card detailed-card\">...&#x3C;/div> */\n\n/* CSS 里给它命名 */\n.detailed-card {\n  view-transition-name: detailed-card; /* 起个名字，必须唯一！ */\n  contain: layout; /* 建议加上 contain，帮助浏览器优化 */\n}\n\u003c/code>\u003c/pre>\n\u003cp>一旦你给元素加了 \u003ccode>view-transition-name\u003c/code>：\u003c/p>\n\u003cul>\n\u003cli>浏览器会为这个 \u003ccode>detailed-card\u003c/code> 创建\u003cstrong>单独的\u003c/strong> \u003ccode>::view-transition-group(detailed-card)\u003c/code>、\u003ccode>::view-transition-image-pair(detailed-card)\u003c/code> 等伪元素。\u003c/li>\n\u003cli>这个元素在旧状态和新状态的快照会被单独截取。\u003c/li>\n\u003cli>\u003ccode>::view-transition-group(detailed-card)\u003c/code> 会自动从旧元素的位置/大小\u003cstrong>动画过渡\u003c/strong>到新元素的位置/大小。\u003c/li>\n\u003cli>\u003ccode>::view-transition-old(detailed-card)\u003c/code> 和 \u003ccode>::view-transition-new(detailed-card)\u003c/code> 默认还是会进行\u003cstrong>交叉淡入淡出\u003c/strong>。\u003c/li>\n\u003c/ul>\n\u003cp>你可以像上面修改 \u003ccode>root\u003c/code> 一样，针对 \u003ccode>detailed-card\u003c/code> 这个名字来定制动画：\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">::view-transition-group(detailed-card) {\n  /* 可以改变 group 的动画，比如弹跳效果 */\n  animation-timing-function: cubic-bezier(0.5, 1.5, 0.5, 1.5);\n}\n\n::view-transition-old(detailed-card) {\n  /* 比如让旧卡片直接消失，不淡出 */\n  animation: none;\n  opacity: 0;\n}\n\n::view-transition-new(detailed-card) {\n  /* 比如让新卡片从下面飞入 */\n  animation: 300ms ease-out both slide-from-bottom;\n}\n\n@keyframes slide-from-bottom {\n  from {\n    transform: translateY(50px);\n    opacity: 0;\n  }\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>重要提示\u003c/strong>：\u003ccode>view-transition-name\u003c/code> 的值在\u003cstrong>同一时刻\u003c/strong>必须是唯一的。如果在拍快照时发现有两个元素用了同一个名字，整个 View Transition 过程会失败（但 DOM 更新还是会执行）。\u003c/p>\n\u003cp>\u003cstrong>3. 处理进入和离开动画 (使用 \u003ccode>:only-child\u003c/code>)\u003c/strong>\u003c/p>\n\u003cp>有时候，某个元素只在新状态或旧状态存在（比如一个侧边栏导航只在某些页面有）。这时 \u003ccode>::view-transition-image-pair\u003c/code> 里就只有一个孩子 (\u003ccode>::view-transition-old\u003c/code> 或 \u003ccode>::view-transition-new\u003c/code>)。我们可以利用 CSS 的 \u003ccode>:only-child\u003c/code> 伪类来专门处理这种情况：\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.sidebar {\n  view-transition-name: sidebar;\n}\n\n/* 侧边栏进入动画 (新状态有，旧状态没有) */\n::view-transition-new(sidebar):only-child {\n  animation: slide-in 300ms ease-out;\n}\n\n/* 侧边栏离开动画 (旧状态有，新状态没有) */\n::view-transition-old(sidebar):only-child {\n  animation: slide-out 300ms ease-in;\n}\n\n/* 如果新旧状态都有侧边栏，默认的 group 位置/大小动画 + image-pair 淡入淡出可能就够了， */\n/* 或者你也可以单独为这种情况写动画 (不加 :only-child) */\n\u003c/code>\u003c/pre>\n\u003ch2>六、更骚的操作：JavaScript 动画 (Web Animations API)\u003c/h2>\n\u003cp>CSS 动画很方便，但对于某些交互性强、需要动态计算的动画（比如规范里的那个鼠标点击位置圆形展开的例子），JavaScript 就派上用场了。\u003c/p>\n\u003cp>最佳时机是等待 \u003ccode>transition.ready\u003c/code> Promise resolve 之后：\u003c/p>\n\u003cpre>\u003ccode class=\"language-javascript\">function navigateWithCircularReveal(data, clickEvent) {\n  if (!document.startViewTransition) {\n    updateContent(data);\n    return;\n  }\n\n  // 获取点击位置\n  const x = clickEvent?.clientX ?? window.innerWidth / 2;\n  const y = clickEvent?.clientY ?? window.innerHeight / 2;\n  // 计算到最远角的距离作为最终半径\n  const endRadius = Math.hypot(\n    Math.max(x, window.innerWidth - x),\n    Math.max(y, window.innerHeight - y)\n  );\n\n  const transition = document.startViewTransition(() => updateContent(data));\n\n  // 等待伪元素准备好\n  transition.ready.then(() => {\n    // 使用 Web Animations API\n    document.documentElement.animate(\n      {\n        // 动画目标：从点击位置的小圆变成覆盖全屏的大圆\n        clipPath: [\n          `circle(0px at ${x}px ${y}px)`,\n          `circle(${endRadius}px at ${x}px ${y}px)`,\n        ],\n      },\n      {\n        duration: 500,\n        easing: \"ease-in\",\n        // 关键：指定动画作用在哪个伪元素上！\n        pseudoElement: \"::view-transition-new(root)\", // 让新内容以圆形揭示出来\n      }\n    );\n  });\n}\n\u003c/code>\u003c/pre>\n\u003cp>在这个例子里，我们还需要修改一下 CSS，阻止默认的淡入淡出，并让新旧内容直接叠加：\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">/* 禁用默认动画 */\n::view-transition-old(root),\n::view-transition-new(root) {\n  animation: none;\n}\n\n/* 让新旧内容直接叠加，由 clip-path 控制谁可见 */\n::view-transition-image-pair(root) {\n  isolation: auto; /* 如果不需要混合模式，可以设为 auto */\n}\n\n::view-transition-new(root) {\n  mix-blend-mode: normal; /* 确保 JS 动画时混合模式正常 */\n  z-index: 1; /* 确保新内容在上面，被 clip-path 控制 */\n}\n\n::view-transition-old(root) {\n  mix-blend-mode: normal;\n  z-index: 0;\n}\n\u003c/code>\u003c/pre>\n\u003ch2>七、注意事项与最佳实践\u003c/h2>\n\u003col>\n\u003cli>\u003cstrong>\u003ccode>view-transition-name\u003c/code> 唯一性\u003c/strong>：再强调一次，非常重要！\u003c/li>\n\u003cli>\u003cstrong>\u003ccode>contain: layout\u003c/code> / \u003ccode>content-visibility: hidden\u003c/code>\u003c/strong>：对于指定了 \u003ccode>view-transition-name\u003c/code> 的元素，加上 \u003ccode>contain: layout;\u003c/code> 或类似的 CSS（如 \u003ccode>contain: strict;\u003c/code> 或 \u003ccode>content-visibility: hidden;\u003c/code> 如果适用）可以帮助浏览器更好地隔离该元素的布局和渲染，提升性能。浏览器只需要知道这个元素的大小和位置，内部细节在快照时再处理。\u003c/li>\n\u003cli>\u003cstrong>过渡是增强\u003c/strong>：时刻记住 View Transitions 是锦上添花。即使动画失败或被跳过，核心功能（DOM 更新）也应该能正常工作。\u003c/li>\n\u003cli>\u003cstrong>性能考量\u003c/strong>：虽然浏览器会做优化，但截取快照、创建伪元素、运行动画还是有成本的。对于非常复杂的页面或大量的独立过渡元素，要注意测试性能。避免给太多小元素指定 \u003ccode>view-transition-name\u003c/code>。\u003c/li>\n\u003cli>\u003cstrong>快照内容\u003c/strong>：快照是渲染结果，包括 CSS 绘制的背景、伪元素内容等。但不包括 \u003ccode>&#x3C;iframe>\u003c/code> 内部的内容（除非同源）或某些插件内容。\u003c/li>\n\u003cli>\u003cstrong>调试\u003c/strong>：现代浏览器的开发者工具（如 Chrome DevTools）已经开始支持调试 View Transitions，可以检查伪元素树、查看应用的动画等。\u003c/li>\n\u003c/ol>\n\u003ch2>八、总结\u003c/h2>\n\u003cp>CSS View Transitions 绝对是近年来 Web 平台最令人兴奋的新特性之一。它精准地抓住了前端开发中关于页面切换动画的痛点，提供了一种优雅、高效且符合渐进增强理念的解决方案。\u003c/p>\n\u003cp>其核心在于\u003cstrong>分离 DOM 更新与视觉过渡\u003c/strong>，通过\u003cstrong>快照\u003c/strong>和\u003cstrong>伪元素树\u003c/strong>，让浏览器接管了繁琐的过渡动画协调工作，开发者只需要：\u003c/p>\n\u003col>\n\u003cli>用 \u003ccode>document.startViewTransition\u003c/code> 包裹你的 DOM 更新逻辑。\u003c/li>\n\u003cli>（可选）用 \u003ccode>view-transition-name\u003c/code> 标记需要独立动画的元素。\u003c/li>\n\u003cli>（可选）用 CSS 或 JavaScript (Web Animations API) 定制伪元素的动画效果。\u003c/li>\n\u003c/ol>\n\u003cp>从此，打造原生 App 般丝滑的页面转场不再是难事。赶紧去试试吧，让你的网页也“纵享丝滑”！\u003c/p>\n\u003cp>\u003cstrong>参考资料：\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\u003ca href=\"https://www.w3.org/TR/css-view-transitions-1/\">W3C CSS View Transitions Module Level 1 Spec\u003c/a>\u003c/li>\n\u003cli>\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API\">MDN 文档: View Transitions API\u003c/a>\u003c/li>\n\u003cli>\u003ca href=\"https://developer.chrome.com/docs/web-platform/view-transitions/same-document\">Same-document view transitions for single-page applications\u003c/a>\u003c/li>\n\u003cli>\u003ca href=\"https://github.com/demarketed/view-transitions-polyfill\">github.com/demarketed/view-transitions-polyfill\u003c/a>\u003c/li>\n\u003cli>\u003ca href=\"https://caniuse.com/view-transitions\">\u003ccode>caniuse View Transitions API (single-document)\u003c/code>\u003c/a>\n\u003cul>\n\u003cli>chrome 111+\u003c/li>\n\u003cli>safari 18.0+\u003c/li>\n\u003c/ul>\n\u003c/li>\n\u003c/ul>","markdownContent":"\n今天咱们来聊一个前端圈儿里越来越火的新玩意儿——CSS View Transitions。这东西就好比给你的网页换场加了个丝滑的电影转场特效，告别过去那种生硬的“啪嗒”一下切换页面的体验。\n\nW3C 的大佬们捣鼓出的这个 [CSS View Transitions Module Level 1](https://www.w3.org/TR/css-view-transitions-1/) 规范，目前已经是 CR（Candidate Recommendation）阶段，说明离咱们大规模用上不远了。咱们的目标是彻底搞懂它，从“这啥玩意儿？”到“哦豁，有点意思”再到“爷青回，这动画我自己写！”。\n\n## 一、告别刀耕火种：View Transitions 要解决啥蛋疼问题？\n\n想想以前，尤其是在 SPA（单页应用）里搞页面切换动画，那叫一个折腾：\n\n1.  **DOM 大乱炖**：为了让新旧两个状态能同时存在并产生动画效果（比如旧的淡出，新的淡入），你可能得手动控制 DOM，让两个页面的内容在某个时间段内都挂在页面上。这 DOM 结构，简直是为了动画效果“牺牲色相”，乱七八糟。\n2.  **JS 胶水代码**：得写一堆 JavaScript 来协调 DOM 的增删、CSS class 的切换、动画的开始结束监听。逻辑复杂，还容易出 bug。\n3.  **性能与体验**：DOM 结构复杂了，性能可能受影响；动画过程中，焦点管理、可访问性（ARIA）也容易出问题，用户体验可能打折。比如动画过程中，屏幕阅读器是读旧的还是新的？按钮能点吗？\n\n**核心痛点**：**视觉过渡效果** 和 **DOM 状态更新** 这两件事，在过去是紧密耦合、互相掣肘的。为了视觉效果，我们不得不扭曲 DOM 结构和更新逻辑。\n\n## 二、View Transitions 的核心思想与哲学：解耦！分离！\n\nW3C 的大佬们说：“不行，这太 low 了！咱们得想个办法把这两件事分开！”\n\n于是，View Transitions 的核心哲学诞生了：\n\n**将视觉层面的过渡动画 与 DOM 结构和数据的更新彻底分离。**\n\n怎么分离呢？想象一下：\n\n1.  **DOM 更新？瞬间完成！** 你该怎么更新 DOM 还怎么更新，别管动画的事儿。调用 API 后，你的更新代码（比如 React 的 `setState`，Vue 的数据修改，或者原生 JS 操作）会立即或异步执行，DOM 状态瞬间变成新的。\n2.  **视觉过渡？交给浏览器！** 在你更新 DOM 的前后，浏览器会像个摄影师，“咔嚓”给旧状态拍张照，“咔嚓”给新状态拍张照（这里的“照片”是渲染层面的快照，不是真的图片文件）。\n3.  **幕后动画师**：浏览器拿到这两张“照片”后，在一个特殊的、凌驾于普通内容之上的图层里，基于这两张快照玩起了动画。默认是简单的交叉淡入淡出（cross-fade）。旧“照片”慢慢消失，新“照片”慢慢显现。\n4.  **动画结束，收工！** 动画播完，这个特殊的图层和里面的“照片”就被清理掉了，用户看到的就是真实的新 DOM 状态。\n\n**好处显而易见：**\n\n- **DOM 干净**：你的 DOM 结构永远反映真实的应用状态，不用为了动画而妥协。\n- **关注点分离**：JS 只管数据和 DOM 更新，CSS/Web Animations API 只管动画表现。清爽！\n- **体验更佳**：因为 DOM 更新是（逻辑上）瞬时的，底层的状态切换更快，可访问性问题也更容易处理。动画只是一个视觉增强层。\n- **渐进增强**：如果浏览器不支持 View Transitions，或者因为某些原因（如用户设置了减弱动态效果）动画无法执行，你的 DOM 更新逻辑依然会照常运行，页面还是能正常切换，只是没动画而已。完美符合渐进增强的理念。\n\n## 三、上手初体验：`document.startViewTransition` 登场！\n\n说了半天理论，上代码！最最核心的入口就是 `document` 对象上的新方法 `startViewTransition()`。\n\n```javascript\n// 假设你原来是这么更新内容的\nfunction updateContent(data) {\n  // ... 一顿操作猛如虎，更新 DOM ...\n  console.log(\"DOM 更新完毕！\");\n}\n\n// 现在想加上过渡动画？改成这样：\nfunction navigate(data) {\n  // 判断浏览器是否支持\n  if (!document.startViewTransition) {\n    console.log(\"浏览器不支持 View Transitions，直接更新\");\n    updateContent(data);\n    return;\n  }\n\n  // 调用 startViewTransition ！\n  const transition = document.startViewTransition(() => {\n    // 这个回调函数里，放你原来的 DOM 更新逻辑\n    updateContent(data);\n    // 这个回调函数可以是同步的，也可以返回一个 Promise\n    // 如果返回 Promise，浏览器会等 Promise resolve 后再拍“新照片”\n    // return new Promise(resolve => setTimeout(resolve, 1000));\n  });\n\n  // transition 对象后面会讲，它包含一些有用的 Promise\n  transition.finished.then(() => {\n    console.log(\"过渡动画播放完毕！\");\n  });\n}\n\n// 触发导航\nnavigate({ content: \"新的页面内容\" });\n```\n\n**发生了什么？**\n\n1.  调用 `startViewTransition()`，浏览器：“收到！准备拍旧照片！”\n2.  浏览器拍下当前页面的**旧状态快照**。\n3.  浏览器执行你传入的那个回调函数 `() => updateContent(data)`。\n4.  你的 `updateContent` 函数执行，DOM 瞬间变成了新状态。\n5.  （如果回调返回 Promise，浏览器会等它 resolve）浏览器：“OK，DOM 更新完了，拍新照片！”\n6.  浏览器拍下当前页面的**新状态快照**。\n7.  浏览器在幕后创建一个特殊的**伪元素树**（后面细讲），把旧快照和新快照放进去。\n8.  浏览器应用默认的 CSS 动画（交叉淡入淡出）到这些伪元素上。\n9.  动画开始播放。用户看到旧内容淡出，新内容淡入。\n10. 动画结束。\n11. 浏览器清理掉伪元素树。\n12. `transition.finished` Promise resolve。\n\n就这么简单，一个基础的页面交叉淡入淡出效果就有了！你几乎没改动原来的 DOM 更新逻辑，只是把它包了一层 `startViewTransition`。\n\n**`ViewTransition` 对象：你的动画小助手**\n\n`startViewTransition` 返回一个 `ViewTransition` 对象，它有几个重要的属性（都是 Promise）：\n\n- `updateCallbackDone`: 当你传入的回调函数执行完毕（如果是 Promise，则 resolve）时，这个 Promise 就 resolve。表示 DOM 更新逻辑本身已经跑完了。\n- `ready`: 当浏览器准备好新旧快照，并且创建了用于动画的伪元素、即将开始动画时，这个 Promise 就 resolve。如果你想用 JavaScript (Web Animations API) 来控制更复杂的动画，这是最佳时机。\n- `finished`: 当整个过渡动画播放完毕，并且伪元素被清理后，这个 Promise 就 resolve。表示一切都结束了，用户看到的是最终的新状态。\n\n还有一个方法：\n\n- `skipTransition()`: 调用这个方法可以立即跳过动画，直接显示最终状态。这在某些情况下（比如用户快速连续点击）可能有用。\n\n## 四、深入幕后：揭秘伪元素树\n\n前面提到，浏览器在幕后创建了一个“伪元素树”来承载动画。这棵树长啥样？\n\n```\n::view-transition                    (根节点，覆盖整个视口)\n└─ ::view-transition-group(name)     (每个独立过渡元素的“分组”)\n   └─ ::view-transition-image-pair(name) (新旧快照的“容器对”)\n      ├─ ::view-transition-old(name)   (旧状态快照的“图片”)\n      └─ ::view-transition-new(name)   (新状态快照的“图片”)\n```\n\n- `::view-transition`: 整个过渡效果的根容器，通常固定定位，覆盖整个快照区域（Snapshot Containing Block，一般是整个视口）。\n- `::view-transition-group(name)`: 代表一个**独立进行过渡的视觉区域**。默认情况下，整个页面是一个匿名的 `root` 分组。如果你给某个元素指定了 `view-transition-name`，那么这个元素就会拥有自己的具名分组。这个 group 负责模拟原始元素的大小和位置，并且默认会在这两个状态之间进行动画。\n- `::view-transition-image-pair(name)`: 包裹新旧两个快照的容器。它的主要作用是提供一个隔离环境（`isolation: isolate`），确保新旧快照的混合模式（blend mode）只影响它们俩，不影响外部。\n- `::view-transition-old(name)`: 承载旧状态快照的伪元素。你可以把它想象成一个 `\u003cimg>` 标签，内容是旧页面的样子。\n- `::view-transition-new(name)`: 承载新状态快照的伪元素。同上，内容是新页面的样子。\n\n**关键点**：\n\n- `name` 通常是 `root`（代表整个页面），或者是你通过 CSS 的 `view-transition-name` 属性给元素指定的名字。\n- 默认情况下，只有 `::view-transition-group(root)` 这一个分组。\n- 浏览器提供了一套**用户代理样式表 (UA Stylesheet)**，给这些伪元素加上了默认样式和动画，实现了那个默认的交叉淡入淡出效果。\n- `::view-transition-old(root)` 代表着 startViewTransition 开始之前的页面快照（截图）\n- `::view-transition-new(root)` 代表着当前 document.documentElement 元素，它被当成快照使用。在这个期间，你实时去续改 dom 的样式，就是直接反应在 `::view-transition-new(root)` 这个快照上。\n  - 也就是说，其实你的整个 document.documentElement 已经变成一个快照元素了，如果你隐藏了 `::view-transition`（opacity:0），你会发现整个 document.documentElement 都不见了，其实是灯下黑，它其实就是挂载在 `::view-transition-new(root)` 里头。同时因为处于快照模式，DOM 的交互实现现在完全无法响应。\n- 如果你通过`view-transition-name: name` 去定义一个 Element，那么等同于这个元素被剥离出来，独立成一个图层来渲染。\n  - 如果这个 name 在`::view-transition-new(root)`中存在，那么它会获取其最终的样式，否则那么就默认使用`::view-transition-old(name)`复制成`::view-transition-new(name)`\n  - 也就是说，这时候有两个层叠在一起的元素`::view-transition-old(name)`和`::view-transition-new(name)`，默认情况下，前者会做淡出动画，后者会做淡入动画。因此你可以拿着这两个元素分别搞事情。\n  - 以上同时二者被包含在 `::view-transition-image-pair(name)` 下面，同时 `::view-transition-image-pair(name)` 被包含在`::view-transition-group(name)`下面。目前 group 下面只有一个 image-pair 对象，之所以要设计成两层。是因为 image-pair 负责提供 `isolation: isolate`，然后 group 负责提供几何变 —— 即位置（transform）、尺寸（width, height）从旧状态到新状态的动画。\n  - 这里是因为 `isolation: isolate` 局限性，导致不得不分成两层。首先对于其作用，这里不展开细说，目的就是为了更好的前后过渡的混合效果\n  - 然后是如果将 image-pair 和 group 合并成一个行不行？大概行，但有些需求就不好做。假设如果分开，你可以在 group 上做背景色，而不会被 image-pair 所影响。因为`new`和`old`的 mix-blend-mode 只会干扰到 image-pair 就终止了。如果合成一个，那么背景色就会被参与到混合中去。\n  - 这里给一个例子 [Isolation Demo](https://appn.deweb.com/examples/kitchen-sink/isolation-isolate/)\n\n## 五、定制你的专属转场：CSS 大显身手\n\n默认的淡入淡出太普通？没问题！既然是伪元素，我们就可以用 CSS 来定制它们的样式和动画！\n\n**1. 改变默认动画时长或效果 (针对整个页面 root)**\n\n```css\n/* 让默认的交叉淡入淡出变慢一点 */\n::view-transition-old(root),\n::view-transition-new(root) {\n  animation-duration: 0.5s;\n}\n\n/* 自定义动画：比如，旧的向左滑出并淡出，新的从右滑入并淡入 */\n@keyframes slide-to-left {\n  to {\n    transform: translateX(-30px);\n    opacity: 0;\n  }\n}\n\n@keyframes slide-from-right {\n  from {\n    transform: translateX(30px);\n    opacity: 0;\n  }\n}\n\n::view-transition-old(root) {\n  animation: 300ms cubic-bezier(0.4, 0, 1, 1) both slide-to-left;\n}\n\n::view-transition-new(root) {\n  animation: 300ms cubic-bezier(0, 0, 0.2, 1) 90ms both slide-from-right; /* 延迟一点出现 */\n}\n```\n\n**2. 让特定元素动起来：`view-transition-name`**\n\n想让页面上的某个卡片、头像、标题单独动起来？给它一个名字！\n\n```css\n/* HTML 里有个卡片 */\n/* \u003cdiv class=\"card detailed-card\">...\u003c/div> */\n\n/* CSS 里给它命名 */\n.detailed-card {\n  view-transition-name: detailed-card; /* 起个名字，必须唯一！ */\n  contain: layout; /* 建议加上 contain，帮助浏览器优化 */\n}\n```\n\n一旦你给元素加了 `view-transition-name`：\n\n- 浏览器会为这个 `detailed-card` 创建**单独的** `::view-transition-group(detailed-card)`、`::view-transition-image-pair(detailed-card)` 等伪元素。\n- 这个元素在旧状态和新状态的快照会被单独截取。\n- `::view-transition-group(detailed-card)` 会自动从旧元素的位置/大小**动画过渡**到新元素的位置/大小。\n- `::view-transition-old(detailed-card)` 和 `::view-transition-new(detailed-card)` 默认还是会进行**交叉淡入淡出**。\n\n你可以像上面修改 `root` 一样，针对 `detailed-card` 这个名字来定制动画：\n\n```css\n::view-transition-group(detailed-card) {\n  /* 可以改变 group 的动画，比如弹跳效果 */\n  animation-timing-function: cubic-bezier(0.5, 1.5, 0.5, 1.5);\n}\n\n::view-transition-old(detailed-card) {\n  /* 比如让旧卡片直接消失，不淡出 */\n  animation: none;\n  opacity: 0;\n}\n\n::view-transition-new(detailed-card) {\n  /* 比如让新卡片从下面飞入 */\n  animation: 300ms ease-out both slide-from-bottom;\n}\n\n@keyframes slide-from-bottom {\n  from {\n    transform: translateY(50px);\n    opacity: 0;\n  }\n}\n```\n\n**重要提示**：`view-transition-name` 的值在**同一时刻**必须是唯一的。如果在拍快照时发现有两个元素用了同一个名字，整个 View Transition 过程会失败（但 DOM 更新还是会执行）。\n\n**3. 处理进入和离开动画 (使用 `:only-child`)**\n\n有时候，某个元素只在新状态或旧状态存在（比如一个侧边栏导航只在某些页面有）。这时 `::view-transition-image-pair` 里就只有一个孩子 (`::view-transition-old` 或 `::view-transition-new`)。我们可以利用 CSS 的 `:only-child` 伪类来专门处理这种情况：\n\n```css\n.sidebar {\n  view-transition-name: sidebar;\n}\n\n/* 侧边栏进入动画 (新状态有，旧状态没有) */\n::view-transition-new(sidebar):only-child {\n  animation: slide-in 300ms ease-out;\n}\n\n/* 侧边栏离开动画 (旧状态有，新状态没有) */\n::view-transition-old(sidebar):only-child {\n  animation: slide-out 300ms ease-in;\n}\n\n/* 如果新旧状态都有侧边栏，默认的 group 位置/大小动画 + image-pair 淡入淡出可能就够了， */\n/* 或者你也可以单独为这种情况写动画 (不加 :only-child) */\n```\n\n## 六、更骚的操作：JavaScript 动画 (Web Animations API)\n\nCSS 动画很方便，但对于某些交互性强、需要动态计算的动画（比如规范里的那个鼠标点击位置圆形展开的例子），JavaScript 就派上用场了。\n\n最佳时机是等待 `transition.ready` Promise resolve 之后：\n\n```javascript\nfunction navigateWithCircularReveal(data, clickEvent) {\n  if (!document.startViewTransition) {\n    updateContent(data);\n    return;\n  }\n\n  // 获取点击位置\n  const x = clickEvent?.clientX ?? window.innerWidth / 2;\n  const y = clickEvent?.clientY ?? window.innerHeight / 2;\n  // 计算到最远角的距离作为最终半径\n  const endRadius = Math.hypot(\n    Math.max(x, window.innerWidth - x),\n    Math.max(y, window.innerHeight - y)\n  );\n\n  const transition = document.startViewTransition(() => updateContent(data));\n\n  // 等待伪元素准备好\n  transition.ready.then(() => {\n    // 使用 Web Animations API\n    document.documentElement.animate(\n      {\n        // 动画目标：从点击位置的小圆变成覆盖全屏的大圆\n        clipPath: [\n          `circle(0px at ${x}px ${y}px)`,\n          `circle(${endRadius}px at ${x}px ${y}px)`,\n        ],\n      },\n      {\n        duration: 500,\n        easing: \"ease-in\",\n        // 关键：指定动画作用在哪个伪元素上！\n        pseudoElement: \"::view-transition-new(root)\", // 让新内容以圆形揭示出来\n      }\n    );\n  });\n}\n```\n\n在这个例子里，我们还需要修改一下 CSS，阻止默认的淡入淡出，并让新旧内容直接叠加：\n\n```css\n/* 禁用默认动画 */\n::view-transition-old(root),\n::view-transition-new(root) {\n  animation: none;\n}\n\n/* 让新旧内容直接叠加，由 clip-path 控制谁可见 */\n::view-transition-image-pair(root) {\n  isolation: auto; /* 如果不需要混合模式，可以设为 auto */\n}\n\n::view-transition-new(root) {\n  mix-blend-mode: normal; /* 确保 JS 动画时混合模式正常 */\n  z-index: 1; /* 确保新内容在上面，被 clip-path 控制 */\n}\n\n::view-transition-old(root) {\n  mix-blend-mode: normal;\n  z-index: 0;\n}\n```\n\n## 七、注意事项与最佳实践\n\n1.  **`view-transition-name` 唯一性**：再强调一次，非常重要！\n2.  **`contain: layout` / `content-visibility: hidden`**：对于指定了 `view-transition-name` 的元素，加上 `contain: layout;` 或类似的 CSS（如 `contain: strict;` 或 `content-visibility: hidden;` 如果适用）可以帮助浏览器更好地隔离该元素的布局和渲染，提升性能。浏览器只需要知道这个元素的大小和位置，内部细节在快照时再处理。\n3.  **过渡是增强**：时刻记住 View Transitions 是锦上添花。即使动画失败或被跳过，核心功能（DOM 更新）也应该能正常工作。\n4.  **性能考量**：虽然浏览器会做优化，但截取快照、创建伪元素、运行动画还是有成本的。对于非常复杂的页面或大量的独立过渡元素，要注意测试性能。避免给太多小元素指定 `view-transition-name`。\n5.  **快照内容**：快照是渲染结果，包括 CSS 绘制的背景、伪元素内容等。但不包括 `\u003ciframe>` 内部的内容（除非同源）或某些插件内容。\n6.  **调试**：现代浏览器的开发者工具（如 Chrome DevTools）已经开始支持调试 View Transitions，可以检查伪元素树、查看应用的动画等。\n\n## 八、总结\n\nCSS View Transitions 绝对是近年来 Web 平台最令人兴奋的新特性之一。它精准地抓住了前端开发中关于页面切换动画的痛点，提供了一种优雅、高效且符合渐进增强理念的解决方案。\n\n其核心在于**分离 DOM 更新与视觉过渡**，通过**快照**和**伪元素树**，让浏览器接管了繁琐的过渡动画协调工作，开发者只需要：\n\n1.  用 `document.startViewTransition` 包裹你的 DOM 更新逻辑。\n2.  （可选）用 `view-transition-name` 标记需要独立动画的元素。\n3.  （可选）用 CSS 或 JavaScript (Web Animations API) 定制伪元素的动画效果。\n\n从此，打造原生 App 般丝滑的页面转场不再是难事。赶紧去试试吧，让你的网页也“纵享丝滑”！\n\n**参考资料：**\n\n- [W3C CSS View Transitions Module Level 1 Spec](https://www.w3.org/TR/css-view-transitions-1/)\n- [MDN 文档: View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API)\n- [Same-document view transitions for single-page applications](https://developer.chrome.com/docs/web-platform/view-transitions/same-document)\n- [github.com/demarketed/view-transitions-polyfill](https://github.com/demarketed/view-transitions-polyfill)\n- [`caniuse View Transitions API (single-document)`](https://caniuse.com/view-transitions)\n  - chrome 111+\n  - safari 18.0+\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.XrIATmm0.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.IQG_6ZON.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-vy2czm8u.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-0HRAW6Xj.js" as="script" type="text/javascript">
      </body>
    </html>