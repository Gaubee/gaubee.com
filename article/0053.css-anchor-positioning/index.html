<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.B0ujMgz2.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }

          main > p > img {
            max-width: 100%;
            margin: 0 auto;
            display: block;
          }
        </style><h1>CSS 锚定定位(Anchor Positioning)</h1><main><p>今天我们要聊一个 CSS 世界里正在悄然兴起，但可能彻底改变我们布局方式的“大杀器”——<strong>CSS Anchor Positioning</strong>（锚定定位）。</p>
<p>你有没有遇到过这样的场景？鼠标悬浮在一个按钮上，想弹出一个 tooltip；点击一个输入框，希望下方出现一个建议列表；或者实现一个下拉菜单，它得不偏不倚地对齐触发按钮。</p>
<p><img src="/img/css-anchor-positioning/bad-tooltip-posiction.webp" alt="想象一个按钮和旁边恼人的 tooltip 定位问题"></p>
<p>在过去，我们是怎么解决的？</p>
<ol>
<li><strong>DOM 结构依赖：</strong> 把 tooltip/下拉菜单硬塞到按钮的父元素里，然后用 <code>position: relative/absolute</code> 各种计算。但这要求 DOM 结构必须“配合”，不够灵活。</li>
<li><strong>JavaScript 大法：</strong> 获取按钮的位置和尺寸 (<code>getBoundingClientRect</code>)，计算 tooltip 应该放哪，监听滚动、窗口大小变化，重新计算... 心智负担重，性能还可能有问题。这感觉就像是为了拧个螺丝，结果造了台挖掘机。</li>
</ol>
<p>这些方法都透露着一种“不得已而为之”的无奈。我们只是想让一个元素 <em>相对</em> 于 <em>另一个</em> 元素定位，为什么就这么难？CSS 的 <code>position: absolute</code> 不是相对于包含块吗？如果我的触发元素和定位元素不在一个合适的包含块里，或者我压根不想关心它们的 DOM 结构关系呢？</p>
<p><strong>Anchor Positioning 的核心哲学：解放定位，打破束缚</strong></p>
<p>CSS Anchor Positioning 就像给 CSS 定位系统加了个“外挂”。它的核心思想简单粗暴但极其有效：</p>
<blockquote>
<p><strong>让一个元素（通常是绝对定位或固定定位的）可以显式地声明它想“锚定”到页面上的一个或多个其他元素，并基于这些“锚点”元素的位置和尺寸来定位或调整自身尺寸，而无需关心它们在 DOM 树中的关系或共同的包含块。</strong></p>
</blockquote>
<p>这就像在大海里航行，以前你只能靠附近的灯塔（包含块）定位，现在你可以直接抛锚（anchor）到任何你想停靠的岛屿（任意元素）旁边。这种<strong>解耦</strong>是革命性的：</p>
<ul>
<li><strong>DOM 结构自由：</strong> 你的 tooltip、popover 可以放在 <code>&#x3C;body></code> 下，或者任何你想放的地方，不再受父子关系的限制。</li>
<li><strong>CSS 驱动：</strong> 定位逻辑回归 CSS，减少甚至消除对 JS 的依赖，更符合关注点分离原则，性能也可能更好。</li>
<li><strong>智能避让：</strong> 内建了处理边缘碰撞、自动调整位置（fallback）的机制，让“气泡总在元素旁边，但又不会跑出屏幕”这种需求变得简单。</li>
</ul>
<p>听起来是不是很激动人心？别急，我们一步步来看它是怎么施展魔法的。</p>
<h3>入门：抛出第一个锚</h3>
<p>想象我们要给一个按钮 <code>.anchor-btn</code> 加一个 tooltip <code>.tooltip</code>。</p>
<p><strong>第一步：指定谁是锚点 (<code>anchor-name</code>)</strong></p>
<p>首先，得告诉 CSS，哪个元素是我们的“锚”。这通过 <code>anchor-name</code> 属性完成。它的值需要是 CSS 变量那种 <code>--</code> 开头的“虚线标识符”（dashed-ident）。</p>
<pre><code class="language-css">.anchor-btn {
  /* --my-anchor 就是这个锚点的名字 */
  anchor-name: --my-anchor;

  /* 其他样式... */
  padding: 10px 20px;
  border: 1px solid #ccc;
}
</code></pre>
<p><strong>第二步：设置需要定位的元素</strong></p>
<p>Tooltip 通常需要脱离文档流，所以我们给它 <code>position: fixed</code> 或 <code>absolute</code>。<code>fixed</code> 更省心，不用担心嵌套层级和 <code>transform</code> 干扰定位基准（虽然 Anchor Positioning 自身对 transform 和 scroll 有特殊处理，后面会提）。</p>
<pre><code class="language-css">.tooltip {
  position: fixed; /* 或者 absolute */
  background-color: #333;
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  /* 先隐藏，可能通过 JS 或 :hover/:focus 等显示 */
  display: none;
}
</code></pre>
<p><strong>第三步：连接锚点和定位元素 (默认锚点 <code>position-anchor</code>)</strong></p>
<p>现在，告诉 <code>.tooltip</code>，它默认应该参考哪个锚点。使用 <code>position-anchor</code> 属性。</p>
<pre><code class="language-css">.tooltip {
  position: fixed;
  /* ... 其他样式 ... */

  /* 默认情况下，我的位置参考 --my-anchor 这个锚点 */
  position-anchor: --my-anchor;
}
</code></pre>
<p><strong>第四步：使用 <code>anchor()</code> 函数定位</strong></p>
<p>最关键的一步来了！怎么具体定位呢？用 <code>anchor()</code> 函数！这个函数可以用在 <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code> 这些 inset 属性里。</p>
<p><code>anchor()</code> 函数的基本用法是 <code>anchor(&#x3C;anchor-side>)</code>。当 <code>position-anchor</code> 设置了默认锚点时，可以省略锚点名字。<code>&#x3C;anchor-side></code> 指的是你希望定位元素的哪条边对齐锚点元素的哪条边。</p>
<p>例如，我们想让 tooltip 的底部（<code>bottom</code>）对齐按钮的顶部（<code>top</code>）：</p>
<pre><code class="language-css">.tooltip {
  position: fixed;
  /* 消除默认 margin 行为，这个很重要，否则会有很多不符合预期的行为 */
  margin: 0;
  /* 设置锚定点 */
  position-anchor: --my-anchor;
  /* ... 其他样式 ... */

  /* 让我的 bottom 对齐 默认锚点 的 top */
  bottom: anchor(top);
  /* 水平方向，让我的左边 对齐 默认锚点 的左边 */
  left: anchor(left);

  /* 加一点偏移，让 tooltip 在按钮上方一点 */
  margin-bottom: 8px;
}
</code></pre>
<p><code>anchor()</code> 函数里的 <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code> 指的是锚点元素的<strong>边界</strong>。</p>
<p>还有两个特殊的关键字：<code>inside</code> 和 <code>outside</code>。
<code>inside</code> 指的是与 inset 属性<strong>相同</strong>的边，<code>outside</code> 指的是<strong>相对</strong>的边。</p>
<p>例如，<code>bottom: anchor(top)</code> 可以理解为：
我要设置 <code>bottom</code> 属性，它的值依赖于锚点的 <code>top</code> 边。</p>
<p>而 <code>bottom: anchor(outside)</code> 就有点意思了，用在 <code>bottom</code> 属性上时，<code>outside</code> 指的是锚点的 <code>top</code> 边。用在 <code>top</code> 属性上时，<code>outside</code> 指的是锚点的 <code>bottom</code> 边。它表示“贴着锚点的外面”。</p>
<p>所以，上面的 <code>bottom: anchor(top)</code> 其实更自然的写法是：</p>
<pre><code class="language-css">.tooltip {
  /* ... */
  /* 把我的 top 定位在 锚点 的 bottom (即按钮下方) */
  /* top: anchor(bottom); */

  /* 或者，让我的 bottom 定位在 锚点 的 top (即按钮上方) */
  bottom: anchor(top);

  /* 水平居中？可以让 tooltip 的中线对齐锚点的中线 */
  left: anchor(center);
  transform: translateX(-50%); /* CSS经典居中 */

  margin-bottom: 8px; /* 向上偏移 */
}
</code></pre>
<p><code>anchor()</code> 还可以接受百分比，<code>anchor(50%)</code> 或 <code>anchor(center)</code> 都代表锚点对应轴向的中心线。</p>
<pre><code class="language-html">&#x3C;button class="anchor-btn">Hover Me&#x3C;/button>
&#x3C;div class="tooltip" style="display: block;">I'm a tooltip!&#x3C;/div>
</code></pre>
<p><img src="/img/css-anchor-positioning/tooltip-above-center.webp" alt="基础锚定定位效果"></p>
<p>是不是很简单？没有 JS，没有复杂的 DOM 嵌套，CSS 自己搞定了！</p>
<h3>进阶：让定位更得心应手</h3>
<p><code>anchor()</code> 函数很强大，但每次都要写 <code>top</code>/<code>left</code> 有点繁琐。Anchor Positioning 提供了一些“语法糖”和增强功能。</p>
<p><strong>1. <code>position-area</code>：九宫格布局</strong></p>
<p>这是个超级方便的属性。它把锚点元素和它的“可用空间”（通常是视口或其包含块）想象成一个 3x3 的网格。你可以直接指定 tooltip 应该占据哪个格子。</p>
<p><img src="/img/css-anchor-positioning/position-area-grid.webp" alt="position-area 的 3x3 网格示意图"> (来自规范草案的图)</p>
<p>它的值可以是类似 <code>block-start</code>（块轴起点，通常是顶部）, <code>inline-end</code>（行轴终点，通常是右侧）, <code>center</code> 这样的关键字组合。</p>
<p>例如，把 tooltip 放在按钮上方居中，可以这样写：</p>
<pre><code class="language-css">.tooltip {
  position: fixed;
  position-anchor: --my-anchor;
  /* ... 其他样式 ... */

  /* 区域：块轴起点(top)，行轴中间(center) */
  position-area: block-start center;
  /* 默认对齐方式通常就不错，也可以用 align-self/justify-self 微调 */
}
</code></pre>
<p>想放右边中间？<code>position-area: center inline-end;</code>
想放左下角？<code>position-area: block-end inline-start;</code></p>
<p>它甚至支持跨越多行/列，如 <code>span-block-start</code> (从中间跨越到顶部)。</p>
<p><strong>2. <code>anchor-center</code>：居中对齐的新选择</strong></p>
<p>对于 <code>align-self</code> 和 <code>justify-self</code>，增加了一个新值 <code>anchor-center</code>。当使用 <code>position-area</code> 或希望在某个轴向上精确地对齐锚点的中心时，这个值非常有用。</p>
<pre><code class="language-css">.tooltip {
  /* ... */
  position-area: block-start; /* 放在上方区域 */
  justify-self: anchor-center; /* 水平方向对齐锚点中心 */
}
</code></pre>
<p><strong>3. <code>anchor-size()</code>：尺寸向锚点看齐</strong></p>
<p>有时候，我们希望定位元素的尺寸能跟随锚点变化。比如，下拉菜单的宽度应该和触发按钮一样宽。<code>anchor-size()</code> 函数应运而生！</p>
<pre><code class="language-css">.dropdown-menu {
  position: fixed;
  position-anchor: --my-trigger;
  /* ... */
  top: anchor(bottom);
  left: anchor(left);

  /* 让我的宽度等于 --my-trigger 锚点的宽度 */
  width: anchor-size(width);
  /* 或者用逻辑轴 */
  /* width: anchor-size(inline); */

  /* 高度也可以 */
  /* max-height: anchor-size(height) * 3; */
}
</code></pre>
<p><code>anchor-size()</code> 可以用在 <code>width</code>, <code>height</code>, <code>min-*</code>, <code>max-*</code> 等属性中，可以引用 <code>width</code>, <code>height</code>, <code>block</code>, <code>inline</code> (逻辑轴) 等。</p>
<h3>实战：处理真实世界的复杂性</h3>
<p>理想很丰满，现实很骨感。如果 tooltip 放在按钮上方会超出屏幕怎么办？如果滚动页面，锚点跑了，tooltip 会不会留在原地发呆？</p>
<p><strong>1. 边缘碰撞与回退 (<code>position-try-fallbacks</code>, <code>@position-try</code>)</strong></p>
<p>这是 Anchor Positioning 的精髓之一！当默认的定位方式导致元素溢出其容器（通常是视口）时，它可以自动尝试备选方案。</p>
<ul>
<li>
<p><strong>内置回退策略 (<code>flip-block</code>, <code>flip-inline</code>, <code>flip-start</code>)</strong>:
<code>position-try-fallbacks</code> 属性可以接受一些关键字，比如 <code>flip-block</code> 会尝试在块轴方向翻转（比如从上翻到下），<code>flip-inline</code> 则在行轴方向翻转（从左到右）。</p>
<pre><code class="language-css">.tooltip {
  /* ... */
  position-area: block-start; /* 默认放上面 */
  /* 如果上面放不下，尝试块级翻转（放到下面） */
  position-try-fallbacks: flip-block;
}
</code></pre>
</li>
<li>
<p><strong>自定义回退规则 (<code>@position-try</code>)</strong>:
你可以定义具名的回退样式集。</p>
<pre><code class="language-css">@position-try --fallback-bottom {
  position-area: block-end; /* 尝试放下面 */
  /* 可以定义更多样式调整 */
  background-color: lightcoral; /* 比如换个背景色提示 */
}

@position-try --fallback-right {
  position-area: inline-end;
}

.tooltip {
  /* ... */
  position-area: block-start; /* 默认放上面 */
  /* 尝试顺序：先用 --fallback-bottom 规则，再尝试行内翻转，再用 --fallback-right 规则 */
  position-try-fallbacks: --fallback-bottom, flip-inline, --fallback-right;
}
</code></pre>
</li>
<li>
<p><strong>回退顺序 (<code>position-try-order</code>)</strong>:
默认按 <code>position-try-fallbacks</code> 列表顺序尝试。但有时你希望优先选择<strong>空间更大</strong>的回退位置，可以用 <code>most-width</code>, <code>most-height</code>, <code>most-block-size</code>, <code>most-inline-size</code>。</p>
<pre><code class="language-css">.tooltip {
  /* ... */
  position-try-fallbacks: --try-top, --try-bottom, --try-left, --try-right;
  /* 优先选择高度最大的位置 */
  position-try-order: most-height;
}
</code></pre>
</li>
</ul>
<p><strong>2. 滚动与变换：性能与行为的权衡</strong></p>
<p>这是一个复杂但重要的话题。如果锚点在可滚动区域内，或者被 <code>transform</code> 了，定位元素怎么办？</p>
<ul>
<li><strong>基本原则：</strong> 为了性能，浏览器通常<strong>不会</strong>在滚动或 <code>transform</code> 改变时频繁重新计算锚点元素的精确布局。</li>
<li><strong>记住滚动偏移 (<code>remembered scroll offset</code>)：</strong> 浏览器会在某个时间点（比如元素首次显示或回退策略改变时）“记住”锚点相对于定位元素的滚动容器的滚动偏移量。后续定位会基于这个记住的值。</li>
<li><strong>默认锚点的特权：</strong> 如果定位元素只依赖<strong>默认锚点</strong> (<code>position-anchor</code> 指定的那个)，并且满足特定条件（比如用了 <code>anchor-center</code> 或 <code>position-area</code>），浏览器<strong>可以</strong>在滚动时<strong>平移</strong>定位元素，让它跟随默认锚点移动。这是一种性能友好的“补偿”(<code>compensate for scroll</code>)。</li>
<li><strong>多锚点或非默认锚点：</strong> 如果你用了多个 <code>anchor()</code> 指向不同滚动容器的锚点，或者依赖非默认锚点，滚动时它们的位置可能就不再精确跟随了（只跟随非滚动部分的移动）。</li>
<li><strong><code>transform</code> 的影响：</strong> 规范草案目前提到，默认情况下，锚点上的 <code>transform</code> <strong>不影响</strong> <code>anchor()</code> 函数的计算结果（Issue 1）。这可能会在未来改变。</li>
</ul>
<p>简单说：尽量让你的主要定位逻辑依赖默认锚点，可以获得更好的滚动跟随效果。对于复杂的多锚点场景，滚动时的行为可能没那么“实时”。</p>
<p><strong>3. 条件隐藏 (<code>position-visibility</code>)</strong></p>
<p>有时候，如果锚点无效、不可见，或者即使尝试了所有回退方案，定位元素仍然溢出，我们可能希望直接隐藏它。<code>position-visibility</code> 属性就是干这个的。</p>
<pre><code class="language-css">.tooltip {
  /* ... */
  /* 默认值是 anchors-visible，如果锚点不可见（比如被滚动隐藏了）就自动隐藏 */
  /* position-visibility: anchors-visible; */

  /* 如果所有回退都试过后还溢出，就隐藏 */
  position-visibility: no-overflow;

  /* 如果有必须的锚点（比如 anchor() 没提供 fallback 值）无效，就隐藏 */
  /* position-visibility: anchors-valid; */

  /* 组合使用 */
  position-visibility: anchors-valid no-overflow;
}
</code></pre>
<h3>高级话题：作用域、隐式锚点</h3>
<ul>
<li>
<p><strong><code>anchor-scope</code>：避免命名冲突</strong>
在组件化开发中，如果你在列表的每个 <code>&#x3C;li></code> 里都用了 <code>anchor-name: --item-anchor</code>，那所有 <code>&#x3C;li></code> 里的定位元素都会锚定到<strong>最后一个</strong> <code>&#x3C;li></code> 上！<code>anchor-scope</code> 可以限制锚点名称的查找范围。</p>
<pre><code class="language-css">li {
  /* 这个锚点名字只在 li 内部及其后代中有效 */
  anchor-name: --item-anchor;
  anchor-scope: --item-anchor;
  position: relative; /* 创建层叠上下文可能也有帮助 */
}
li .popup {
  position: absolute;
  position-anchor: --item-anchor;
  top: anchor(bottom);
  /* ... */
}
</code></pre>
</li>
<li>
<p><strong>隐式锚点 (<code>auto</code>)</strong>
某些 HTML API（比如未来的 Popover API）可能会自动建立锚定关系。比如，触发 popover 的按钮自动成为该 popover 的“隐式锚点”。这时，你可以用 <code>position-anchor: auto;</code> 或者在 <code>anchor()</code>/<code>anchor-size()</code> 中省略锚点名来引用它。</p>
</li>
</ul>
<h3>别忘了可访问性 (Accessibility)</h3>
<p>重要的事情说三遍：Anchor Positioning 是<strong>纯视觉</strong>的！它在视觉上把两个元素关联起来，但<strong>不会</strong>自动建立它们之间的语义联系。</p>
<p>屏幕阅读器等辅助技术无法理解这种视觉关联。所以，你必须：</p>
<ul>
<li>使用 <code>aria-describedby</code>, <code>aria-details</code> 等 ARIA 属性，在 HTML 中明确两者关系。</li>
<li>确保合理的焦点管理和键盘导航。</li>
</ul>
<p>好消息是，像 Popover API 这样的原生 HTML 功能，在提供隐式锚点的同时，通常也会处理好相关的可访问性问题。</p>
<h3>总结：未来已来？</h3>
<p>CSS Anchor Positioning 无疑是近年来 CSS 布局领域最激动人心的提案之一。它直击了 Web 开发中长期存在的定位痛点，提供了一种更声明式、更灵活、更强大的解决方案。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>DOM 解耦：</strong> 布局不再受限于 HTML 结构。</li>
<li><strong>CSS 驱动：</strong> 减少 JS 依赖，代码更清晰。</li>
<li><strong>智能回退：</strong> 内建边缘检测和位置调整。</li>
<li><strong>强大灵活：</strong> <code>anchor()</code>, <code>anchor-size()</code>, <code>position-area</code> 提供了丰富的控制。</li>
</ul>
<p><strong>注意事项/挑战：</strong></p>
<ul>
<li><strong>新规范：</strong> 目前仍是 Editor's Draft（编辑草案），API 可能会变化，浏览器支持需要关注（通常需要开启实验性标志）。(写作时基于 2024 年 10 月草案)</li>
<li><strong>滚动/变换行为：</strong> 涉及性能权衡，行为需要理解清楚。</li>
<li><strong>可访问性：</strong> 需要开发者额外关注。</li>
<li><strong>学习曲线：</strong> 虽然入门简单，但回退、滚动等机制需要深入理解。</li>
</ul>
<p>总的来说，Anchor Positioning 描绘了一个美好的未来：开发者可以更专注于内容和语义，把复杂的定位逻辑交还给 CSS。虽然离全面普及还有距离，但了解它、尝试它，绝对能让你在未来的 Web 布局中占得先机。</p>
<p>告别那些为了定位而写的 JS "屎山"吧，拥抱 CSS 的新可能！你觉得这个新特性怎么样？欢迎在评论区留下你的看法！</p>
<hr>
<p>希望这篇模仿张鑫旭老师风格的文章能帮助你理解 CSS Anchor Positioning！记得，实际运用时一定要查阅最新的规范文档和浏览器兼容性信息。</p>
<p>参考文献：</p>
<ol>
<li><a href="https://drafts.csswg.org/css-anchor-position-1/">CSS Anchor Positioning - Editor’s Draft, 12 October 2024</a></li>
</ol></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0053.css-anchor-positioning"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0053.css-anchor-positioning.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"title":"CSS 锚定定位(Anchor Positioning)","date":"!Date:2025-04-06T16:29:44.973Z","updated":"!Date:2025-04-06T16:34:20.423Z"},"metadata":{"title":"CSS 锚定定位(Anchor Positioning)","date":"!Date:2025-04-06T16:29:44.973Z","updated":"!Date:2025-04-06T16:34:20.423Z","id":"0053.css-anchor-positioning","createdAt":"!Date:2025-04-06T16:29:44.973Z","updatedAt":"!Date:2025-04-06T16:34:20.423Z","tags":[]},"htmlContent":"\u003cp>今天我们要聊一个 CSS 世界里正在悄然兴起，但可能彻底改变我们布局方式的“大杀器”——\u003cstrong>CSS Anchor Positioning\u003c/strong>（锚定定位）。\u003c/p>\n\u003cp>你有没有遇到过这样的场景？鼠标悬浮在一个按钮上，想弹出一个 tooltip；点击一个输入框，希望下方出现一个建议列表；或者实现一个下拉菜单，它得不偏不倚地对齐触发按钮。\u003c/p>\n\u003cp>\u003cimg src=\"/img/css-anchor-positioning/bad-tooltip-posiction.webp\" alt=\"想象一个按钮和旁边恼人的 tooltip 定位问题\">\u003c/p>\n\u003cp>在过去，我们是怎么解决的？\u003c/p>\n\u003col>\n\u003cli>\u003cstrong>DOM 结构依赖：\u003c/strong> 把 tooltip/下拉菜单硬塞到按钮的父元素里，然后用 \u003ccode>position: relative/absolute\u003c/code> 各种计算。但这要求 DOM 结构必须“配合”，不够灵活。\u003c/li>\n\u003cli>\u003cstrong>JavaScript 大法：\u003c/strong> 获取按钮的位置和尺寸 (\u003ccode>getBoundingClientRect\u003c/code>)，计算 tooltip 应该放哪，监听滚动、窗口大小变化，重新计算... 心智负担重，性能还可能有问题。这感觉就像是为了拧个螺丝，结果造了台挖掘机。\u003c/li>\n\u003c/ol>\n\u003cp>这些方法都透露着一种“不得已而为之”的无奈。我们只是想让一个元素 \u003cem>相对\u003c/em> 于 \u003cem>另一个\u003c/em> 元素定位，为什么就这么难？CSS 的 \u003ccode>position: absolute\u003c/code> 不是相对于包含块吗？如果我的触发元素和定位元素不在一个合适的包含块里，或者我压根不想关心它们的 DOM 结构关系呢？\u003c/p>\n\u003cp>\u003cstrong>Anchor Positioning 的核心哲学：解放定位，打破束缚\u003c/strong>\u003c/p>\n\u003cp>CSS Anchor Positioning 就像给 CSS 定位系统加了个“外挂”。它的核心思想简单粗暴但极其有效：\u003c/p>\n\u003cblockquote>\n\u003cp>\u003cstrong>让一个元素（通常是绝对定位或固定定位的）可以显式地声明它想“锚定”到页面上的一个或多个其他元素，并基于这些“锚点”元素的位置和尺寸来定位或调整自身尺寸，而无需关心它们在 DOM 树中的关系或共同的包含块。\u003c/strong>\u003c/p>\n\u003c/blockquote>\n\u003cp>这就像在大海里航行，以前你只能靠附近的灯塔（包含块）定位，现在你可以直接抛锚（anchor）到任何你想停靠的岛屿（任意元素）旁边。这种\u003cstrong>解耦\u003c/strong>是革命性的：\u003c/p>\n\u003cul>\n\u003cli>\u003cstrong>DOM 结构自由：\u003c/strong> 你的 tooltip、popover 可以放在 \u003ccode>&#x3C;body>\u003c/code> 下，或者任何你想放的地方，不再受父子关系的限制。\u003c/li>\n\u003cli>\u003cstrong>CSS 驱动：\u003c/strong> 定位逻辑回归 CSS，减少甚至消除对 JS 的依赖，更符合关注点分离原则，性能也可能更好。\u003c/li>\n\u003cli>\u003cstrong>智能避让：\u003c/strong> 内建了处理边缘碰撞、自动调整位置（fallback）的机制，让“气泡总在元素旁边，但又不会跑出屏幕”这种需求变得简单。\u003c/li>\n\u003c/ul>\n\u003cp>听起来是不是很激动人心？别急，我们一步步来看它是怎么施展魔法的。\u003c/p>\n\u003ch3>入门：抛出第一个锚\u003c/h3>\n\u003cp>想象我们要给一个按钮 \u003ccode>.anchor-btn\u003c/code> 加一个 tooltip \u003ccode>.tooltip\u003c/code>。\u003c/p>\n\u003cp>\u003cstrong>第一步：指定谁是锚点 (\u003ccode>anchor-name\u003c/code>)\u003c/strong>\u003c/p>\n\u003cp>首先，得告诉 CSS，哪个元素是我们的“锚”。这通过 \u003ccode>anchor-name\u003c/code> 属性完成。它的值需要是 CSS 变量那种 \u003ccode>--\u003c/code> 开头的“虚线标识符”（dashed-ident）。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.anchor-btn {\n  /* --my-anchor 就是这个锚点的名字 */\n  anchor-name: --my-anchor;\n\n  /* 其他样式... */\n  padding: 10px 20px;\n  border: 1px solid #ccc;\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>第二步：设置需要定位的元素\u003c/strong>\u003c/p>\n\u003cp>Tooltip 通常需要脱离文档流，所以我们给它 \u003ccode>position: fixed\u003c/code> 或 \u003ccode>absolute\u003c/code>。\u003ccode>fixed\u003c/code> 更省心，不用担心嵌套层级和 \u003ccode>transform\u003c/code> 干扰定位基准（虽然 Anchor Positioning 自身对 transform 和 scroll 有特殊处理，后面会提）。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  position: fixed; /* 或者 absolute */\n  background-color: #333;\n  color: white;\n  padding: 5px 10px;\n  border-radius: 4px;\n  /* 先隐藏，可能通过 JS 或 :hover/:focus 等显示 */\n  display: none;\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>第三步：连接锚点和定位元素 (默认锚点 \u003ccode>position-anchor\u003c/code>)\u003c/strong>\u003c/p>\n\u003cp>现在，告诉 \u003ccode>.tooltip\u003c/code>，它默认应该参考哪个锚点。使用 \u003ccode>position-anchor\u003c/code> 属性。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  position: fixed;\n  /* ... 其他样式 ... */\n\n  /* 默认情况下，我的位置参考 --my-anchor 这个锚点 */\n  position-anchor: --my-anchor;\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>第四步：使用 \u003ccode>anchor()\u003c/code> 函数定位\u003c/strong>\u003c/p>\n\u003cp>最关键的一步来了！怎么具体定位呢？用 \u003ccode>anchor()\u003c/code> 函数！这个函数可以用在 \u003ccode>top\u003c/code>, \u003ccode>left\u003c/code>, \u003ccode>right\u003c/code>, \u003ccode>bottom\u003c/code> 这些 inset 属性里。\u003c/p>\n\u003cp>\u003ccode>anchor()\u003c/code> 函数的基本用法是 \u003ccode>anchor(&#x3C;anchor-side>)\u003c/code>。当 \u003ccode>position-anchor\u003c/code> 设置了默认锚点时，可以省略锚点名字。\u003ccode>&#x3C;anchor-side>\u003c/code> 指的是你希望定位元素的哪条边对齐锚点元素的哪条边。\u003c/p>\n\u003cp>例如，我们想让 tooltip 的底部（\u003ccode>bottom\u003c/code>）对齐按钮的顶部（\u003ccode>top\u003c/code>）：\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  position: fixed;\n  /* 消除默认 margin 行为，这个很重要，否则会有很多不符合预期的行为 */\n  margin: 0;\n  /* 设置锚定点 */\n  position-anchor: --my-anchor;\n  /* ... 其他样式 ... */\n\n  /* 让我的 bottom 对齐 默认锚点 的 top */\n  bottom: anchor(top);\n  /* 水平方向，让我的左边 对齐 默认锚点 的左边 */\n  left: anchor(left);\n\n  /* 加一点偏移，让 tooltip 在按钮上方一点 */\n  margin-bottom: 8px;\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003ccode>anchor()\u003c/code> 函数里的 \u003ccode>top\u003c/code>, \u003ccode>left\u003c/code>, \u003ccode>right\u003c/code>, \u003ccode>bottom\u003c/code> 指的是锚点元素的\u003cstrong>边界\u003c/strong>。\u003c/p>\n\u003cp>还有两个特殊的关键字：\u003ccode>inside\u003c/code> 和 \u003ccode>outside\u003c/code>。\n\u003ccode>inside\u003c/code> 指的是与 inset 属性\u003cstrong>相同\u003c/strong>的边，\u003ccode>outside\u003c/code> 指的是\u003cstrong>相对\u003c/strong>的边。\u003c/p>\n\u003cp>例如，\u003ccode>bottom: anchor(top)\u003c/code> 可以理解为：\n我要设置 \u003ccode>bottom\u003c/code> 属性，它的值依赖于锚点的 \u003ccode>top\u003c/code> 边。\u003c/p>\n\u003cp>而 \u003ccode>bottom: anchor(outside)\u003c/code> 就有点意思了，用在 \u003ccode>bottom\u003c/code> 属性上时，\u003ccode>outside\u003c/code> 指的是锚点的 \u003ccode>top\u003c/code> 边。用在 \u003ccode>top\u003c/code> 属性上时，\u003ccode>outside\u003c/code> 指的是锚点的 \u003ccode>bottom\u003c/code> 边。它表示“贴着锚点的外面”。\u003c/p>\n\u003cp>所以，上面的 \u003ccode>bottom: anchor(top)\u003c/code> 其实更自然的写法是：\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  /* ... */\n  /* 把我的 top 定位在 锚点 的 bottom (即按钮下方) */\n  /* top: anchor(bottom); */\n\n  /* 或者，让我的 bottom 定位在 锚点 的 top (即按钮上方) */\n  bottom: anchor(top);\n\n  /* 水平居中？可以让 tooltip 的中线对齐锚点的中线 */\n  left: anchor(center);\n  transform: translateX(-50%); /* CSS经典居中 */\n\n  margin-bottom: 8px; /* 向上偏移 */\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003ccode>anchor()\u003c/code> 还可以接受百分比，\u003ccode>anchor(50%)\u003c/code> 或 \u003ccode>anchor(center)\u003c/code> 都代表锚点对应轴向的中心线。\u003c/p>\n\u003cpre>\u003ccode class=\"language-html\">&#x3C;button class=\"anchor-btn\">Hover Me&#x3C;/button>\n&#x3C;div class=\"tooltip\" style=\"display: block;\">I'm a tooltip!&#x3C;/div>\n\u003c/code>\u003c/pre>\n\u003cp>\u003cimg src=\"/img/css-anchor-positioning/tooltip-above-center.webp\" alt=\"基础锚定定位效果\">\u003c/p>\n\u003cp>是不是很简单？没有 JS，没有复杂的 DOM 嵌套，CSS 自己搞定了！\u003c/p>\n\u003ch3>进阶：让定位更得心应手\u003c/h3>\n\u003cp>\u003ccode>anchor()\u003c/code> 函数很强大，但每次都要写 \u003ccode>top\u003c/code>/\u003ccode>left\u003c/code> 有点繁琐。Anchor Positioning 提供了一些“语法糖”和增强功能。\u003c/p>\n\u003cp>\u003cstrong>1. \u003ccode>position-area\u003c/code>：九宫格布局\u003c/strong>\u003c/p>\n\u003cp>这是个超级方便的属性。它把锚点元素和它的“可用空间”（通常是视口或其包含块）想象成一个 3x3 的网格。你可以直接指定 tooltip 应该占据哪个格子。\u003c/p>\n\u003cp>\u003cimg src=\"/img/css-anchor-positioning/position-area-grid.webp\" alt=\"position-area 的 3x3 网格示意图\"> (来自规范草案的图)\u003c/p>\n\u003cp>它的值可以是类似 \u003ccode>block-start\u003c/code>（块轴起点，通常是顶部）, \u003ccode>inline-end\u003c/code>（行轴终点，通常是右侧）, \u003ccode>center\u003c/code> 这样的关键字组合。\u003c/p>\n\u003cp>例如，把 tooltip 放在按钮上方居中，可以这样写：\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  position: fixed;\n  position-anchor: --my-anchor;\n  /* ... 其他样式 ... */\n\n  /* 区域：块轴起点(top)，行轴中间(center) */\n  position-area: block-start center;\n  /* 默认对齐方式通常就不错，也可以用 align-self/justify-self 微调 */\n}\n\u003c/code>\u003c/pre>\n\u003cp>想放右边中间？\u003ccode>position-area: center inline-end;\u003c/code>\n想放左下角？\u003ccode>position-area: block-end inline-start;\u003c/code>\u003c/p>\n\u003cp>它甚至支持跨越多行/列，如 \u003ccode>span-block-start\u003c/code> (从中间跨越到顶部)。\u003c/p>\n\u003cp>\u003cstrong>2. \u003ccode>anchor-center\u003c/code>：居中对齐的新选择\u003c/strong>\u003c/p>\n\u003cp>对于 \u003ccode>align-self\u003c/code> 和 \u003ccode>justify-self\u003c/code>，增加了一个新值 \u003ccode>anchor-center\u003c/code>。当使用 \u003ccode>position-area\u003c/code> 或希望在某个轴向上精确地对齐锚点的中心时，这个值非常有用。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  /* ... */\n  position-area: block-start; /* 放在上方区域 */\n  justify-self: anchor-center; /* 水平方向对齐锚点中心 */\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>3. \u003ccode>anchor-size()\u003c/code>：尺寸向锚点看齐\u003c/strong>\u003c/p>\n\u003cp>有时候，我们希望定位元素的尺寸能跟随锚点变化。比如，下拉菜单的宽度应该和触发按钮一样宽。\u003ccode>anchor-size()\u003c/code> 函数应运而生！\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.dropdown-menu {\n  position: fixed;\n  position-anchor: --my-trigger;\n  /* ... */\n  top: anchor(bottom);\n  left: anchor(left);\n\n  /* 让我的宽度等于 --my-trigger 锚点的宽度 */\n  width: anchor-size(width);\n  /* 或者用逻辑轴 */\n  /* width: anchor-size(inline); */\n\n  /* 高度也可以 */\n  /* max-height: anchor-size(height) * 3; */\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003ccode>anchor-size()\u003c/code> 可以用在 \u003ccode>width\u003c/code>, \u003ccode>height\u003c/code>, \u003ccode>min-*\u003c/code>, \u003ccode>max-*\u003c/code> 等属性中，可以引用 \u003ccode>width\u003c/code>, \u003ccode>height\u003c/code>, \u003ccode>block\u003c/code>, \u003ccode>inline\u003c/code> (逻辑轴) 等。\u003c/p>\n\u003ch3>实战：处理真实世界的复杂性\u003c/h3>\n\u003cp>理想很丰满，现实很骨感。如果 tooltip 放在按钮上方会超出屏幕怎么办？如果滚动页面，锚点跑了，tooltip 会不会留在原地发呆？\u003c/p>\n\u003cp>\u003cstrong>1. 边缘碰撞与回退 (\u003ccode>position-try-fallbacks\u003c/code>, \u003ccode>@position-try\u003c/code>)\u003c/strong>\u003c/p>\n\u003cp>这是 Anchor Positioning 的精髓之一！当默认的定位方式导致元素溢出其容器（通常是视口）时，它可以自动尝试备选方案。\u003c/p>\n\u003cul>\n\u003cli>\n\u003cp>\u003cstrong>内置回退策略 (\u003ccode>flip-block\u003c/code>, \u003ccode>flip-inline\u003c/code>, \u003ccode>flip-start\u003c/code>)\u003c/strong>:\n\u003ccode>position-try-fallbacks\u003c/code> 属性可以接受一些关键字，比如 \u003ccode>flip-block\u003c/code> 会尝试在块轴方向翻转（比如从上翻到下），\u003ccode>flip-inline\u003c/code> 则在行轴方向翻转（从左到右）。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  /* ... */\n  position-area: block-start; /* 默认放上面 */\n  /* 如果上面放不下，尝试块级翻转（放到下面） */\n  position-try-fallbacks: flip-block;\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>自定义回退规则 (\u003ccode>@position-try\u003c/code>)\u003c/strong>:\n你可以定义具名的回退样式集。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">@position-try --fallback-bottom {\n  position-area: block-end; /* 尝试放下面 */\n  /* 可以定义更多样式调整 */\n  background-color: lightcoral; /* 比如换个背景色提示 */\n}\n\n@position-try --fallback-right {\n  position-area: inline-end;\n}\n\n.tooltip {\n  /* ... */\n  position-area: block-start; /* 默认放上面 */\n  /* 尝试顺序：先用 --fallback-bottom 规则，再尝试行内翻转，再用 --fallback-right 规则 */\n  position-try-fallbacks: --fallback-bottom, flip-inline, --fallback-right;\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>回退顺序 (\u003ccode>position-try-order\u003c/code>)\u003c/strong>:\n默认按 \u003ccode>position-try-fallbacks\u003c/code> 列表顺序尝试。但有时你希望优先选择\u003cstrong>空间更大\u003c/strong>的回退位置，可以用 \u003ccode>most-width\u003c/code>, \u003ccode>most-height\u003c/code>, \u003ccode>most-block-size\u003c/code>, \u003ccode>most-inline-size\u003c/code>。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  /* ... */\n  position-try-fallbacks: --try-top, --try-bottom, --try-left, --try-right;\n  /* 优先选择高度最大的位置 */\n  position-try-order: most-height;\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003c/ul>\n\u003cp>\u003cstrong>2. 滚动与变换：性能与行为的权衡\u003c/strong>\u003c/p>\n\u003cp>这是一个复杂但重要的话题。如果锚点在可滚动区域内，或者被 \u003ccode>transform\u003c/code> 了，定位元素怎么办？\u003c/p>\n\u003cul>\n\u003cli>\u003cstrong>基本原则：\u003c/strong> 为了性能，浏览器通常\u003cstrong>不会\u003c/strong>在滚动或 \u003ccode>transform\u003c/code> 改变时频繁重新计算锚点元素的精确布局。\u003c/li>\n\u003cli>\u003cstrong>记住滚动偏移 (\u003ccode>remembered scroll offset\u003c/code>)：\u003c/strong> 浏览器会在某个时间点（比如元素首次显示或回退策略改变时）“记住”锚点相对于定位元素的滚动容器的滚动偏移量。后续定位会基于这个记住的值。\u003c/li>\n\u003cli>\u003cstrong>默认锚点的特权：\u003c/strong> 如果定位元素只依赖\u003cstrong>默认锚点\u003c/strong> (\u003ccode>position-anchor\u003c/code> 指定的那个)，并且满足特定条件（比如用了 \u003ccode>anchor-center\u003c/code> 或 \u003ccode>position-area\u003c/code>），浏览器\u003cstrong>可以\u003c/strong>在滚动时\u003cstrong>平移\u003c/strong>定位元素，让它跟随默认锚点移动。这是一种性能友好的“补偿”(\u003ccode>compensate for scroll\u003c/code>)。\u003c/li>\n\u003cli>\u003cstrong>多锚点或非默认锚点：\u003c/strong> 如果你用了多个 \u003ccode>anchor()\u003c/code> 指向不同滚动容器的锚点，或者依赖非默认锚点，滚动时它们的位置可能就不再精确跟随了（只跟随非滚动部分的移动）。\u003c/li>\n\u003cli>\u003cstrong>\u003ccode>transform\u003c/code> 的影响：\u003c/strong> 规范草案目前提到，默认情况下，锚点上的 \u003ccode>transform\u003c/code> \u003cstrong>不影响\u003c/strong> \u003ccode>anchor()\u003c/code> 函数的计算结果（Issue 1）。这可能会在未来改变。\u003c/li>\n\u003c/ul>\n\u003cp>简单说：尽量让你的主要定位逻辑依赖默认锚点，可以获得更好的滚动跟随效果。对于复杂的多锚点场景，滚动时的行为可能没那么“实时”。\u003c/p>\n\u003cp>\u003cstrong>3. 条件隐藏 (\u003ccode>position-visibility\u003c/code>)\u003c/strong>\u003c/p>\n\u003cp>有时候，如果锚点无效、不可见，或者即使尝试了所有回退方案，定位元素仍然溢出，我们可能希望直接隐藏它。\u003ccode>position-visibility\u003c/code> 属性就是干这个的。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">.tooltip {\n  /* ... */\n  /* 默认值是 anchors-visible，如果锚点不可见（比如被滚动隐藏了）就自动隐藏 */\n  /* position-visibility: anchors-visible; */\n\n  /* 如果所有回退都试过后还溢出，就隐藏 */\n  position-visibility: no-overflow;\n\n  /* 如果有必须的锚点（比如 anchor() 没提供 fallback 值）无效，就隐藏 */\n  /* position-visibility: anchors-valid; */\n\n  /* 组合使用 */\n  position-visibility: anchors-valid no-overflow;\n}\n\u003c/code>\u003c/pre>\n\u003ch3>高级话题：作用域、隐式锚点\u003c/h3>\n\u003cul>\n\u003cli>\n\u003cp>\u003cstrong>\u003ccode>anchor-scope\u003c/code>：避免命名冲突\u003c/strong>\n在组件化开发中，如果你在列表的每个 \u003ccode>&#x3C;li>\u003c/code> 里都用了 \u003ccode>anchor-name: --item-anchor\u003c/code>，那所有 \u003ccode>&#x3C;li>\u003c/code> 里的定位元素都会锚定到\u003cstrong>最后一个\u003c/strong> \u003ccode>&#x3C;li>\u003c/code> 上！\u003ccode>anchor-scope\u003c/code> 可以限制锚点名称的查找范围。\u003c/p>\n\u003cpre>\u003ccode class=\"language-css\">li {\n  /* 这个锚点名字只在 li 内部及其后代中有效 */\n  anchor-name: --item-anchor;\n  anchor-scope: --item-anchor;\n  position: relative; /* 创建层叠上下文可能也有帮助 */\n}\nli .popup {\n  position: absolute;\n  position-anchor: --item-anchor;\n  top: anchor(bottom);\n  /* ... */\n}\n\u003c/code>\u003c/pre>\n\u003c/li>\n\u003cli>\n\u003cp>\u003cstrong>隐式锚点 (\u003ccode>auto\u003c/code>)\u003c/strong>\n某些 HTML API（比如未来的 Popover API）可能会自动建立锚定关系。比如，触发 popover 的按钮自动成为该 popover 的“隐式锚点”。这时，你可以用 \u003ccode>position-anchor: auto;\u003c/code> 或者在 \u003ccode>anchor()\u003c/code>/\u003ccode>anchor-size()\u003c/code> 中省略锚点名来引用它。\u003c/p>\n\u003c/li>\n\u003c/ul>\n\u003ch3>别忘了可访问性 (Accessibility)\u003c/h3>\n\u003cp>重要的事情说三遍：Anchor Positioning 是\u003cstrong>纯视觉\u003c/strong>的！它在视觉上把两个元素关联起来，但\u003cstrong>不会\u003c/strong>自动建立它们之间的语义联系。\u003c/p>\n\u003cp>屏幕阅读器等辅助技术无法理解这种视觉关联。所以，你必须：\u003c/p>\n\u003cul>\n\u003cli>使用 \u003ccode>aria-describedby\u003c/code>, \u003ccode>aria-details\u003c/code> 等 ARIA 属性，在 HTML 中明确两者关系。\u003c/li>\n\u003cli>确保合理的焦点管理和键盘导航。\u003c/li>\n\u003c/ul>\n\u003cp>好消息是，像 Popover API 这样的原生 HTML 功能，在提供隐式锚点的同时，通常也会处理好相关的可访问性问题。\u003c/p>\n\u003ch3>总结：未来已来？\u003c/h3>\n\u003cp>CSS Anchor Positioning 无疑是近年来 CSS 布局领域最激动人心的提案之一。它直击了 Web 开发中长期存在的定位痛点，提供了一种更声明式、更灵活、更强大的解决方案。\u003c/p>\n\u003cp>\u003cstrong>优点：\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\u003cstrong>DOM 解耦：\u003c/strong> 布局不再受限于 HTML 结构。\u003c/li>\n\u003cli>\u003cstrong>CSS 驱动：\u003c/strong> 减少 JS 依赖，代码更清晰。\u003c/li>\n\u003cli>\u003cstrong>智能回退：\u003c/strong> 内建边缘检测和位置调整。\u003c/li>\n\u003cli>\u003cstrong>强大灵活：\u003c/strong> \u003ccode>anchor()\u003c/code>, \u003ccode>anchor-size()\u003c/code>, \u003ccode>position-area\u003c/code> 提供了丰富的控制。\u003c/li>\n\u003c/ul>\n\u003cp>\u003cstrong>注意事项/挑战：\u003c/strong>\u003c/p>\n\u003cul>\n\u003cli>\u003cstrong>新规范：\u003c/strong> 目前仍是 Editor's Draft（编辑草案），API 可能会变化，浏览器支持需要关注（通常需要开启实验性标志）。(写作时基于 2024 年 10 月草案)\u003c/li>\n\u003cli>\u003cstrong>滚动/变换行为：\u003c/strong> 涉及性能权衡，行为需要理解清楚。\u003c/li>\n\u003cli>\u003cstrong>可访问性：\u003c/strong> 需要开发者额外关注。\u003c/li>\n\u003cli>\u003cstrong>学习曲线：\u003c/strong> 虽然入门简单，但回退、滚动等机制需要深入理解。\u003c/li>\n\u003c/ul>\n\u003cp>总的来说，Anchor Positioning 描绘了一个美好的未来：开发者可以更专注于内容和语义，把复杂的定位逻辑交还给 CSS。虽然离全面普及还有距离，但了解它、尝试它，绝对能让你在未来的 Web 布局中占得先机。\u003c/p>\n\u003cp>告别那些为了定位而写的 JS \"屎山\"吧，拥抱 CSS 的新可能！你觉得这个新特性怎么样？欢迎在评论区留下你的看法！\u003c/p>\n\u003chr>\n\u003cp>希望这篇模仿张鑫旭老师风格的文章能帮助你理解 CSS Anchor Positioning！记得，实际运用时一定要查阅最新的规范文档和浏览器兼容性信息。\u003c/p>\n\u003cp>参考文献：\u003c/p>\n\u003col>\n\u003cli>\u003ca href=\"https://drafts.csswg.org/css-anchor-position-1/\">CSS Anchor Positioning - Editor’s Draft, 12 October 2024\u003c/a>\u003c/li>\n\u003c/ol>","markdownContent":"\n今天我们要聊一个 CSS 世界里正在悄然兴起，但可能彻底改变我们布局方式的“大杀器”——**CSS Anchor Positioning**（锚定定位）。\n\n你有没有遇到过这样的场景？鼠标悬浮在一个按钮上，想弹出一个 tooltip；点击一个输入框，希望下方出现一个建议列表；或者实现一个下拉菜单，它得不偏不倚地对齐触发按钮。\n\n![想象一个按钮和旁边恼人的 tooltip 定位问题](/img/css-anchor-positioning/bad-tooltip-posiction.webp)\n\n在过去，我们是怎么解决的？\n\n1.  **DOM 结构依赖：** 把 tooltip/下拉菜单硬塞到按钮的父元素里，然后用 `position: relative/absolute` 各种计算。但这要求 DOM 结构必须“配合”，不够灵活。\n2.  **JavaScript 大法：** 获取按钮的位置和尺寸 (`getBoundingClientRect`)，计算 tooltip 应该放哪，监听滚动、窗口大小变化，重新计算... 心智负担重，性能还可能有问题。这感觉就像是为了拧个螺丝，结果造了台挖掘机。\n\n这些方法都透露着一种“不得已而为之”的无奈。我们只是想让一个元素 _相对_ 于 _另一个_ 元素定位，为什么就这么难？CSS 的 `position: absolute` 不是相对于包含块吗？如果我的触发元素和定位元素不在一个合适的包含块里，或者我压根不想关心它们的 DOM 结构关系呢？\n\n**Anchor Positioning 的核心哲学：解放定位，打破束缚**\n\nCSS Anchor Positioning 就像给 CSS 定位系统加了个“外挂”。它的核心思想简单粗暴但极其有效：\n\n> **让一个元素（通常是绝对定位或固定定位的）可以显式地声明它想“锚定”到页面上的一个或多个其他元素，并基于这些“锚点”元素的位置和尺寸来定位或调整自身尺寸，而无需关心它们在 DOM 树中的关系或共同的包含块。**\n\n这就像在大海里航行，以前你只能靠附近的灯塔（包含块）定位，现在你可以直接抛锚（anchor）到任何你想停靠的岛屿（任意元素）旁边。这种**解耦**是革命性的：\n\n- **DOM 结构自由：** 你的 tooltip、popover 可以放在 `\u003cbody>` 下，或者任何你想放的地方，不再受父子关系的限制。\n- **CSS 驱动：** 定位逻辑回归 CSS，减少甚至消除对 JS 的依赖，更符合关注点分离原则，性能也可能更好。\n- **智能避让：** 内建了处理边缘碰撞、自动调整位置（fallback）的机制，让“气泡总在元素旁边，但又不会跑出屏幕”这种需求变得简单。\n\n听起来是不是很激动人心？别急，我们一步步来看它是怎么施展魔法的。\n\n### 入门：抛出第一个锚\n\n想象我们要给一个按钮 `.anchor-btn` 加一个 tooltip `.tooltip`。\n\n**第一步：指定谁是锚点 (`anchor-name`)**\n\n首先，得告诉 CSS，哪个元素是我们的“锚”。这通过 `anchor-name` 属性完成。它的值需要是 CSS 变量那种 `--` 开头的“虚线标识符”（dashed-ident）。\n\n```css\n.anchor-btn {\n  /* --my-anchor 就是这个锚点的名字 */\n  anchor-name: --my-anchor;\n\n  /* 其他样式... */\n  padding: 10px 20px;\n  border: 1px solid #ccc;\n}\n```\n\n**第二步：设置需要定位的元素**\n\nTooltip 通常需要脱离文档流，所以我们给它 `position: fixed` 或 `absolute`。`fixed` 更省心，不用担心嵌套层级和 `transform` 干扰定位基准（虽然 Anchor Positioning 自身对 transform 和 scroll 有特殊处理，后面会提）。\n\n```css\n.tooltip {\n  position: fixed; /* 或者 absolute */\n  background-color: #333;\n  color: white;\n  padding: 5px 10px;\n  border-radius: 4px;\n  /* 先隐藏，可能通过 JS 或 :hover/:focus 等显示 */\n  display: none;\n}\n```\n\n**第三步：连接锚点和定位元素 (默认锚点 `position-anchor`)**\n\n现在，告诉 `.tooltip`，它默认应该参考哪个锚点。使用 `position-anchor` 属性。\n\n```css\n.tooltip {\n  position: fixed;\n  /* ... 其他样式 ... */\n\n  /* 默认情况下，我的位置参考 --my-anchor 这个锚点 */\n  position-anchor: --my-anchor;\n}\n```\n\n**第四步：使用 `anchor()` 函数定位**\n\n最关键的一步来了！怎么具体定位呢？用 `anchor()` 函数！这个函数可以用在 `top`, `left`, `right`, `bottom` 这些 inset 属性里。\n\n`anchor()` 函数的基本用法是 `anchor(\u003canchor-side>)`。当 `position-anchor` 设置了默认锚点时，可以省略锚点名字。`\u003canchor-side>` 指的是你希望定位元素的哪条边对齐锚点元素的哪条边。\n\n例如，我们想让 tooltip 的底部（`bottom`）对齐按钮的顶部（`top`）：\n\n```css\n.tooltip {\n  position: fixed;\n  /* 消除默认 margin 行为，这个很重要，否则会有很多不符合预期的行为 */\n  margin: 0;\n  /* 设置锚定点 */\n  position-anchor: --my-anchor;\n  /* ... 其他样式 ... */\n\n  /* 让我的 bottom 对齐 默认锚点 的 top */\n  bottom: anchor(top);\n  /* 水平方向，让我的左边 对齐 默认锚点 的左边 */\n  left: anchor(left);\n\n  /* 加一点偏移，让 tooltip 在按钮上方一点 */\n  margin-bottom: 8px;\n}\n```\n\n`anchor()` 函数里的 `top`, `left`, `right`, `bottom` 指的是锚点元素的**边界**。\n\n还有两个特殊的关键字：`inside` 和 `outside`。\n`inside` 指的是与 inset 属性**相同**的边，`outside` 指的是**相对**的边。\n\n例如，`bottom: anchor(top)` 可以理解为：\n我要设置 `bottom` 属性，它的值依赖于锚点的 `top` 边。\n\n而 `bottom: anchor(outside)` 就有点意思了，用在 `bottom` 属性上时，`outside` 指的是锚点的 `top` 边。用在 `top` 属性上时，`outside` 指的是锚点的 `bottom` 边。它表示“贴着锚点的外面”。\n\n所以，上面的 `bottom: anchor(top)` 其实更自然的写法是：\n\n```css\n.tooltip {\n  /* ... */\n  /* 把我的 top 定位在 锚点 的 bottom (即按钮下方) */\n  /* top: anchor(bottom); */\n\n  /* 或者，让我的 bottom 定位在 锚点 的 top (即按钮上方) */\n  bottom: anchor(top);\n\n  /* 水平居中？可以让 tooltip 的中线对齐锚点的中线 */\n  left: anchor(center);\n  transform: translateX(-50%); /* CSS经典居中 */\n\n  margin-bottom: 8px; /* 向上偏移 */\n}\n```\n\n`anchor()` 还可以接受百分比，`anchor(50%)` 或 `anchor(center)` 都代表锚点对应轴向的中心线。\n\n```html\n\u003cbutton class=\"anchor-btn\">Hover Me\u003c/button>\n\u003cdiv class=\"tooltip\" style=\"display: block;\">I'm a tooltip!\u003c/div>\n```\n\n![基础锚定定位效果](/img/css-anchor-positioning/tooltip-above-center.webp)\n\n是不是很简单？没有 JS，没有复杂的 DOM 嵌套，CSS 自己搞定了！\n\n### 进阶：让定位更得心应手\n\n`anchor()` 函数很强大，但每次都要写 `top`/`left` 有点繁琐。Anchor Positioning 提供了一些“语法糖”和增强功能。\n\n**1. `position-area`：九宫格布局**\n\n这是个超级方便的属性。它把锚点元素和它的“可用空间”（通常是视口或其包含块）想象成一个 3x3 的网格。你可以直接指定 tooltip 应该占据哪个格子。\n\n![position-area 的 3x3 网格示意图](/img/css-anchor-positioning/position-area-grid.webp) (来自规范草案的图)\n\n它的值可以是类似 `block-start`（块轴起点，通常是顶部）, `inline-end`（行轴终点，通常是右侧）, `center` 这样的关键字组合。\n\n例如，把 tooltip 放在按钮上方居中，可以这样写：\n\n```css\n.tooltip {\n  position: fixed;\n  position-anchor: --my-anchor;\n  /* ... 其他样式 ... */\n\n  /* 区域：块轴起点(top)，行轴中间(center) */\n  position-area: block-start center;\n  /* 默认对齐方式通常就不错，也可以用 align-self/justify-self 微调 */\n}\n```\n\n想放右边中间？`position-area: center inline-end;`\n想放左下角？`position-area: block-end inline-start;`\n\n它甚至支持跨越多行/列，如 `span-block-start` (从中间跨越到顶部)。\n\n**2. `anchor-center`：居中对齐的新选择**\n\n对于 `align-self` 和 `justify-self`，增加了一个新值 `anchor-center`。当使用 `position-area` 或希望在某个轴向上精确地对齐锚点的中心时，这个值非常有用。\n\n```css\n.tooltip {\n  /* ... */\n  position-area: block-start; /* 放在上方区域 */\n  justify-self: anchor-center; /* 水平方向对齐锚点中心 */\n}\n```\n\n**3. `anchor-size()`：尺寸向锚点看齐**\n\n有时候，我们希望定位元素的尺寸能跟随锚点变化。比如，下拉菜单的宽度应该和触发按钮一样宽。`anchor-size()` 函数应运而生！\n\n```css\n.dropdown-menu {\n  position: fixed;\n  position-anchor: --my-trigger;\n  /* ... */\n  top: anchor(bottom);\n  left: anchor(left);\n\n  /* 让我的宽度等于 --my-trigger 锚点的宽度 */\n  width: anchor-size(width);\n  /* 或者用逻辑轴 */\n  /* width: anchor-size(inline); */\n\n  /* 高度也可以 */\n  /* max-height: anchor-size(height) * 3; */\n}\n```\n\n`anchor-size()` 可以用在 `width`, `height`, `min-*`, `max-*` 等属性中，可以引用 `width`, `height`, `block`, `inline` (逻辑轴) 等。\n\n### 实战：处理真实世界的复杂性\n\n理想很丰满，现实很骨感。如果 tooltip 放在按钮上方会超出屏幕怎么办？如果滚动页面，锚点跑了，tooltip 会不会留在原地发呆？\n\n**1. 边缘碰撞与回退 (`position-try-fallbacks`, `@position-try`)**\n\n这是 Anchor Positioning 的精髓之一！当默认的定位方式导致元素溢出其容器（通常是视口）时，它可以自动尝试备选方案。\n\n- **内置回退策略 (`flip-block`, `flip-inline`, `flip-start`)**:\n  `position-try-fallbacks` 属性可以接受一些关键字，比如 `flip-block` 会尝试在块轴方向翻转（比如从上翻到下），`flip-inline` 则在行轴方向翻转（从左到右）。\n\n  ```css\n  .tooltip {\n    /* ... */\n    position-area: block-start; /* 默认放上面 */\n    /* 如果上面放不下，尝试块级翻转（放到下面） */\n    position-try-fallbacks: flip-block;\n  }\n  ```\n\n- **自定义回退规则 (`@position-try`)**:\n  你可以定义具名的回退样式集。\n\n  ```css\n  @position-try --fallback-bottom {\n    position-area: block-end; /* 尝试放下面 */\n    /* 可以定义更多样式调整 */\n    background-color: lightcoral; /* 比如换个背景色提示 */\n  }\n\n  @position-try --fallback-right {\n    position-area: inline-end;\n  }\n\n  .tooltip {\n    /* ... */\n    position-area: block-start; /* 默认放上面 */\n    /* 尝试顺序：先用 --fallback-bottom 规则，再尝试行内翻转，再用 --fallback-right 规则 */\n    position-try-fallbacks: --fallback-bottom, flip-inline, --fallback-right;\n  }\n  ```\n\n- **回退顺序 (`position-try-order`)**:\n  默认按 `position-try-fallbacks` 列表顺序尝试。但有时你希望优先选择**空间更大**的回退位置，可以用 `most-width`, `most-height`, `most-block-size`, `most-inline-size`。\n\n  ```css\n  .tooltip {\n    /* ... */\n    position-try-fallbacks: --try-top, --try-bottom, --try-left, --try-right;\n    /* 优先选择高度最大的位置 */\n    position-try-order: most-height;\n  }\n  ```\n\n**2. 滚动与变换：性能与行为的权衡**\n\n这是一个复杂但重要的话题。如果锚点在可滚动区域内，或者被 `transform` 了，定位元素怎么办？\n\n- **基本原则：** 为了性能，浏览器通常**不会**在滚动或 `transform` 改变时频繁重新计算锚点元素的精确布局。\n- **记住滚动偏移 (`remembered scroll offset`)：** 浏览器会在某个时间点（比如元素首次显示或回退策略改变时）“记住”锚点相对于定位元素的滚动容器的滚动偏移量。后续定位会基于这个记住的值。\n- **默认锚点的特权：** 如果定位元素只依赖**默认锚点** (`position-anchor` 指定的那个)，并且满足特定条件（比如用了 `anchor-center` 或 `position-area`），浏览器**可以**在滚动时**平移**定位元素，让它跟随默认锚点移动。这是一种性能友好的“补偿”(`compensate for scroll`)。\n- **多锚点或非默认锚点：** 如果你用了多个 `anchor()` 指向不同滚动容器的锚点，或者依赖非默认锚点，滚动时它们的位置可能就不再精确跟随了（只跟随非滚动部分的移动）。\n- **`transform` 的影响：** 规范草案目前提到，默认情况下，锚点上的 `transform` **不影响** `anchor()` 函数的计算结果（Issue 1）。这可能会在未来改变。\n\n简单说：尽量让你的主要定位逻辑依赖默认锚点，可以获得更好的滚动跟随效果。对于复杂的多锚点场景，滚动时的行为可能没那么“实时”。\n\n**3. 条件隐藏 (`position-visibility`)**\n\n有时候，如果锚点无效、不可见，或者即使尝试了所有回退方案，定位元素仍然溢出，我们可能希望直接隐藏它。`position-visibility` 属性就是干这个的。\n\n```css\n.tooltip {\n  /* ... */\n  /* 默认值是 anchors-visible，如果锚点不可见（比如被滚动隐藏了）就自动隐藏 */\n  /* position-visibility: anchors-visible; */\n\n  /* 如果所有回退都试过后还溢出，就隐藏 */\n  position-visibility: no-overflow;\n\n  /* 如果有必须的锚点（比如 anchor() 没提供 fallback 值）无效，就隐藏 */\n  /* position-visibility: anchors-valid; */\n\n  /* 组合使用 */\n  position-visibility: anchors-valid no-overflow;\n}\n```\n\n### 高级话题：作用域、隐式锚点\n\n- **`anchor-scope`：避免命名冲突**\n  在组件化开发中，如果你在列表的每个 `\u003cli>` 里都用了 `anchor-name: --item-anchor`，那所有 `\u003cli>` 里的定位元素都会锚定到**最后一个** `\u003cli>` 上！`anchor-scope` 可以限制锚点名称的查找范围。\n\n  ```css\n  li {\n    /* 这个锚点名字只在 li 内部及其后代中有效 */\n    anchor-name: --item-anchor;\n    anchor-scope: --item-anchor;\n    position: relative; /* 创建层叠上下文可能也有帮助 */\n  }\n  li .popup {\n    position: absolute;\n    position-anchor: --item-anchor;\n    top: anchor(bottom);\n    /* ... */\n  }\n  ```\n\n- **隐式锚点 (`auto`)**\n  某些 HTML API（比如未来的 Popover API）可能会自动建立锚定关系。比如，触发 popover 的按钮自动成为该 popover 的“隐式锚点”。这时，你可以用 `position-anchor: auto;` 或者在 `anchor()`/`anchor-size()` 中省略锚点名来引用它。\n\n### 别忘了可访问性 (Accessibility)\n\n重要的事情说三遍：Anchor Positioning 是**纯视觉**的！它在视觉上把两个元素关联起来，但**不会**自动建立它们之间的语义联系。\n\n屏幕阅读器等辅助技术无法理解这种视觉关联。所以，你必须：\n\n- 使用 `aria-describedby`, `aria-details` 等 ARIA 属性，在 HTML 中明确两者关系。\n- 确保合理的焦点管理和键盘导航。\n\n好消息是，像 Popover API 这样的原生 HTML 功能，在提供隐式锚点的同时，通常也会处理好相关的可访问性问题。\n\n### 总结：未来已来？\n\nCSS Anchor Positioning 无疑是近年来 CSS 布局领域最激动人心的提案之一。它直击了 Web 开发中长期存在的定位痛点，提供了一种更声明式、更灵活、更强大的解决方案。\n\n**优点：**\n\n- **DOM 解耦：** 布局不再受限于 HTML 结构。\n- **CSS 驱动：** 减少 JS 依赖，代码更清晰。\n- **智能回退：** 内建边缘检测和位置调整。\n- **强大灵活：** `anchor()`, `anchor-size()`, `position-area` 提供了丰富的控制。\n\n**注意事项/挑战：**\n\n- **新规范：** 目前仍是 Editor's Draft（编辑草案），API 可能会变化，浏览器支持需要关注（通常需要开启实验性标志）。(写作时基于 2024 年 10 月草案)\n- **滚动/变换行为：** 涉及性能权衡，行为需要理解清楚。\n- **可访问性：** 需要开发者额外关注。\n- **学习曲线：** 虽然入门简单，但回退、滚动等机制需要深入理解。\n\n总的来说，Anchor Positioning 描绘了一个美好的未来：开发者可以更专注于内容和语义，把复杂的定位逻辑交还给 CSS。虽然离全面普及还有距离，但了解它、尝试它，绝对能让你在未来的 Web 布局中占得先机。\n\n告别那些为了定位而写的 JS \"屎山\"吧，拥抱 CSS 的新可能！你觉得这个新特性怎么样？欢迎在评论区留下你的看法！\n\n---\n\n希望这篇模仿张鑫旭老师风格的文章能帮助你理解 CSS Anchor Positioning！记得，实际运用时一定要查阅最新的规范文档和浏览器兼容性信息。\n\n参考文献：\n\n1. [CSS Anchor Positioning - Editor’s Draft, 12 October 2024](https://drafts.csswg.org/css-anchor-position-1/)\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.XrIATmm0.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.IQG_6ZON.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-vy2czm8u.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-0HRAW6Xj.js" as="script" type="text/javascript">
      </body>
    </html>