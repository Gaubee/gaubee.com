<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.-4-S6IZd.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }

          main > p > img {
            max-width: 100%;
            margin: 0 auto;
            display: block;
          }
        </style><h1>Firebase在国内使用的一些方法</h1><main><p>Firebase在国内有些地区是可用的，但只是有些，没法保证全国通用，这篇文章谈的是服务端（Node.js）的使用。</p>
<p>前提是电脑跑起来了代理软件，这个怎么搞我就不说了，代理服务器方面我建议用香港的代理服务器，那就很快很稳了。</p>
<p>首先是Firebase-tool这个命令行工具，源码中使用的是request这个库，所以只要在源码里头加上<code>proxy</code>属性就行了。</p>
<p>目前版本来说这个文件是<code>api.js</code>，找到<code>_request</code>这个函数，在里头加上一句：</p>
<pre><code class="language-js">  options.proxy = "http://127.0.0.1:8118";
</code></pre>
<hr>
<p>比较麻烦的是Firbase-admin这个库，用的是原生的http/https这两个核心的，核心服务都是走https的，所以这篇文章主要就谈一谈原生库如何走代理。我已经将这个库整理到<a href="https://github.com/Gaubee/firebase-admin-proxyable">firebase-admin-proxyable</a>这里了，国内用户可以安装这个并看着文档中DEMO的写法来配置自己的代理。</p>
<ol>
<li>
<p>核心原理就是使用<a href="https://nodejs.org/api/http.html#http_class_http_agent">agent</a>这个属性，具体看官方文档。</p>
</li>
<li>
<p>在npm里头，绝大多数的代理，核心都是这个库：<a href="https://www.npmjs.com/package/tunnel-agent">tunnel-agent</a>，点链接进去没文档，没关系，直接看源码，源码就单文件不到300行。</p>
</li>
<li>
<p>然后推荐用<a href="https://www.npmjs.com/package/caw">caw</a>这个库。源码也是很简单的，读过觉得很靠谱，所以才在这里推荐使用。</p>
</li>
</ol>
<p>以上就是相关的核心基本知识了。
下面是实践：</p>
<hr>
<h3>第一步</h3>
<pre><code class="language-js">const caw = require('caw');

const https = require("https");

https.globalAgent = caw("http://127.0.0.1:8118", {
	protocol: 'https'
});
</code></pre>
<p>设置全局代理，agent的只有在keep-alive的情况下才会自动触发，去使用globalAgent。</p>
<blockquote>
<p>注意，这里：<code>"http://</code>这个代理的协议头不能少，看源码就知道为什么，因为源码很精简，没有去做那些不必要的智能判断，所以包括后面的<code>protocol: 'https'</code>也不能少，这点很重要。</p>
</blockquote>
<h3>第二步</h3>
<pre><code class="language-js">const admin = require("./firebase-admin");
</code></pre>
<p>要把node_modules里头的firebase-admin文件夹拿出来，改源码，当然你也可以手动去跟随维护一个走代理版本的库。</p>
<h3>第三步</h3>
<p>找到api-request.js文件中https请求的options的定义，添加以下属性。</p>
<pre><code class="language-js">// firebase-admin\lib\utils\api-request.js
 |  var options = {
 |      method: httpMethod,
 |      host: host,
 |      port: port,
 |      path: path,
 |      headers: headers,
+|      agent: https.globalAgent,
 |  };
</code></pre>
<p>找到credential.js文件中requestAccessToken函数，在函数头部添加以下代码</p>
<pre><code class="language-js">// firebase-admin\lib\auth\credential.js
 |function requestAccessToken(transit, options, data) {
+|    if(transit === https){
+|        options.agent = https.globalAgent;
+|    }
 |    return new Promise(function (resolve, reject) {
</code></pre>
<hr>
<p>2017-8-2补充：
上面说的代理，是针对Google身份校验方面的代理。而在身份校验通过后，就是要开始用<code>wss</code>协议连接到服务器了，这点我补充一下如何配置：
在源码中有这么一段：</p>
<pre><code>0 == this.Wd.indexOf("wss://") ? d.HTTPS_PROXY || d.https_proxy : d.HTTP_PROXY || d.http_proxy;
</code></pre>
<p>意思是，wss的代理走的不是nodejs的，而是自己的一套，默认从命令行的环境中获取代理参数，所以如果wss连接不稳定，需要走代理的话：</p>
<pre><code>set https_proxy=http://127.0.0.1:8118
</code></pre>
<p>注意，这里头<code>http://</code>这个协议前缀一定要加。</p></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0031.Some-of-the-methods-used-by-Firebase-in-the-country"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0031.Some-of-the-methods-used-by-Firebase-in-the-country.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"Firebase在国内使用的一些方法","date":"!Date:2017-03-13T03:33:32.000Z","updated":"!Date:2017-08-02T09:25:34.000Z"},"metadata":{"layout":"layouts/article.njk","title":"Firebase在国内使用的一些方法","date":"!Date:2017-03-13T03:33:32.000Z","updated":"!Date:2017-08-02T09:25:34.000Z","id":"0031.Some-of-the-methods-used-by-Firebase-in-the-country","createdAt":"!Date:2017-03-13T03:33:32.000Z","updatedAt":"!Date:2017-08-02T09:25:34.000Z","tags":[]},"htmlContent":"\u003cp>Firebase在国内有些地区是可用的，但只是有些，没法保证全国通用，这篇文章谈的是服务端（Node.js）的使用。\u003c/p>\n\u003cp>前提是电脑跑起来了代理软件，这个怎么搞我就不说了，代理服务器方面我建议用香港的代理服务器，那就很快很稳了。\u003c/p>\n\u003cp>首先是Firebase-tool这个命令行工具，源码中使用的是request这个库，所以只要在源码里头加上\u003ccode>proxy\u003c/code>属性就行了。\u003c/p>\n\u003cp>目前版本来说这个文件是\u003ccode>api.js\u003c/code>，找到\u003ccode>_request\u003c/code>这个函数，在里头加上一句：\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">  options.proxy = \"http://127.0.0.1:8118\";\n\u003c/code>\u003c/pre>\n\u003chr>\n\u003cp>比较麻烦的是Firbase-admin这个库，用的是原生的http/https这两个核心的，核心服务都是走https的，所以这篇文章主要就谈一谈原生库如何走代理。我已经将这个库整理到\u003ca href=\"https://github.com/Gaubee/firebase-admin-proxyable\">firebase-admin-proxyable\u003c/a>这里了，国内用户可以安装这个并看着文档中DEMO的写法来配置自己的代理。\u003c/p>\n\u003col>\n\u003cli>\n\u003cp>核心原理就是使用\u003ca href=\"https://nodejs.org/api/http.html#http_class_http_agent\">agent\u003c/a>这个属性，具体看官方文档。\u003c/p>\n\u003c/li>\n\u003cli>\n\u003cp>在npm里头，绝大多数的代理，核心都是这个库：\u003ca href=\"https://www.npmjs.com/package/tunnel-agent\">tunnel-agent\u003c/a>，点链接进去没文档，没关系，直接看源码，源码就单文件不到300行。\u003c/p>\n\u003c/li>\n\u003cli>\n\u003cp>然后推荐用\u003ca href=\"https://www.npmjs.com/package/caw\">caw\u003c/a>这个库。源码也是很简单的，读过觉得很靠谱，所以才在这里推荐使用。\u003c/p>\n\u003c/li>\n\u003c/ol>\n\u003cp>以上就是相关的核心基本知识了。\n下面是实践：\u003c/p>\n\u003chr>\n\u003ch3>第一步\u003c/h3>\n\u003cpre>\u003ccode class=\"language-js\">const caw = require('caw');\n\nconst https = require(\"https\");\n\nhttps.globalAgent = caw(\"http://127.0.0.1:8118\", {\n\tprotocol: 'https'\n});\n\u003c/code>\u003c/pre>\n\u003cp>设置全局代理，agent的只有在keep-alive的情况下才会自动触发，去使用globalAgent。\u003c/p>\n\u003cblockquote>\n\u003cp>注意，这里：\u003ccode>\"http://\u003c/code>这个代理的协议头不能少，看源码就知道为什么，因为源码很精简，没有去做那些不必要的智能判断，所以包括后面的\u003ccode>protocol: 'https'\u003c/code>也不能少，这点很重要。\u003c/p>\n\u003c/blockquote>\n\u003ch3>第二步\u003c/h3>\n\u003cpre>\u003ccode class=\"language-js\">const admin = require(\"./firebase-admin\");\n\u003c/code>\u003c/pre>\n\u003cp>要把node_modules里头的firebase-admin文件夹拿出来，改源码，当然你也可以手动去跟随维护一个走代理版本的库。\u003c/p>\n\u003ch3>第三步\u003c/h3>\n\u003cp>找到api-request.js文件中https请求的options的定义，添加以下属性。\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">// firebase-admin\\lib\\utils\\api-request.js\n |  var options = {\n |      method: httpMethod,\n |      host: host,\n |      port: port,\n |      path: path,\n |      headers: headers,\n+|      agent: https.globalAgent,\n |  };\n\u003c/code>\u003c/pre>\n\u003cp>找到credential.js文件中requestAccessToken函数，在函数头部添加以下代码\u003c/p>\n\u003cpre>\u003ccode class=\"language-js\">// firebase-admin\\lib\\auth\\credential.js\n |function requestAccessToken(transit, options, data) {\n+|    if(transit === https){\n+|        options.agent = https.globalAgent;\n+|    }\n |    return new Promise(function (resolve, reject) {\n\u003c/code>\u003c/pre>\n\u003chr>\n\u003cp>2017-8-2补充：\n上面说的代理，是针对Google身份校验方面的代理。而在身份校验通过后，就是要开始用\u003ccode>wss\u003c/code>协议连接到服务器了，这点我补充一下如何配置：\n在源码中有这么一段：\u003c/p>\n\u003cpre>\u003ccode>0 == this.Wd.indexOf(\"wss://\") ? d.HTTPS_PROXY || d.https_proxy : d.HTTP_PROXY || d.http_proxy;\n\u003c/code>\u003c/pre>\n\u003cp>意思是，wss的代理走的不是nodejs的，而是自己的一套，默认从命令行的环境中获取代理参数，所以如果wss连接不稳定，需要走代理的话：\u003c/p>\n\u003cpre>\u003ccode>set https_proxy=http://127.0.0.1:8118\n\u003c/code>\u003c/pre>\n\u003cp>注意，这里头\u003ccode>http://\u003c/code>这个协议前缀一定要加。\u003c/p>","markdownContent":"\nFirebase在国内有些地区是可用的，但只是有些，没法保证全国通用，这篇文章谈的是服务端（Node.js）的使用。\n\n前提是电脑跑起来了代理软件，这个怎么搞我就不说了，代理服务器方面我建议用香港的代理服务器，那就很快很稳了。\n\n首先是Firebase-tool这个命令行工具，源码中使用的是request这个库，所以只要在源码里头加上`proxy`属性就行了。\n\n目前版本来说这个文件是`api.js`，找到`_request`这个函数，在里头加上一句：\n```js\n  options.proxy = \"http://127.0.0.1:8118\";\n```\n\n--------\n\n比较麻烦的是Firbase-admin这个库，用的是原生的http/https这两个核心的，核心服务都是走https的，所以这篇文章主要就谈一谈原生库如何走代理。我已经将这个库整理到[firebase-admin-proxyable](https://github.com/Gaubee/firebase-admin-proxyable)这里了，国内用户可以安装这个并看着文档中DEMO的写法来配置自己的代理。\n\n1. 核心原理就是使用[agent](https://nodejs.org/api/http.html#http_class_http_agent)这个属性，具体看官方文档。\n\n2. 在npm里头，绝大多数的代理，核心都是这个库：[tunnel-agent](https://www.npmjs.com/package/tunnel-agent)，点链接进去没文档，没关系，直接看源码，源码就单文件不到300行。\n\n3. 然后推荐用[caw](https://www.npmjs.com/package/caw)这个库。源码也是很简单的，读过觉得很靠谱，所以才在这里推荐使用。\n\n以上就是相关的核心基本知识了。\n下面是实践：\n\n-----\n\n### 第一步\n```js\nconst caw = require('caw');\n\nconst https = require(\"https\");\n\nhttps.globalAgent = caw(\"http://127.0.0.1:8118\", {\n\tprotocol: 'https'\n});\n```\n设置全局代理，agent的只有在keep-alive的情况下才会自动触发，去使用globalAgent。\n> 注意，这里：`\"http://`这个代理的协议头不能少，看源码就知道为什么，因为源码很精简，没有去做那些不必要的智能判断，所以包括后面的`protocol: 'https'`也不能少，这点很重要。\n\n### 第二步\n\n```js\nconst admin = require(\"./firebase-admin\");\n```\n要把node_modules里头的firebase-admin文件夹拿出来，改源码，当然你也可以手动去跟随维护一个走代理版本的库。\n\n### 第三步\n\n找到api-request.js文件中https请求的options的定义，添加以下属性。\n```js\n// firebase-admin\\lib\\utils\\api-request.js\n |  var options = {\n |      method: httpMethod,\n |      host: host,\n |      port: port,\n |      path: path,\n |      headers: headers,\n+|      agent: https.globalAgent,\n |  };\n```\n\n找到credential.js文件中requestAccessToken函数，在函数头部添加以下代码\n```js\n// firebase-admin\\lib\\auth\\credential.js\n |function requestAccessToken(transit, options, data) {\n+|    if(transit === https){\n+|        options.agent = https.globalAgent;\n+|    }\n |    return new Promise(function (resolve, reject) {\n```\n\n--------------\n\n2017-8-2补充：\n上面说的代理，是针对Google身份校验方面的代理。而在身份校验通过后，就是要开始用`wss`协议连接到服务器了，这点我补充一下如何配置：\n在源码中有这么一段：\n```\n0 == this.Wd.indexOf(\"wss://\") ? d.HTTPS_PROXY || d.https_proxy : d.HTTP_PROXY || d.http_proxy;\n```\n意思是，wss的代理走的不是nodejs的，而是自己的一套，默认从命令行的环境中获取代理参数，所以如果wss连接不稳定，需要走代理的话：\n```\nset https_proxy=http://127.0.0.1:8118\n```\n注意，这里头`http://`这个协议前缀一定要加。\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.Drxmn1Vl.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.Dy4hh5dO.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-BaTxRAW4.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-CZaZKh6Z.js" as="script" type="text/javascript">
      </body>
    </html>