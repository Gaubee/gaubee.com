<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.BMrmlmx0.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="/img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="/img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh;background-color:#fafafa;color:#333"><style type="text/css">
          main > p {
            text-indent: 1em;
          }
        </style><h1>使用WebGL作色器基础知识实现PIXI.js高斯三角模糊</h1><main><p>官方给出的模糊滤镜效果不尽人意，所以就想自己写一个，顺带学习了一些 WebGL 的作色器相关的基础知识。
说真的网上的文章讲得不是很乱，以下是我总结出来的。</p>
<h2>WebGL 作色器</h2>
<p>作色器的基本理念我不赘述。不了解的看下面猜测一下也能猜出个大概。
这里从 PIXI.js 的源码中来看，用<a href="https://github.com/pixijs/pixi.js/blob/master/src/filters/blur/BlurXFilter.js">blurXFilter</a>为例，顶点作色器的代码如下：</p>
<pre><code class="language-glsl">attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

uniform float strength;
uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying vec2 vBlurTexCoords[6];

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;

    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);
    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);
    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);
    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);
    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);
    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);

    vColor = vec4(aColor.rgb * aColor.a, aColor.a);
}
</code></pre>
<p><strong>顶点作色器</strong>程序执行过程中需要数据，首先了解这三种数据：</p>
<ol>
<li>Attribute (从缓冲区对象中拉取数据)</li>
<li>Uniform (在绘制过程中所有顶点都需要的、固定的数据值)</li>
<li>Texture (像素/纹理元素数据)
<strong>片元作色器</strong>也需要数据，也是三种获取方式：</li>
<li>Uniform (在绘制过程中每个像素都需要的、固定的变量值)</li>
<li>Texture (像素/纹理元素数据)</li>
<li>Varying (从顶点着色器传递过来并且经过内插过程的数据)</li>
</ol>
<p>简单的站在我这个新手的角度来说，我是这样看的：
attribute 是 PIXI 框架传入的数据，顶点作色器最终的计算数据是反应到<code>gl_Position</code>上面。
uniform 是用户自己传入的数据。
varying 是定点作色器和片元作色器的共享的数据。</p>
<p>所以对比<a href="https://github.com/pixijs/pixi.js/blob/039200b46d7840f065faa50739e4b98f69678db4/src/core/renderers/webgl/shaders/TextureShader.js#L74-L90">默认的顶点作色器代码 TextureShader</a>，可以看出有三行都是一样的：</p>
<pre><code class="language-glsl">gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
vTextureCoord = aTextureCoord;
vColor = vec4(aColor.rgb * aColor.a, aColor.a);
</code></pre>
<p>不管这三行，看其它部分：</p>
<pre><code class="language-glsl">    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);
    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);
    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);
    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);
    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);
    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);
</code></pre>
<p>当我把 strength 值调整到 100 后，是这样的效果：</p>
<p><img src="/img/pixi-webgl-gaussian-blur/strength-100.png" alt="image"></p>
<p>我不得不诟病这个模糊效果（不然也不会有这篇文章了）。所以现在理解一下上面的代码：
<code>vec2( X , Y)</code> 意味着一个偏移量，其中 Y=0，而<code>aTextureCoord</code>从命名理解就是<strong>纹理坐标</strong>，这里 j 把纹理贴图左右两边的数据拿了过来，在执行片元作色器的时候用上了：</p>
<pre><code class="language-glsl">precision lowp float;

varying vec2 vTextureCoord;
varying vec2 vBlurTexCoords[6];
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = vec4(0.0);

    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;
    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;
    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;
    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;
    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;
    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;
    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;
}
</code></pre>
<p>可以看到实现方式就是把左右纹理贴图的数据以渐变的方式贴到一个点上，最终看到的就是上面效果图展示的多层贴图以不同透明度重叠的效果。PS: <code>vColor</code>这个参数我猜是遮罩或者透明通道</p>
<h2>参考 glfx 实现高斯模糊</h2>
<p>对比<a href="https://github.com/evanw/glfx.js/blob/master/src/filters/blur/triangleblur.js">triangleblur.js</a>。可以看出它的作色器代码其实是片元作色器代码，顶点作色器放空 null 使用默认。所以对比一下参数其实就好办了：
其中<code>delta</code>这个参数都是用户传入的，剩下的只有<code>texture|texCoord</code>分别对应 PIXI.js 中的<code>uSampler|vTextureCoord</code>。</p>
<p>所以代码关系对上后就好说了，接下来用 TypeScript 来实现 PIXI.js 中的高斯模糊滤镜。</p>
<h2>PIXI.js 中高斯模糊的实现</h2>
<p>参考官方写法，先搭建出大概的类架构：</p>
<pre><code class="language-typescript">class GaussianBlur extends PIXI.AbstractFilter {
  _delta: number;
  constructor() {
    let vert = "";
    let frag = "";
    super(vert, frag, {});
  }
  applyFilter(renderer, input, output, clear) {}
  get blur() {
    return this._delta;
  }
  set blur(value) {
    this._delta = value;
  }
}
export default GaussianBlur;
</code></pre>
<p>然后就是要传入作色器代码了:</p>
<pre><code class="language-typescript">var randomShaderFunc =
  "\
    float random(vec3 scale, float seed) {\
        /* use the fragment position for a different seed per-pixel */\
        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\
    }\
";
let vert = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

uniform vec2 delta;
uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying vec2 vDelta;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;

    vDelta = delta;

    vColor = vec4(aColor.rgb * aColor.a, aColor.a);
}`;
let frag = `precision lowp float;

varying vec2 vTextureCoord;
varying vec2 vDelta;
varying vec4 vColor;

uniform sampler2D uSampler;
${randomShaderFunc}
void main() {
    vec4 color = vec4(0.0);
    float total = 0.0;

    /* randomize the lookup values to hide the fixed number of samples */
    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

    for (float t = -30.0; t &#x3C;= 30.0; t++) {
        float percent = (t + offset - 0.5) / 30.0;
        float weight = 1.0 - abs(percent);
        vec4 sample = texture2D(uSampler, vTextureCoord + vDelta * percent);

        /* switch to pre-multiplied alpha to correctly blur transparent images */
        sample.rgb *= sample.a;

        color += sample * weight;
        total += weight;
    }

    gl_FragColor = color / total;

    /* switch back from pre-multiplied alpha */
    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
}`;
</code></pre>
<p>要注意的是，PIXI.js 的风格就是数据都是从顶点作色器那边传入的，所以 detal 参数就从顶点作色器那边进行赋值并在片元作色器那边使用。片元作色器那边基本就是把 glfx 的代码拷贝过来，然后把参数命名改成 PIXI 中的参数命名即可。要注意的是<code>precision lowp float;</code>这一句 glfx 没有，PIXI 中一定要加，好像是声明精度的问题，作为一个小白，暂时不理解，只是在做的过程中发现如果没有这句的话作色器编译的时候会报错。
最终效果（blur=10）：</p>
<p><img src="/img/pixi-webgl-gaussian-blur/blur-10.png" alt="image"></p>
<p>还有一个要注意的问题就是这个滤镜要跑两次才行，就是 X\Y 是分开来模糊的，如果一起的话，会变成斜方向的模糊。PIXI 中类似的实现参考<a href="https://github.com/pixijs/pixi.js/blob/master/src/filters/blur/BlurFilter.js">BlurFilter</a>，因为它也是 X、Y 两次模糊滤镜后的效果。以下是我 applyFilter 的代码：</p>
<pre><code class="language-typescript">var shader = this.getShader(renderer);
var renderTarget = renderer.filterManager.getRenderTarget(true);
this.uniforms.delta.value = {
  x: this._delta / input.size.width,
  y: 0,
};
renderer.filterManager.applyFilter(shader, input, renderTarget, clear);

this.uniforms.delta.value = {
  x: 0,
  y: this._delta / input.size.height,
};
renderer.filterManager.applyFilter(shader, renderTarget, output, clear);

// 很重要，不加的话会引发内存泄漏
renderer.filterManager.returnRenderTarget(renderTarget);
</code></pre>
<hr>
<p>最后贴出完整代码：
Typescript、ES6 版本：<a href="https://gist.github.com/Gaubee/54aa14b5e06ef8c3f5c25e1964c89fab#file-gaussianblur-ts">Gaussianblur.ts</a>
ES5 版本：<a href="https://gist.github.com/Gaubee/54aa14b5e06ef8c3f5c25e1964c89fab#file-gaussianblur-js">Gaussianblur.js</a></p></main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"0025.Implement-PIXI.js-Gauss-triangle-blur-using-WebGL-colorist-basics"},"data":{"article":{"fileEntry":{"path":"/home/runner/work/gaubee.com/gaubee.com/articles/0025.Implement-PIXI.js-Gauss-triangle-blur-using-WebGL-colorist-basics.md","options":{"cwd":"/home/runner/work/gaubee.com/gaubee.com/articles"},"isFile":true,"isDirectory":false},"originMetadata":{"layout":"layouts/article.njk","title":"使用WebGL作色器基础知识实现PIXI.js高斯三角模糊","date":"!Date:2016-05-03T12:12:09.000Z","updated":"!Date:2016-05-04T05:40:20.000Z","tags":["javascript"]},"metadata":{"layout":"layouts/article.njk","title":"使用WebGL作色器基础知识实现PIXI.js高斯三角模糊","date":"!Date:2016-05-03T12:12:09.000Z","updated":"!Date:2016-05-04T05:40:20.000Z","tags":["javascript"],"id":"0025.Implement-PIXI.js-Gauss-triangle-blur-using-WebGL-colorist-basics","createdAt":"!Date:2016-05-03T12:12:09.000Z","updatedAt":"!Date:2016-05-04T05:40:20.000Z"},"htmlContent":"\u003cp>官方给出的模糊滤镜效果不尽人意，所以就想自己写一个，顺带学习了一些 WebGL 的作色器相关的基础知识。\n说真的网上的文章讲得不是很乱，以下是我总结出来的。\u003c/p>\n\u003ch2>WebGL 作色器\u003c/h2>\n\u003cp>作色器的基本理念我不赘述。不了解的看下面猜测一下也能猜出个大概。\n这里从 PIXI.js 的源码中来看，用\u003ca href=\"https://github.com/pixijs/pixi.js/blob/master/src/filters/blur/BlurXFilter.js\">blurXFilter\u003c/a>为例，顶点作色器的代码如下：\u003c/p>\n\u003cpre>\u003ccode class=\"language-glsl\">attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n\u003c/code>\u003c/pre>\n\u003cp>\u003cstrong>顶点作色器\u003c/strong>程序执行过程中需要数据，首先了解这三种数据：\u003c/p>\n\u003col>\n\u003cli>Attribute (从缓冲区对象中拉取数据)\u003c/li>\n\u003cli>Uniform (在绘制过程中所有顶点都需要的、固定的数据值)\u003c/li>\n\u003cli>Texture (像素/纹理元素数据)\n\u003cstrong>片元作色器\u003c/strong>也需要数据，也是三种获取方式：\u003c/li>\n\u003cli>Uniform (在绘制过程中每个像素都需要的、固定的变量值)\u003c/li>\n\u003cli>Texture (像素/纹理元素数据)\u003c/li>\n\u003cli>Varying (从顶点着色器传递过来并且经过内插过程的数据)\u003c/li>\n\u003c/ol>\n\u003cp>简单的站在我这个新手的角度来说，我是这样看的：\nattribute 是 PIXI 框架传入的数据，顶点作色器最终的计算数据是反应到\u003ccode>gl_Position\u003c/code>上面。\nuniform 是用户自己传入的数据。\nvarying 是定点作色器和片元作色器的共享的数据。\u003c/p>\n\u003cp>所以对比\u003ca href=\"https://github.com/pixijs/pixi.js/blob/039200b46d7840f065faa50739e4b98f69678db4/src/core/renderers/webgl/shaders/TextureShader.js#L74-L90\">默认的顶点作色器代码 TextureShader\u003c/a>，可以看出有三行都是一样的：\u003c/p>\n\u003cpre>\u003ccode class=\"language-glsl\">gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\nvTextureCoord = aTextureCoord;\nvColor = vec4(aColor.rgb * aColor.a, aColor.a);\n\u003c/code>\u003c/pre>\n\u003cp>不管这三行，看其它部分：\u003c/p>\n\u003cpre>\u003ccode class=\"language-glsl\">    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\n\u003c/code>\u003c/pre>\n\u003cp>当我把 strength 值调整到 100 后，是这样的效果：\u003c/p>\n\u003cp>\u003cimg src=\"/img/pixi-webgl-gaussian-blur/strength-100.png\" alt=\"image\">\u003c/p>\n\u003cp>我不得不诟病这个模糊效果（不然也不会有这篇文章了）。所以现在理解一下上面的代码：\n\u003ccode>vec2( X , Y)\u003c/code> 意味着一个偏移量，其中 Y=0，而\u003ccode>aTextureCoord\u003c/code>从命名理解就是\u003cstrong>纹理坐标\u003c/strong>，这里 j 把纹理贴图左右两边的数据拿了过来，在执行片元作色器的时候用上了：\u003c/p>\n\u003cpre>\u003ccode class=\"language-glsl\">precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n\u003c/code>\u003c/pre>\n\u003cp>可以看到实现方式就是把左右纹理贴图的数据以渐变的方式贴到一个点上，最终看到的就是上面效果图展示的多层贴图以不同透明度重叠的效果。PS: \u003ccode>vColor\u003c/code>这个参数我猜是遮罩或者透明通道\u003c/p>\n\u003ch2>参考 glfx 实现高斯模糊\u003c/h2>\n\u003cp>对比\u003ca href=\"https://github.com/evanw/glfx.js/blob/master/src/filters/blur/triangleblur.js\">triangleblur.js\u003c/a>。可以看出它的作色器代码其实是片元作色器代码，顶点作色器放空 null 使用默认。所以对比一下参数其实就好办了：\n其中\u003ccode>delta\u003c/code>这个参数都是用户传入的，剩下的只有\u003ccode>texture|texCoord\u003c/code>分别对应 PIXI.js 中的\u003ccode>uSampler|vTextureCoord\u003c/code>。\u003c/p>\n\u003cp>所以代码关系对上后就好说了，接下来用 TypeScript 来实现 PIXI.js 中的高斯模糊滤镜。\u003c/p>\n\u003ch2>PIXI.js 中高斯模糊的实现\u003c/h2>\n\u003cp>参考官方写法，先搭建出大概的类架构：\u003c/p>\n\u003cpre>\u003ccode class=\"language-typescript\">class GaussianBlur extends PIXI.AbstractFilter {\n  _delta: number;\n  constructor() {\n    let vert = \"\";\n    let frag = \"\";\n    super(vert, frag, {});\n  }\n  applyFilter(renderer, input, output, clear) {}\n  get blur() {\n    return this._delta;\n  }\n  set blur(value) {\n    this._delta = value;\n  }\n}\nexport default GaussianBlur;\n\u003c/code>\u003c/pre>\n\u003cp>然后就是要传入作色器代码了:\u003c/p>\n\u003cpre>\u003ccode class=\"language-typescript\">var randomShaderFunc =\n  \"\\\n    float random(vec3 scale, float seed) {\\\n        /* use the fragment position for a different seed per-pixel */\\\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\\\n    }\\\n\";\nlet vert = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform vec2 delta;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vDelta;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vDelta = delta;\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}`;\nlet frag = `precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vDelta;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n${randomShaderFunc}\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    /* randomize the lookup values to hide the fixed number of samples */\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    for (float t = -30.0; t &#x3C;= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + vDelta * percent);\n\n        /* switch to pre-multiplied alpha to correctly blur transparent images */\n        sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n\n    /* switch back from pre-multiplied alpha */\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}`;\n\u003c/code>\u003c/pre>\n\u003cp>要注意的是，PIXI.js 的风格就是数据都是从顶点作色器那边传入的，所以 detal 参数就从顶点作色器那边进行赋值并在片元作色器那边使用。片元作色器那边基本就是把 glfx 的代码拷贝过来，然后把参数命名改成 PIXI 中的参数命名即可。要注意的是\u003ccode>precision lowp float;\u003c/code>这一句 glfx 没有，PIXI 中一定要加，好像是声明精度的问题，作为一个小白，暂时不理解，只是在做的过程中发现如果没有这句的话作色器编译的时候会报错。\n最终效果（blur=10）：\u003c/p>\n\u003cp>\u003cimg src=\"/img/pixi-webgl-gaussian-blur/blur-10.png\" alt=\"image\">\u003c/p>\n\u003cp>还有一个要注意的问题就是这个滤镜要跑两次才行，就是 X\\Y 是分开来模糊的，如果一起的话，会变成斜方向的模糊。PIXI 中类似的实现参考\u003ca href=\"https://github.com/pixijs/pixi.js/blob/master/src/filters/blur/BlurFilter.js\">BlurFilter\u003c/a>，因为它也是 X、Y 两次模糊滤镜后的效果。以下是我 applyFilter 的代码：\u003c/p>\n\u003cpre>\u003ccode class=\"language-typescript\">var shader = this.getShader(renderer);\nvar renderTarget = renderer.filterManager.getRenderTarget(true);\nthis.uniforms.delta.value = {\n  x: this._delta / input.size.width,\n  y: 0,\n};\nrenderer.filterManager.applyFilter(shader, input, renderTarget, clear);\n\nthis.uniforms.delta.value = {\n  x: 0,\n  y: this._delta / input.size.height,\n};\nrenderer.filterManager.applyFilter(shader, renderTarget, output, clear);\n\n// 很重要，不加的话会引发内存泄漏\nrenderer.filterManager.returnRenderTarget(renderTarget);\n\u003c/code>\u003c/pre>\n\u003chr>\n\u003cp>最后贴出完整代码：\nTypescript、ES6 版本：\u003ca href=\"https://gist.github.com/Gaubee/54aa14b5e06ef8c3f5c25e1964c89fab#file-gaussianblur-ts\">Gaussianblur.ts\u003c/a>\nES5 版本：\u003ca href=\"https://gist.github.com/Gaubee/54aa14b5e06ef8c3f5c25e1964c89fab#file-gaussianblur-js\">Gaussianblur.js\u003c/a>\u003c/p>","markdownContent":"\n官方给出的模糊滤镜效果不尽人意，所以就想自己写一个，顺带学习了一些 WebGL 的作色器相关的基础知识。\n说真的网上的文章讲得不是很乱，以下是我总结出来的。\n\n## WebGL 作色器\n\n作色器的基本理念我不赘述。不了解的看下面猜测一下也能猜出个大概。\n这里从 PIXI.js 的源码中来看，用[blurXFilter](https://github.com/pixijs/pixi.js/blob/master/src/filters/blur/BlurXFilter.js)为例，顶点作色器的代码如下：\n\n```glsl /vert\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform float strength;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vBlurTexCoords[6];\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n```\n\n**顶点作色器**程序执行过程中需要数据，首先了解这三种数据：\n\n1. Attribute (从缓冲区对象中拉取数据)\n2. Uniform (在绘制过程中所有顶点都需要的、固定的数据值)\n3. Texture (像素/纹理元素数据)\n   **片元作色器**也需要数据，也是三种获取方式：\n4. Uniform (在绘制过程中每个像素都需要的、固定的变量值)\n5. Texture (像素/纹理元素数据)\n6. Varying (从顶点着色器传递过来并且经过内插过程的数据)\n\n简单的站在我这个新手的角度来说，我是这样看的：\nattribute 是 PIXI 框架传入的数据，顶点作色器最终的计算数据是反应到`gl_Position`上面。\nuniform 是用户自己传入的数据。\nvarying 是定点作色器和片元作色器的共享的数据。\n\n所以对比[默认的顶点作色器代码 TextureShader](https://github.com/pixijs/pixi.js/blob/039200b46d7840f065faa50739e4b98f69678db4/src/core/renderers/webgl/shaders/TextureShader.js#L74-L90)，可以看出有三行都是一样的：\n\n```glsl /vert\ngl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\nvTextureCoord = aTextureCoord;\nvColor = vec4(aColor.rgb * aColor.a, aColor.a);\n```\n\n不管这三行，看其它部分：\n\n```glsl /vert\n    vBlurTexCoords[ 0] = aTextureCoord + vec2(-0.012 * strength, 0.0);\n    vBlurTexCoords[ 1] = aTextureCoord + vec2(-0.008 * strength, 0.0);\n    vBlurTexCoords[ 2] = aTextureCoord + vec2(-0.004 * strength, 0.0);\n    vBlurTexCoords[ 3] = aTextureCoord + vec2( 0.004 * strength, 0.0);\n    vBlurTexCoords[ 4] = aTextureCoord + vec2( 0.008 * strength, 0.0);\n    vBlurTexCoords[ 5] = aTextureCoord + vec2( 0.012 * strength, 0.0);\n```\n\n当我把 strength 值调整到 100 后，是这样的效果：\n\n![image](/img/pixi-webgl-gaussian-blur/strength-100.png)\n\n我不得不诟病这个模糊效果（不然也不会有这篇文章了）。所以现在理解一下上面的代码：\n`vec2( X , Y)` 意味着一个偏移量，其中 Y=0，而`aTextureCoord`从命名理解就是**纹理坐标**，这里 j 把纹理贴图左右两边的数据拿了过来，在执行片元作色器的时候用上了：\n\n```glsl /frag\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vBlurTexCoords[6];\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = vec4(0.0);\n\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 0])*0.004431848411938341;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 1])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 2])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vTextureCoord     )*0.3989422804014327;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 3])*0.2419707245191454;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 4])*0.05399096651318985;\n    gl_FragColor += texture2D(uSampler, vBlurTexCoords[ 5])*0.004431848411938341;\n}\n```\n\n可以看到实现方式就是把左右纹理贴图的数据以渐变的方式贴到一个点上，最终看到的就是上面效果图展示的多层贴图以不同透明度重叠的效果。PS: `vColor`这个参数我猜是遮罩或者透明通道\n\n## 参考 glfx 实现高斯模糊\n\n对比[triangleblur.js](https://github.com/evanw/glfx.js/blob/master/src/filters/blur/triangleblur.js)。可以看出它的作色器代码其实是片元作色器代码，顶点作色器放空 null 使用默认。所以对比一下参数其实就好办了：\n其中`delta`这个参数都是用户传入的，剩下的只有`texture|texCoord`分别对应 PIXI.js 中的`uSampler|vTextureCoord`。\n\n所以代码关系对上后就好说了，接下来用 TypeScript 来实现 PIXI.js 中的高斯模糊滤镜。\n\n## PIXI.js 中高斯模糊的实现\n\n参考官方写法，先搭建出大概的类架构：\n\n```typescript\nclass GaussianBlur extends PIXI.AbstractFilter {\n  _delta: number;\n  constructor() {\n    let vert = \"\";\n    let frag = \"\";\n    super(vert, frag, {});\n  }\n  applyFilter(renderer, input, output, clear) {}\n  get blur() {\n    return this._delta;\n  }\n  set blur(value) {\n    this._delta = value;\n  }\n}\nexport default GaussianBlur;\n```\n\n然后就是要传入作色器代码了:\n\n```typescript\nvar randomShaderFunc =\n  \"\\\n    float random(vec3 scale, float seed) {\\\n        /* use the fragment position for a different seed per-pixel */\\\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\\\n    }\\\n\";\nlet vert = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform vec2 delta;\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vDelta;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n\n    vDelta = delta;\n\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}`;\nlet frag = `precision lowp float;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vDelta;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n${randomShaderFunc}\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    /* randomize the lookup values to hide the fixed number of samples */\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    for (float t = -30.0; t \u003c= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + vDelta * percent);\n\n        /* switch to pre-multiplied alpha to correctly blur transparent images */\n        sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n\n    /* switch back from pre-multiplied alpha */\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}`;\n```\n\n要注意的是，PIXI.js 的风格就是数据都是从顶点作色器那边传入的，所以 detal 参数就从顶点作色器那边进行赋值并在片元作色器那边使用。片元作色器那边基本就是把 glfx 的代码拷贝过来，然后把参数命名改成 PIXI 中的参数命名即可。要注意的是`precision lowp float;`这一句 glfx 没有，PIXI 中一定要加，好像是声明精度的问题，作为一个小白，暂时不理解，只是在做的过程中发现如果没有这句的话作色器编译的时候会报错。\n最终效果（blur=10）：\n\n![image](/img/pixi-webgl-gaussian-blur/blur-10.png)\n\n还有一个要注意的问题就是这个滤镜要跑两次才行，就是 X\\Y 是分开来模糊的，如果一起的话，会变成斜方向的模糊。PIXI 中类似的实现参考[BlurFilter](https://github.com/pixijs/pixi.js/blob/master/src/filters/blur/BlurFilter.js)，因为它也是 X、Y 两次模糊滤镜后的效果。以下是我 applyFilter 的代码：\n\n```typescript\nvar shader = this.getShader(renderer);\nvar renderTarget = renderer.filterManager.getRenderTarget(true);\nthis.uniforms.delta.value = {\n  x: this._delta / input.size.width,\n  y: 0,\n};\nrenderer.filterManager.applyFilter(shader, input, renderTarget, clear);\n\nthis.uniforms.delta.value = {\n  x: 0,\n  y: this._delta / input.size.height,\n};\nrenderer.filterManager.applyFilter(shader, renderTarget, output, clear);\n\n// 很重要，不加的话会引发内存泄漏\nrenderer.filterManager.returnRenderTarget(renderTarget);\n```\n\n---\n\n最后贴出完整代码：\nTypescript、ES6 版本：[Gaussianblur.ts](https://gist.github.com/Gaubee/54aa14b5e06ef8c3f5c25e1964c89fab#file-gaussianblur-ts)\nES5 版本：[Gaussianblur.js](https://gist.github.com/Gaubee/54aa14b5e06ef8c3f5c25e1964c89fab#file-gaussianblur-js)\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.CHhd62G8.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.zKRL1uyc.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-DcLnoLrn.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-BMsgTsFr.js" as="script" type="text/javascript">
      </body>
    </html>