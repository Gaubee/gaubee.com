<!DOCTYPE html>
    <html lang="en">
      <head>
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_css_index-e8e12f67.CaHEwVA7.css">
        <link rel="stylesheet" type="text/css" href="/assets/static/renderer_Layout-031b266d.CEjdw0pU.css">
        <meta charset="UTF-8" />
        <link rel="icon" href="/img/head.webp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="Gaubee&#039;s Blogs / Events / Projects" />
        <title>Gaubee&#039;s Site</title>
      </head>
      <body>
        <div id="root"><link rel="preload" as="image" href="img/head.webp"/><div style="display:flex;max-width:900px;margin:auto"><div style="display:flex;flex-direction:column;justify-content:space-between;max-height:100vh;width:38%;max-width:26em;position:sticky;top:0"><div id="sidebar" style="padding:20px;flex-shrink:0;display:flex;flex-direction:column;line-height:1.8em;border-right:2px solid #eee"><div style="margin-top:20px;margin-bottom:10px"><a href="/"><img src="img/head.webp" height="64" width="64" alt="logo"/></a></div><a href="/" class="">Timeline</a><a href="/projects" class="">Projects</a><a href="/about" class="">About</a></div><div style="padding:16px"><small>本网站不收集任何访问者的行为与信息，不做任何商业运作，仅仅为个人使用。</small><small style="display:block;margin-top:8px"><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">闽ICP备17026139号-1</a></small></div></div><div id="page-container"><div id="page-content" style="padding:20px;padding-bottom:50px;min-height:100vh"><h1>nodejs的自定义全局模块</h1><main><p>需求如下：
写了一个类：<code>function A(){/*...*/}</code>，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。
这里推荐三种方法：
<s>1. 重写require函数，加一层请求拦截的包裹。</s>
2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。
3. 将对象注册到底层模块列表中。
无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。
而第一种和第三种都要涉及到一个对象：<code>process.binding(&quot;natives&quot;)</code>；这里返回的将是原生模块的代码。
第三种无疑效率最高，实现方法如下：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8" tabindex="0"><code class="language-js"><span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">var</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> natives_modules </span><span style="color:#D73A49;--shiki-dark:#F97583">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> process.</span><span style="color:#6F42C1;--shiki-dark:#B392F0">binding</span><span style="color:#24292E;--shiki-dark:#E1E4E8">(</span><span style="color:#032F62;--shiki-dark:#9ECBFF">"natives"</span><span style="color:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">function</span><span style="color:#6F42C1;--shiki-dark:#B392F0"> defineAs</span><span style="color:#24292E;--shiki-dark:#E1E4E8">(</span><span style="color:#E36209;--shiki-dark:#FFAB70">module_name</span><span style="color:#24292E;--shiki-dark:#E1E4E8">, </span><span style="color:#E36209;--shiki-dark:#FFAB70">obj</span><span style="color:#24292E;--shiki-dark:#E1E4E8">){</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">    if</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> (natives_modules.</span><span style="color:#6F42C1;--shiki-dark:#B392F0">hasOwnProperty</span><span style="color:#24292E;--shiki-dark:#E1E4E8">(module_name)) {</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">        throw</span><span style="color:#6F42C1;--shiki-dark:#B392F0"> Error</span><span style="color:#24292E;--shiki-dark:#E1E4E8">(</span><span style="color:#032F62;--shiki-dark:#9ECBFF">"Module Name has be defined"</span><span style="color:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">    var</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> __module_uuid </span><span style="color:#D73A49;--shiki-dark:#F97583">=</span><span style="color:#D73A49;--shiki-dark:#F97583"> +new</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> Date </span><span style="color:#D73A49;--shiki-dark:#F97583">+</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> Math.</span><span style="color:#6F42C1;--shiki-dark:#B392F0">random</span><span style="color:#24292E;--shiki-dark:#E1E4E8">().</span><span style="color:#6F42C1;--shiki-dark:#B392F0">toString</span><span style="color:#24292E;--shiki-dark:#E1E4E8">(</span><span style="color:#005CC5;--shiki-dark:#79B8FF">32</span><span style="color:#24292E;--shiki-dark:#E1E4E8">);</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8">    global[__module_uuid] </span><span style="color:#D73A49;--shiki-dark:#F97583">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> obj;</span></span>
<span class="line"><span style="color:#D73A49;--shiki-dark:#F97583">    var</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> scriptContent </span><span style="color:#D73A49;--shiki-dark:#F97583">=</span><span style="color:#032F62;--shiki-dark:#9ECBFF"> 'module.exports = global["'</span><span style="color:#D73A49;--shiki-dark:#F97583">+</span><span style="color:#24292E;--shiki-dark:#E1E4E8">__module_uuid</span><span style="color:#D73A49;--shiki-dark:#F97583">+</span><span style="color:#032F62;--shiki-dark:#9ECBFF">'"]'</span><span style="color:#24292E;--shiki-dark:#E1E4E8">;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8">    natives_modules[module_name] </span><span style="color:#D73A49;--shiki-dark:#F97583">=</span><span style="color:#24292E;--shiki-dark:#E1E4E8"> scriptContent;</span></span>
<span class="line"><span style="color:#24292E;--shiki-dark:#E1E4E8">};</span></span>
<span class="line"><span style="color:#6A737D;--shiki-dark:#6A737D">//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。</span></span></code></pre>
<hr>
<p>不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。</p>
</main></div></div></div></div>
        <script id="vike_pageContext" type="application/json">{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"Custom-global-modules-for-nodejs"},"data":{"article":{"metadata":{"layout":"layouts/article.njk","title":"nodejs的自定义全局模块","date":"!Date:2015-02-23T16:31:49.000Z","updated":"!Date:2018-10-11T10:29:00.000Z","tags":["javascript","cogitation"],"id":"Custom-global-modules-for-nodejs","createdAt":"!Date:2015-02-23T16:31:49.000Z","updatedAt":"!Date:2018-10-11T10:29:00.000Z"},"htmlContent":"\u003cp>需求如下：\n写了一个类：\u003ccode>function A(){/*...*/}\u003c/code>，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。\n这里推荐三种方法：\n\u003cs>1. 重写require函数，加一层请求拦截的包裹。\u003c/s>\n2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。\n3. 将对象注册到底层模块列表中。\n无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。\n而第一种和第三种都要涉及到一个对象：\u003ccode>process.binding(&quot;natives&quot;)\u003c/code>；这里返回的将是原生模块的代码。\n第三种无疑效率最高，实现方法如下：\u003c/p>\n\u003cpre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\">\u003ccode class=\"language-js\">\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">var\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> natives_modules \u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">=\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> process.\u003c/span>\u003cspan style=\"color:#6F42C1;--shiki-dark:#B392F0\">binding\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">(\u003c/span>\u003cspan style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"natives\"\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">);\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">function\u003c/span>\u003cspan style=\"color:#6F42C1;--shiki-dark:#B392F0\"> defineAs\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">(\u003c/span>\u003cspan style=\"color:#E36209;--shiki-dark:#FFAB70\">module_name\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">, \u003c/span>\u003cspan style=\"color:#E36209;--shiki-dark:#FFAB70\">obj\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">){\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">    if\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> (natives_modules.\u003c/span>\u003cspan style=\"color:#6F42C1;--shiki-dark:#B392F0\">hasOwnProperty\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">(module_name)) {\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">        throw\u003c/span>\u003cspan style=\"color:#6F42C1;--shiki-dark:#B392F0\"> Error\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">(\u003c/span>\u003cspan style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"Module Name has be defined\"\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">);\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">    }\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">    var\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> __module_uuid \u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">=\u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\"> +new\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> Date \u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">+\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> Math.\u003c/span>\u003cspan style=\"color:#6F42C1;--shiki-dark:#B392F0\">random\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">().\u003c/span>\u003cspan style=\"color:#6F42C1;--shiki-dark:#B392F0\">toString\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">(\u003c/span>\u003cspan style=\"color:#005CC5;--shiki-dark:#79B8FF\">32\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">);\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">    global[__module_uuid] \u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">=\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> obj;\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">    var\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> scriptContent \u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">=\u003c/span>\u003cspan style=\"color:#032F62;--shiki-dark:#9ECBFF\"> 'module.exports = global[\"'\u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">+\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">__module_uuid\u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">+\u003c/span>\u003cspan style=\"color:#032F62;--shiki-dark:#9ECBFF\">'\"]'\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">;\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">    natives_modules[module_name] \u003c/span>\u003cspan style=\"color:#D73A49;--shiki-dark:#F97583\">=\u003c/span>\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\"> scriptContent;\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#24292E;--shiki-dark:#E1E4E8\">};\u003c/span>\u003c/span>\n\u003cspan class=\"line\">\u003cspan style=\"color:#6A737D;--shiki-dark:#6A737D\">//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。\u003c/span>\u003c/span>\u003c/code>\u003c/pre>\n\u003chr>\n\u003cp>不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。\u003c/p>\n","markdownContent":"\n需求如下：\n写了一个类：`function A(){/*...*/}`，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。\n这里推荐三种方法：\n~~1. 重写require函数，加一层请求拦截的包裹。~~\n2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。\n3. 将对象注册到底层模块列表中。\n无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。\n而第一种和第三种都要涉及到一个对象：`process.binding(\"natives\")`；这里返回的将是原生模块的代码。\n第三种无疑效率最高，实现方法如下：\n\n``` js\nvar natives_modules = process.binding(\"natives\");\nfunction defineAs(module_name, obj){\n    if (natives_modules.hasOwnProperty(module_name)) {\n        throw Error(\"Module Name has be defined\");\n    }\n    var __module_uuid = +new Date + Math.random().toString(32);\n    global[__module_uuid] = obj;\n    var scriptContent = 'module.exports = global[\"'+__module_uuid+'\"]';\n    natives_modules[module_name] = scriptContent;\n};\n//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。\n```\n\n---\n\n不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。\n"}}}</script>
        <script src="/assets/entries/entry-client-routing.yiSdiVxD.js" type="module" async></script>
        <link rel="modulepreload" href="/assets/entries/pages_article_-id.BmaUqteM.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-CDWRLuPF.js" as="script" type="text/javascript">
        <link rel="modulepreload" href="/assets/chunks/chunk-BsHr0IPV.js" as="script" type="text/javascript">
      </body>
    </html>