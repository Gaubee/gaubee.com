{"abortReason":"!undefined","_urlRewrite":null,"_urlRedirect":"!undefined","abortStatusCode":"!undefined","_abortCall":"!undefined","_pageContextInitIsPassedToClient":"!undefined","pageId":"/pages/article/@id","routeParams":{"id":"Custom-global-modules-for-nodejs"},"data":{"article":{"metadata":{"layout":"layouts/article.njk","title":"nodejs的自定义全局模块","date":"!Date:2015-02-23T16:31:49.000Z","updated":"!Date:2018-10-11T10:29:00.000Z","tags":["javascript","cogitation"],"id":"Custom-global-modules-for-nodejs","createdAt":"!Date:2015-02-23T16:31:49.000Z","updatedAt":"!Date:2018-10-11T10:29:00.000Z"},"htmlContent":"<p>需求如下：\n写了一个类：<code>function A(){/*...*/}</code>，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。\n这里推荐三种方法：\n<s>1. 重写require函数，加一层请求拦截的包裹。</s>\n2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。\n3. 将对象注册到底层模块列表中。\n无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。\n而第一种和第三种都要涉及到一个对象：<code>process.binding(&quot;natives&quot;)</code>；这里返回的将是原生模块的代码。\n第三种无疑效率最高，实现方法如下：</p>\n<pre class=\"shiki shiki-themes github-light github-dark\" style=\"background-color:#fff;--shiki-dark-bg:#24292e;color:#24292e;--shiki-dark:#e1e4e8\" tabindex=\"0\"><code class=\"language-js\"><span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">var</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> natives_modules </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> process.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">binding</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"natives\"</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">function</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> defineAs</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#E36209;--shiki-dark:#FFAB70\">module_name</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">, </span><span style=\"color:#E36209;--shiki-dark:#FFAB70\">obj</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">    if</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> (natives_modules.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">hasOwnProperty</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(module_name)) {</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">        throw</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\"> Error</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">\"Module Name has be defined\"</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">    var</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> __module_uuid </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#D73A49;--shiki-dark:#F97583\"> +new</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> Date </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">+</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> Math.</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">random</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">().</span><span style=\"color:#6F42C1;--shiki-dark:#B392F0\">toString</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">(</span><span style=\"color:#005CC5;--shiki-dark:#79B8FF\">32</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    global[__module_uuid] </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> obj;</span></span>\n<span class=\"line\"><span style=\"color:#D73A49;--shiki-dark:#F97583\">    var</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> scriptContent </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\"> 'module.exports = global[\"'</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">+</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">__module_uuid</span><span style=\"color:#D73A49;--shiki-dark:#F97583\">+</span><span style=\"color:#032F62;--shiki-dark:#9ECBFF\">'\"]'</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">    natives_modules[module_name] </span><span style=\"color:#D73A49;--shiki-dark:#F97583\">=</span><span style=\"color:#24292E;--shiki-dark:#E1E4E8\"> scriptContent;</span></span>\n<span class=\"line\"><span style=\"color:#24292E;--shiki-dark:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#6A737D;--shiki-dark:#6A737D\">//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。</span></span></code></pre>\n<hr>\n<p>不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。</p>\n","markdownContent":"\n需求如下：\n写了一个类：`function A(){/*...*/}`，然后想给他暴露到全局中，作为一个可require的模块，无需再通过路径查找获取。\n这里推荐三种方法：\n~~1. 重写require函数，加一层请求拦截的包裹。~~\n2. 根据process.mainModule.filename来获取对应的node_modules文件夹，在里面创建对应的临时文件来进行链接。\n3. 将对象注册到底层模块列表中。\n无论哪种方法，最重要的还是要避免跟系统模块名字冲突。其中第二种有点投机取巧，因为设计到文件的读写，进程意外中断导致文件残留等等不方便的因素导致我并不推荐。\n而第一种和第三种都要涉及到一个对象：`process.binding(\"natives\")`；这里返回的将是原生模块的代码。\n第三种无疑效率最高，实现方法如下：\n\n``` js\nvar natives_modules = process.binding(\"natives\");\nfunction defineAs(module_name, obj){\n    if (natives_modules.hasOwnProperty(module_name)) {\n        throw Error(\"Module Name has be defined\");\n    }\n    var __module_uuid = +new Date + Math.random().toString(32);\n    global[__module_uuid] = obj;\n    var scriptContent = 'module.exports = global[\"'+__module_uuid+'\"]';\n    natives_modules[module_name] = scriptContent;\n};\n//PS：如果你用iojs，__module_uuid可以换成Symbol对象会更好。\n```\n\n---\n\n不过话说回来，不用require函数名，为这些模块的加载方法另外取名字无疑是最简单粗暴的选择，只是说，使用统一的API，即便是后来你把代码封装发布到npm上，也能使原本的代码好好工作，不是很好么。\n"}}}